<html>
<head>
<title>_psosx.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_psosx.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.</span>
<span class="s0"># Use of this source code is governed by a BSD-style license that can be</span>
<span class="s0"># found in the LICENSE file.</span>

<span class="s2">&quot;&quot;&quot;macOS platform implementation.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_common</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psposix</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_osx </span><span class="s3">as </span><span class="s1">cext</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_posix </span><span class="s3">as </span><span class="s1">cext_posix</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">AccessDenied</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NoSuchProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">ZombieProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">conn_tmap</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">conn_to_ntuple</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">isfile_strict</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize_when_activated</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">parse_environ_block</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">usage_percent</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PermissionError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">ProcessLookupError</span>


<span class="s1">__extra__all__ = []</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- globals</span>
<span class="s0"># =====================================================================</span>


<span class="s1">PAGESIZE = cext_posix.getpagesize()</span>
<span class="s1">AF_LINK = cext_posix.AF_LINK</span>

<span class="s1">TCP_STATUSES = {</span>
    <span class="s1">cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_SYN_RECEIVED: _common.CONN_SYN_RECV</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSED: _common.CONN_CLOSE</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_LISTEN: _common.CONN_LISTEN</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSING: _common.CONN_CLOSING</span><span class="s3">,</span>
    <span class="s1">cext.PSUTIL_CONN_NONE: _common.CONN_NONE</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">PROC_STATUSES = {</span>
    <span class="s1">cext.SIDL: _common.STATUS_IDLE</span><span class="s3">,</span>
    <span class="s1">cext.SRUN: _common.STATUS_RUNNING</span><span class="s3">,</span>
    <span class="s1">cext.SSLEEP: _common.STATUS_SLEEPING</span><span class="s3">,</span>
    <span class="s1">cext.SSTOP: _common.STATUS_STOPPED</span><span class="s3">,</span>
    <span class="s1">cext.SZOMB: _common.STATUS_ZOMBIE</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">kinfo_proc_map = dict(</span>
    <span class="s1">ppid=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">ruid=</span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">euid=</span><span class="s4">2</span><span class="s3">,</span>
    <span class="s1">suid=</span><span class="s4">3</span><span class="s3">,</span>
    <span class="s1">rgid=</span><span class="s4">4</span><span class="s3">,</span>
    <span class="s1">egid=</span><span class="s4">5</span><span class="s3">,</span>
    <span class="s1">sgid=</span><span class="s4">6</span><span class="s3">,</span>
    <span class="s1">ttynr=</span><span class="s4">7</span><span class="s3">,</span>
    <span class="s1">ctime=</span><span class="s4">8</span><span class="s3">,</span>
    <span class="s1">status=</span><span class="s4">9</span><span class="s3">,</span>
    <span class="s1">name=</span><span class="s4">10</span><span class="s3">,</span>
<span class="s1">)</span>

<span class="s1">pidtaskinfo_map = dict(</span>
    <span class="s1">cpuutime=</span><span class="s4">0</span><span class="s3">,</span>
    <span class="s1">cpustime=</span><span class="s4">1</span><span class="s3">,</span>
    <span class="s1">rss=</span><span class="s4">2</span><span class="s3">,</span>
    <span class="s1">vms=</span><span class="s4">3</span><span class="s3">,</span>
    <span class="s1">pfaults=</span><span class="s4">4</span><span class="s3">,</span>
    <span class="s1">pageins=</span><span class="s4">5</span><span class="s3">,</span>
    <span class="s1">numthreads=</span><span class="s4">6</span><span class="s3">,</span>
    <span class="s1">volctxsw=</span><span class="s4">7</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- named tuples</span>
<span class="s0"># =====================================================================</span>


<span class="s0"># psutil.cpu_times()</span>
<span class="s1">scputimes = namedtuple(</span><span class="s5">'scputimes'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'user'</span><span class="s3">, </span><span class="s5">'nice'</span><span class="s3">, </span><span class="s5">'system'</span><span class="s3">, </span><span class="s5">'idle'</span><span class="s1">])</span>
<span class="s0"># psutil.virtual_memory()</span>
<span class="s1">svmem = namedtuple(</span>
    <span class="s5">'svmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'total'</span><span class="s3">, </span><span class="s5">'available'</span><span class="s3">, </span><span class="s5">'percent'</span><span class="s3">, </span><span class="s5">'used'</span><span class="s3">, </span><span class="s5">'free'</span><span class="s3">,</span>
              <span class="s5">'active'</span><span class="s3">, </span><span class="s5">'inactive'</span><span class="s3">, </span><span class="s5">'wired'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_info()</span>
<span class="s1">pmem = namedtuple(</span><span class="s5">'pmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'rss'</span><span class="s3">, </span><span class="s5">'vms'</span><span class="s3">, </span><span class="s5">'pfaults'</span><span class="s3">, </span><span class="s5">'pageins'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_full_info()</span>
<span class="s1">pfullmem = namedtuple(</span><span class="s5">'pfullmem'</span><span class="s3">, </span><span class="s1">pmem._fields + (</span><span class="s5">'uss'</span><span class="s3">, </span><span class="s1">))</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- memory</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">virtual_memory():</span>
    <span class="s2">&quot;&quot;&quot;System virtual memory as a namedtuple.&quot;&quot;&quot;</span>
    <span class="s1">total</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">inactive</span><span class="s3">, </span><span class="s1">wired</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">speculative = cext.virtual_mem()</span>
    <span class="s0"># This is how Zabbix calculate avail and used mem:</span>
    <span class="s0"># https://github.com/zabbix/zabbix/blob/trunk/src/libs/zbxsysinfo/</span>
    <span class="s0">#     osx/memory.c</span>
    <span class="s0"># Also see: https://github.com/giampaolo/psutil/issues/1277</span>
    <span class="s1">avail = inactive + free</span>
    <span class="s1">used = active + wired</span>
    <span class="s0"># This is NOT how Zabbix calculates free mem but it matches &quot;free&quot;</span>
    <span class="s0"># cmdline utility.</span>
    <span class="s1">free -= speculative</span>
    <span class="s1">percent = usage_percent((total - avail)</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">svmem(total</span><span class="s3">, </span><span class="s1">avail</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">,</span>
                 <span class="s1">active</span><span class="s3">, </span><span class="s1">inactive</span><span class="s3">, </span><span class="s1">wired)</span>


<span class="s3">def </span><span class="s1">swap_memory():</span>
    <span class="s2">&quot;&quot;&quot;Swap system memory as a (total, used, free, sin, sout) tuple.&quot;&quot;&quot;</span>
    <span class="s1">total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout = cext.swap_mem()</span>
    <span class="s1">percent = usage_percent(used</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_common.sswap(total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- CPU</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system CPU times as a namedtuple.&quot;&quot;&quot;</span>
    <span class="s1">user</span><span class="s3">, </span><span class="s1">nice</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle = cext.cpu_times()</span>
    <span class="s3">return </span><span class="s1">scputimes(user</span><span class="s3">, </span><span class="s1">nice</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle)</span>


<span class="s3">def </span><span class="s1">per_cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system CPU times as a named tuple&quot;&quot;&quot;</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">cpu_t </span><span class="s3">in </span><span class="s1">cext.per_cpu_times():</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">nice</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle = cpu_t</span>
        <span class="s1">item = scputimes(user</span><span class="s3">, </span><span class="s1">nice</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle)</span>
        <span class="s1">ret.append(item)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">cpu_count_logical():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of logical CPUs in the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.cpu_count_logical()</span>


<span class="s3">def </span><span class="s1">cpu_count_cores():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of CPU cores in the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.cpu_count_cores()</span>


<span class="s3">def </span><span class="s1">cpu_stats():</span>
    <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">, </span><span class="s1">syscalls</span><span class="s3">, </span><span class="s1">traps = \</span>
        <span class="s1">cext.cpu_stats()</span>
    <span class="s3">return </span><span class="s1">_common.scpustats(</span>
        <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">, </span><span class="s1">syscalls)</span>


<span class="s3">def </span><span class="s1">cpu_freq():</span>
    <span class="s2">&quot;&quot;&quot;Return CPU frequency. 
    On macOS per-cpu frequency is not supported. 
    Also, the returned frequency never changes, see: 
    https://arstechnica.com/civis/viewtopic.php?f=19&amp;t=465002 
    &quot;&quot;&quot;</span>
    <span class="s1">curr</span><span class="s3">, </span><span class="s1">min_</span><span class="s3">, </span><span class="s1">max_ = cext.cpu_freq()</span>
    <span class="s3">return </span><span class="s1">[_common.scpufreq(curr</span><span class="s3">, </span><span class="s1">min_</span><span class="s3">, </span><span class="s1">max_)]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- disks</span>
<span class="s0"># =====================================================================</span>


<span class="s1">disk_usage = _psposix.disk_usage</span>
<span class="s1">disk_io_counters = cext.disk_io_counters</span>


<span class="s3">def </span><span class="s1">disk_partitions(all=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return mounted disk partitions as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">retlist = []</span>
    <span class="s1">partitions = cext.disk_partitions()</span>
    <span class="s3">for </span><span class="s1">partition </span><span class="s3">in </span><span class="s1">partitions:</span>
        <span class="s1">device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts = partition</span>
        <span class="s3">if </span><span class="s1">device == </span><span class="s5">'none'</span><span class="s1">:</span>
            <span class="s1">device = </span><span class="s5">''</span>
        <span class="s3">if not </span><span class="s1">all:</span>
            <span class="s3">if not </span><span class="s1">os.path.isabs(device) </span><span class="s3">or not </span><span class="s1">os.path.exists(device):</span>
                <span class="s3">continue</span>
        <span class="s1">maxfile = maxpath = </span><span class="s3">None  </span><span class="s0"># set later</span>
        <span class="s1">ntuple = _common.sdiskpart(device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">,</span>
                                   <span class="s1">maxfile</span><span class="s3">, </span><span class="s1">maxpath)</span>
        <span class="s1">retlist.append(ntuple)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- sensors</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">sensors_battery():</span>
    <span class="s2">&quot;&quot;&quot;Return battery information.&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">percent</span><span class="s3">, </span><span class="s1">minsleft</span><span class="s3">, </span><span class="s1">power_plugged = cext.sensors_battery()</span>
    <span class="s3">except </span><span class="s1">NotImplementedError:</span>
        <span class="s0"># no power source - return None according to interface</span>
        <span class="s3">return None</span>
    <span class="s1">power_plugged = power_plugged == </span><span class="s4">1</span>
    <span class="s3">if </span><span class="s1">power_plugged:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNLIMITED</span>
    <span class="s3">elif </span><span class="s1">minsleft == -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNKNOWN</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">secsleft = minsleft * </span><span class="s4">60</span>
    <span class="s3">return </span><span class="s1">_common.sbattery(percent</span><span class="s3">, </span><span class="s1">secsleft</span><span class="s3">, </span><span class="s1">power_plugged)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- network</span>
<span class="s0"># =====================================================================</span>


<span class="s1">net_io_counters = cext.net_io_counters</span>
<span class="s1">net_if_addrs = cext_posix.net_if_addrs</span>


<span class="s3">def </span><span class="s1">net_connections(kind=</span><span class="s5">'inet'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;System-wide network connections.&quot;&quot;&quot;</span>
    <span class="s0"># Note: on macOS this will fail with AccessDenied unless</span>
    <span class="s0"># the process is owned by root.</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">pid </span><span class="s3">in </span><span class="s1">pids():</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">cons = Process(pid).connections(kind)</span>
        <span class="s3">except </span><span class="s1">NoSuchProcess:</span>
            <span class="s3">continue</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">cons:</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cons:</span>
                    <span class="s1">c = list(c) + [pid]</span>
                    <span class="s1">ret.append(_common.sconn(*c))</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">net_if_stats():</span>
    <span class="s2">&quot;&quot;&quot;Get NIC stats (isup, duplex, speed, mtu).&quot;&quot;&quot;</span>
    <span class="s1">names = net_io_counters().keys()</span>
    <span class="s1">ret = {}</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">mtu = cext_posix.net_if_mtu(name)</span>
            <span class="s1">flags = cext_posix.net_if_flags(name)</span>
            <span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed = cext_posix.net_if_duplex_speed(name)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1279</span>
            <span class="s3">if </span><span class="s1">err.errno != errno.ENODEV:</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">hasattr(_common</span><span class="s3">, </span><span class="s5">'NicDuplex'</span><span class="s1">):</span>
                <span class="s1">duplex = _common.NicDuplex(duplex)</span>
            <span class="s1">output_flags = </span><span class="s5">','</span><span class="s1">.join(flags)</span>
            <span class="s1">isup = </span><span class="s5">'running' </span><span class="s3">in </span><span class="s1">flags</span>
            <span class="s1">ret[name] = _common.snicstats(isup</span><span class="s3">, </span><span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">mtu</span><span class="s3">,</span>
                                          <span class="s1">output_flags)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- other system functions</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">boot_time():</span>
    <span class="s2">&quot;&quot;&quot;The system boot time expressed in seconds since the epoch.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.boot_time()</span>


<span class="s3">def </span><span class="s1">users():</span>
    <span class="s2">&quot;&quot;&quot;Return currently connected users as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">retlist = []</span>
    <span class="s1">rawlist = cext.users()</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">tty</span><span class="s3">, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">pid = item</span>
        <span class="s3">if </span><span class="s1">tty == </span><span class="s5">'~'</span><span class="s1">:</span>
            <span class="s3">continue  </span><span class="s0"># reboot or shutdown</span>
        <span class="s3">if not </span><span class="s1">tstamp:</span>
            <span class="s3">continue</span>
        <span class="s1">nt = _common.suser(user</span><span class="s3">, </span><span class="s1">tty </span><span class="s3">or None, </span><span class="s1">hostname </span><span class="s3">or None, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">pid)</span>
        <span class="s1">retlist.append(nt)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- processes</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">pids():</span>
    <span class="s1">ls = cext.pids()</span>
    <span class="s3">if </span><span class="s4">0 </span><span class="s3">not in </span><span class="s1">ls:</span>
        <span class="s0"># On certain macOS versions pids() C doesn't return PID 0 but</span>
        <span class="s0"># &quot;ps&quot; does and the process is querable via sysctl():</span>
        <span class="s0"># https://travis-ci.org/giampaolo/psutil/jobs/309619941</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">Process(</span><span class="s4">0</span><span class="s1">).create_time()</span>
            <span class="s1">ls.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">NoSuchProcess:</span>
            <span class="s3">pass</span>
        <span class="s3">except </span><span class="s1">AccessDenied:</span>
            <span class="s1">ls.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">ls</span>


<span class="s1">pid_exists = _psposix.pid_exists</span>


<span class="s3">def </span><span class="s1">is_zombie(pid):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">st = cext.proc_kinfo_oneshot(pid)[kinfo_proc_map[</span><span class="s5">'status'</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">st == cext.SZOMB</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">wrap_exceptions(fun):</span>
    <span class="s2">&quot;&quot;&quot;Decorator which translates bare OSError exceptions into 
    NoSuchProcess and AccessDenied. 
    &quot;&quot;&quot;</span>
    <span class="s1">@functools.wraps(fun)</span>
    <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">except </span><span class="s1">ProcessLookupError:</span>
            <span class="s3">if </span><span class="s1">is_zombie(self.pid):</span>
                <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">except </span><span class="s1">PermissionError:</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">except </span><span class="s1">cext.ZombieProcessError:</span>
            <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">Process(object):</span>
    <span class="s2">&quot;&quot;&quot;Wrapper class around underlying C implementation.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span><span class="s5">&quot;pid&quot;</span><span class="s3">, </span><span class="s5">&quot;_name&quot;</span><span class="s3">, </span><span class="s5">&quot;_ppid&quot;</span><span class="s3">, </span><span class="s5">&quot;_cache&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pid):</span>
        <span class="s1">self.pid = pid</span>
        <span class="s1">self._name = </span><span class="s3">None</span>
        <span class="s1">self._ppid = </span><span class="s3">None</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_get_kinfo_proc(self):</span>
        <span class="s0"># Note: should work with all PIDs without permission issues.</span>
        <span class="s1">ret = cext.proc_kinfo_oneshot(self.pid)</span>
        <span class="s3">assert </span><span class="s1">len(ret) == len(kinfo_proc_map)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_get_pidtaskinfo(self):</span>
        <span class="s0"># Note: should work for PIDs owned by user only.</span>
        <span class="s1">ret = cext.proc_pidtaskinfo_oneshot(self.pid)</span>
        <span class="s3">assert </span><span class="s1">len(ret) == len(pidtaskinfo_map)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">oneshot_enter(self):</span>
        <span class="s1">self._get_kinfo_proc.cache_activate(self)</span>
        <span class="s1">self._get_pidtaskinfo.cache_activate(self)</span>

    <span class="s3">def </span><span class="s1">oneshot_exit(self):</span>
        <span class="s1">self._get_kinfo_proc.cache_deactivate(self)</span>
        <span class="s1">self._get_pidtaskinfo.cache_deactivate(self)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s1">name = self._get_kinfo_proc()[kinfo_proc_map[</span><span class="s5">'name'</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">name </span><span class="s3">if </span><span class="s1">name </span><span class="s3">is not None else </span><span class="s1">cext.proc_name(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">exe(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_exe(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cmdline(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_cmdline(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">environ(self):</span>
        <span class="s3">return </span><span class="s1">parse_environ_block(cext.proc_environ(self.pid))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">ppid(self):</span>
        <span class="s1">self._ppid = self._get_kinfo_proc()[kinfo_proc_map[</span><span class="s5">'ppid'</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">self._ppid</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cwd(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_cwd(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">uids(self):</span>
        <span class="s1">rawtuple = self._get_kinfo_proc()</span>
        <span class="s3">return </span><span class="s1">_common.puids(</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'ruid'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'euid'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'suid'</span><span class="s1">]])</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">gids(self):</span>
        <span class="s1">rawtuple = self._get_kinfo_proc()</span>
        <span class="s3">return </span><span class="s1">_common.puids(</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'rgid'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'egid'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[kinfo_proc_map[</span><span class="s5">'sgid'</span><span class="s1">]])</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">terminal(self):</span>
        <span class="s1">tty_nr = self._get_kinfo_proc()[kinfo_proc_map[</span><span class="s5">'ttynr'</span><span class="s1">]]</span>
        <span class="s1">tmap = _psposix.get_terminal_map()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tmap[tty_nr]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return None</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_info(self):</span>
        <span class="s1">rawtuple = self._get_pidtaskinfo()</span>
        <span class="s3">return </span><span class="s1">pmem(</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'rss'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'vms'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'pfaults'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'pageins'</span><span class="s1">]]</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_full_info(self):</span>
        <span class="s1">basic_mem = self.memory_info()</span>
        <span class="s1">uss = cext.proc_memory_uss(self.pid)</span>
        <span class="s3">return </span><span class="s1">pfullmem(*basic_mem + (uss</span><span class="s3">, </span><span class="s1">))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_times(self):</span>
        <span class="s1">rawtuple = self._get_pidtaskinfo()</span>
        <span class="s3">return </span><span class="s1">_common.pcputimes(</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'cpuutime'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">rawtuple[pidtaskinfo_map[</span><span class="s5">'cpustime'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s0"># children user / system times are not retrievable (set to 0)</span>
            <span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">create_time(self):</span>
        <span class="s3">return </span><span class="s1">self._get_kinfo_proc()[kinfo_proc_map[</span><span class="s5">'ctime'</span><span class="s1">]]</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_ctx_switches(self):</span>
        <span class="s0"># Unvoluntary value seems not to be available;</span>
        <span class="s0"># getrusage() numbers seems to confirm this theory.</span>
        <span class="s0"># We set it to 0.</span>
        <span class="s1">vol = self._get_pidtaskinfo()[pidtaskinfo_map[</span><span class="s5">'volctxsw'</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">_common.pctxsw(vol</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_threads(self):</span>
        <span class="s3">return </span><span class="s1">self._get_pidtaskinfo()[pidtaskinfo_map[</span><span class="s5">'numthreads'</span><span class="s1">]]</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">open_files(self):</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">files = []</span>
        <span class="s1">rawlist = cext.proc_open_files(self.pid)</span>
        <span class="s3">for </span><span class="s1">path</span><span class="s3">, </span><span class="s1">fd </span><span class="s3">in </span><span class="s1">rawlist:</span>
            <span class="s3">if </span><span class="s1">isfile_strict(path):</span>
                <span class="s1">ntuple = _common.popenfile(path</span><span class="s3">, </span><span class="s1">fd)</span>
                <span class="s1">files.append(ntuple)</span>
        <span class="s3">return </span><span class="s1">files</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">connections(self</span><span class="s3">, </span><span class="s1">kind=</span><span class="s5">'inet'</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">kind </span><span class="s3">not in </span><span class="s1">conn_tmap:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;invalid %r kind argument; choose between %s&quot;</span>
                             <span class="s1">% (kind</span><span class="s3">, </span><span class="s5">', '</span><span class="s1">.join([repr(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">conn_tmap])))</span>
        <span class="s1">families</span><span class="s3">, </span><span class="s1">types = conn_tmap[kind]</span>
        <span class="s1">rawlist = cext.proc_connections(self.pid</span><span class="s3">, </span><span class="s1">families</span><span class="s3">, </span><span class="s1">types)</span>
        <span class="s1">ret = []</span>
        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
            <span class="s1">fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status = item</span>
            <span class="s1">nt = conn_to_ntuple(fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">,</span>
                                <span class="s1">TCP_STATUSES)</span>
            <span class="s1">ret.append(nt)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_fds(self):</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">0</span>
        <span class="s3">return </span><span class="s1">cext.proc_num_fds(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">wait(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">_psposix.wait_pid(self.pid</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">self._name)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_get(self):</span>
        <span class="s3">return </span><span class="s1">cext_posix.getpriority(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_set(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">cext_posix.setpriority(self.pid</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">status(self):</span>
        <span class="s1">code = self._get_kinfo_proc()[kinfo_proc_map[</span><span class="s5">'status'</span><span class="s1">]]</span>
        <span class="s0"># XXX is '?' legit? (we're not supposed to return it anyway)</span>
        <span class="s3">return </span><span class="s1">PROC_STATUSES.get(code</span><span class="s3">, </span><span class="s5">'?'</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">threads(self):</span>
        <span class="s1">rawlist = cext.proc_threads(self.pid)</span>
        <span class="s1">retlist = []</span>
        <span class="s3">for </span><span class="s1">thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime </span><span class="s3">in </span><span class="s1">rawlist:</span>
            <span class="s1">ntuple = _common.pthread(thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime)</span>
            <span class="s1">retlist.append(ntuple)</span>
        <span class="s3">return </span><span class="s1">retlist</span>
</pre>
</body>
</html>
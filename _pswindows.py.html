<html>
<head>
<title>_pswindows.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_pswindows.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.</span>
<span class="s0"># Use of this source code is governed by a BSD-style license that can be</span>
<span class="s0"># found in the LICENSE file.</span>

<span class="s2">&quot;&quot;&quot;Windows platform implementation.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">signal</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_common</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">ENCODING</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">ENCODING_ERRS</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">AccessDenied</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NoSuchProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">TimeoutExpired</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">conn_tmap</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">conn_to_ntuple</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">debug</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">isfile_strict</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize_when_activated</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">parse_environ_block</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">usage_percent</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PY3</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">long</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">lru_cache</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">range</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">unicode</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">ABOVE_NORMAL_PRIORITY_CLASS</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">BELOW_NORMAL_PRIORITY_CLASS</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">HIGH_PRIORITY_CLASS</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">IDLE_PRIORITY_CLASS</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">NORMAL_PRIORITY_CLASS</span>
<span class="s3">from </span><span class="s1">._psutil_windows </span><span class="s3">import </span><span class="s1">REALTIME_PRIORITY_CLASS</span>


<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_windows </span><span class="s3">as </span><span class="s1">cext</span>
<span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">err:</span>
    <span class="s3">if </span><span class="s1">str(err).lower().startswith(</span><span class="s4">&quot;dll load failed&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">\</span>
            <span class="s1">sys.getwindowsversion()[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s0"># We may get here if:</span>
        <span class="s0"># 1) we are on an old Windows version</span>
        <span class="s0"># 2) psutil was installed via pip + wheel</span>
        <span class="s0"># See: https://github.com/giampaolo/psutil/issues/811</span>
        <span class="s1">msg = </span><span class="s4">&quot;this Windows version is too old (&lt; Windows Vista); &quot;</span>
        <span class="s1">msg += </span><span class="s4">&quot;psutil 3.4.2 is the latest version which supports Windows &quot;</span>
        <span class="s1">msg += </span><span class="s4">&quot;2000, XP and 2003 server&quot;</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(msg)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise</span>

<span class="s3">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
    <span class="s3">import </span><span class="s1">enum</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">enum = </span><span class="s3">None</span>

<span class="s0"># process priority constants, import from __init__.py:</span>
<span class="s0"># http://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx</span>
<span class="s1">__extra__all__ = [</span>
    <span class="s4">&quot;win_service_iter&quot;</span><span class="s3">, </span><span class="s4">&quot;win_service_get&quot;</span><span class="s3">,</span>
    <span class="s0"># Process priority</span>
    <span class="s4">&quot;ABOVE_NORMAL_PRIORITY_CLASS&quot;</span><span class="s3">, </span><span class="s4">&quot;BELOW_NORMAL_PRIORITY_CLASS&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;HIGH_PRIORITY_CLASS&quot;</span><span class="s3">, </span><span class="s4">&quot;IDLE_PRIORITY_CLASS&quot;</span><span class="s3">, </span><span class="s4">&quot;NORMAL_PRIORITY_CLASS&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;REALTIME_PRIORITY_CLASS&quot;</span><span class="s3">,</span>
    <span class="s0"># IO priority</span>
    <span class="s4">&quot;IOPRIO_VERYLOW&quot;</span><span class="s3">, </span><span class="s4">&quot;IOPRIO_LOW&quot;</span><span class="s3">, </span><span class="s4">&quot;IOPRIO_NORMAL&quot;</span><span class="s3">, </span><span class="s4">&quot;IOPRIO_HIGH&quot;</span><span class="s3">,</span>
    <span class="s0"># others</span>
    <span class="s4">&quot;CONN_DELETE_TCB&quot;</span><span class="s3">, </span><span class="s4">&quot;AF_LINK&quot;</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- globals</span>
<span class="s0"># =====================================================================</span>

<span class="s1">CONN_DELETE_TCB = </span><span class="s4">&quot;DELETE_TCB&quot;</span>
<span class="s1">ERROR_PARTIAL_COPY = </span><span class="s5">299</span>
<span class="s1">PYPY = </span><span class="s4">'__pypy__' </span><span class="s3">in </span><span class="s1">sys.builtin_module_names</span>

<span class="s3">if </span><span class="s1">enum </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">AF_LINK = -</span><span class="s5">1</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">AddressFamily = enum.IntEnum(</span><span class="s4">'AddressFamily'</span><span class="s3">, </span><span class="s1">{</span><span class="s4">'AF_LINK'</span><span class="s1">: -</span><span class="s5">1</span><span class="s1">})</span>
    <span class="s1">AF_LINK = AddressFamily.AF_LINK</span>

<span class="s1">TCP_STATUSES = {</span>
    <span class="s1">cext.MIB_TCP_STATE_ESTAB: _common.CONN_ESTABLISHED</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_SYN_SENT: _common.CONN_SYN_SENT</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_SYN_RCVD: _common.CONN_SYN_RECV</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_FIN_WAIT1: _common.CONN_FIN_WAIT1</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_FIN_WAIT2: _common.CONN_FIN_WAIT2</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_TIME_WAIT: _common.CONN_TIME_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_CLOSED: _common.CONN_CLOSE</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_CLOSE_WAIT: _common.CONN_CLOSE_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_LAST_ACK: _common.CONN_LAST_ACK</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_LISTEN: _common.CONN_LISTEN</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_CLOSING: _common.CONN_CLOSING</span><span class="s3">,</span>
    <span class="s1">cext.MIB_TCP_STATE_DELETE_TCB: CONN_DELETE_TCB</span><span class="s3">,</span>
    <span class="s1">cext.PSUTIL_CONN_NONE: _common.CONN_NONE</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s3">if </span><span class="s1">enum </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">class </span><span class="s1">Priority(enum.IntEnum):</span>
        <span class="s1">ABOVE_NORMAL_PRIORITY_CLASS = ABOVE_NORMAL_PRIORITY_CLASS</span>
        <span class="s1">BELOW_NORMAL_PRIORITY_CLASS = BELOW_NORMAL_PRIORITY_CLASS</span>
        <span class="s1">HIGH_PRIORITY_CLASS = HIGH_PRIORITY_CLASS</span>
        <span class="s1">IDLE_PRIORITY_CLASS = IDLE_PRIORITY_CLASS</span>
        <span class="s1">NORMAL_PRIORITY_CLASS = NORMAL_PRIORITY_CLASS</span>
        <span class="s1">REALTIME_PRIORITY_CLASS = REALTIME_PRIORITY_CLASS</span>

    <span class="s1">globals().update(Priority.__members__)</span>

<span class="s3">if </span><span class="s1">enum </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">IOPRIO_VERYLOW = </span><span class="s5">0</span>
    <span class="s1">IOPRIO_LOW = </span><span class="s5">1</span>
    <span class="s1">IOPRIO_NORMAL = </span><span class="s5">2</span>
    <span class="s1">IOPRIO_HIGH = </span><span class="s5">3</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">class </span><span class="s1">IOPriority(enum.IntEnum):</span>
        <span class="s1">IOPRIO_VERYLOW = </span><span class="s5">0</span>
        <span class="s1">IOPRIO_LOW = </span><span class="s5">1</span>
        <span class="s1">IOPRIO_NORMAL = </span><span class="s5">2</span>
        <span class="s1">IOPRIO_HIGH = </span><span class="s5">3</span>
    <span class="s1">globals().update(IOPriority.__members__)</span>

<span class="s1">pinfo_map = dict(</span>
    <span class="s1">num_handles=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">ctx_switches=</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">user_time=</span><span class="s5">2</span><span class="s3">,</span>
    <span class="s1">kernel_time=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">create_time=</span><span class="s5">4</span><span class="s3">,</span>
    <span class="s1">num_threads=</span><span class="s5">5</span><span class="s3">,</span>
    <span class="s1">io_rcount=</span><span class="s5">6</span><span class="s3">,</span>
    <span class="s1">io_wcount=</span><span class="s5">7</span><span class="s3">,</span>
    <span class="s1">io_rbytes=</span><span class="s5">8</span><span class="s3">,</span>
    <span class="s1">io_wbytes=</span><span class="s5">9</span><span class="s3">,</span>
    <span class="s1">io_count_others=</span><span class="s5">10</span><span class="s3">,</span>
    <span class="s1">io_bytes_others=</span><span class="s5">11</span><span class="s3">,</span>
    <span class="s1">num_page_faults=</span><span class="s5">12</span><span class="s3">,</span>
    <span class="s1">peak_wset=</span><span class="s5">13</span><span class="s3">,</span>
    <span class="s1">wset=</span><span class="s5">14</span><span class="s3">,</span>
    <span class="s1">peak_paged_pool=</span><span class="s5">15</span><span class="s3">,</span>
    <span class="s1">paged_pool=</span><span class="s5">16</span><span class="s3">,</span>
    <span class="s1">peak_non_paged_pool=</span><span class="s5">17</span><span class="s3">,</span>
    <span class="s1">non_paged_pool=</span><span class="s5">18</span><span class="s3">,</span>
    <span class="s1">pagefile=</span><span class="s5">19</span><span class="s3">,</span>
    <span class="s1">peak_pagefile=</span><span class="s5">20</span><span class="s3">,</span>
    <span class="s1">mem_private=</span><span class="s5">21</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- named tuples</span>
<span class="s0"># =====================================================================</span>


<span class="s0"># psutil.cpu_times()</span>
<span class="s1">scputimes = namedtuple(</span><span class="s4">'scputimes'</span><span class="s3">,</span>
                       <span class="s1">[</span><span class="s4">'user'</span><span class="s3">, </span><span class="s4">'system'</span><span class="s3">, </span><span class="s4">'idle'</span><span class="s3">, </span><span class="s4">'interrupt'</span><span class="s3">, </span><span class="s4">'dpc'</span><span class="s1">])</span>
<span class="s0"># psutil.virtual_memory()</span>
<span class="s1">svmem = namedtuple(</span><span class="s4">'svmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'total'</span><span class="s3">, </span><span class="s4">'available'</span><span class="s3">, </span><span class="s4">'percent'</span><span class="s3">, </span><span class="s4">'used'</span><span class="s3">, </span><span class="s4">'free'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_info()</span>
<span class="s1">pmem = namedtuple(</span>
    <span class="s4">'pmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'rss'</span><span class="s3">, </span><span class="s4">'vms'</span><span class="s3">,</span>
             <span class="s4">'num_page_faults'</span><span class="s3">, </span><span class="s4">'peak_wset'</span><span class="s3">, </span><span class="s4">'wset'</span><span class="s3">, </span><span class="s4">'peak_paged_pool'</span><span class="s3">,</span>
             <span class="s4">'paged_pool'</span><span class="s3">, </span><span class="s4">'peak_nonpaged_pool'</span><span class="s3">, </span><span class="s4">'nonpaged_pool'</span><span class="s3">,</span>
             <span class="s4">'pagefile'</span><span class="s3">, </span><span class="s4">'peak_pagefile'</span><span class="s3">, </span><span class="s4">'private'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_full_info()</span>
<span class="s1">pfullmem = namedtuple(</span><span class="s4">'pfullmem'</span><span class="s3">, </span><span class="s1">pmem._fields + (</span><span class="s4">'uss'</span><span class="s3">, </span><span class="s1">))</span>
<span class="s0"># psutil.Process.memory_maps(grouped=True)</span>
<span class="s1">pmmap_grouped = namedtuple(</span><span class="s4">'pmmap_grouped'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'path'</span><span class="s3">, </span><span class="s4">'rss'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_maps(grouped=False)</span>
<span class="s1">pmmap_ext = namedtuple(</span>
    <span class="s4">'pmmap_ext'</span><span class="s3">, </span><span class="s4">'addr perms ' </span><span class="s1">+ </span><span class="s4">' '</span><span class="s1">.join(pmmap_grouped._fields))</span>
<span class="s0"># psutil.Process.io_counters()</span>
<span class="s1">pio = namedtuple(</span><span class="s4">'pio'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'read_count'</span><span class="s3">, </span><span class="s4">'write_count'</span><span class="s3">,</span>
                         <span class="s4">'read_bytes'</span><span class="s3">, </span><span class="s4">'write_bytes'</span><span class="s3">,</span>
                         <span class="s4">'other_count'</span><span class="s3">, </span><span class="s4">'other_bytes'</span><span class="s1">])</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- utils</span>
<span class="s0"># =====================================================================</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s5">512</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">convert_dos_path(s):</span>
    <span class="s2">r&quot;&quot;&quot;Convert paths using native DOS format like: 
        &quot;\Device\HarddiskVolume1\Windows\systemew\file.txt&quot; 
    into: 
        &quot;C:\Windows\systemew\file.txt&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">rawdrive = </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">.join(s.split(</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">)[:</span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">driveletter = cext.QueryDosDevice(rawdrive)</span>
    <span class="s1">remainder = s[len(rawdrive):]</span>
    <span class="s3">return </span><span class="s1">os.path.join(driveletter</span><span class="s3">, </span><span class="s1">remainder)</span>


<span class="s3">def </span><span class="s1">py2_strencode(s):</span>
    <span class="s2">&quot;&quot;&quot;Encode a unicode string to a byte string by using the default fs 
    encoding + &quot;replace&quot; error handler. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">PY3:</span>
        <span class="s3">return </span><span class="s1">s</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">return </span><span class="s1">s</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">s.encode(ENCODING</span><span class="s3">, </span><span class="s1">ENCODING_ERRS)</span>


<span class="s1">@memoize</span>
<span class="s3">def </span><span class="s1">getpagesize():</span>
    <span class="s3">return </span><span class="s1">cext.getpagesize()</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- memory</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">virtual_memory():</span>
    <span class="s2">&quot;&quot;&quot;System virtual memory as a namedtuple.&quot;&quot;&quot;</span>
    <span class="s1">mem = cext.virtual_mem()</span>
    <span class="s1">totphys</span><span class="s3">, </span><span class="s1">availphys</span><span class="s3">, </span><span class="s1">totsys</span><span class="s3">, </span><span class="s1">availsys = mem</span>
    <span class="s0">#</span>
    <span class="s1">total = totphys</span>
    <span class="s1">avail = availphys</span>
    <span class="s1">free = availphys</span>
    <span class="s1">used = total - avail</span>
    <span class="s1">percent = usage_percent((total - avail)</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">svmem(total</span><span class="s3">, </span><span class="s1">avail</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free)</span>


<span class="s3">def </span><span class="s1">swap_memory():</span>
    <span class="s2">&quot;&quot;&quot;Swap system memory as a (total, used, free, sin, sout) tuple.&quot;&quot;&quot;</span>
    <span class="s1">mem = cext.virtual_mem()</span>

    <span class="s1">total_phys = mem[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">free_phys = mem[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">total_system = mem[</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">free_system = mem[</span><span class="s5">3</span><span class="s1">]</span>

    <span class="s0"># system memory (commit total/limit) is the sum of physical and swap</span>
    <span class="s0"># thus physical memory values need to be substracted to get swap values</span>
    <span class="s1">total = total_system - total_phys</span>
    <span class="s1">free = min(total</span><span class="s3">, </span><span class="s1">free_system - free_phys)</span>
    <span class="s1">used = total - free</span>
    <span class="s1">percent = usage_percent(used</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_common.sswap(total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- disk</span>
<span class="s0"># =====================================================================</span>


<span class="s1">disk_io_counters = cext.disk_io_counters</span>


<span class="s3">def </span><span class="s1">disk_usage(path):</span>
    <span class="s2">&quot;&quot;&quot;Return disk usage associated with path.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">PY3 </span><span class="s3">and </span><span class="s1">isinstance(path</span><span class="s3">, </span><span class="s1">bytes):</span>
        <span class="s0"># XXX: do we want to use &quot;strict&quot;? Probably yes, in order</span>
        <span class="s0"># to fail immediately. After all we are accepting input here...</span>
        <span class="s1">path = path.decode(ENCODING</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">&quot;strict&quot;</span><span class="s1">)</span>
    <span class="s1">total</span><span class="s3">, </span><span class="s1">free = cext.disk_usage(path)</span>
    <span class="s1">used = total - free</span>
    <span class="s1">percent = usage_percent(used</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_common.sdiskusage(total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">percent)</span>


<span class="s3">def </span><span class="s1">disk_partitions(all):</span>
    <span class="s2">&quot;&quot;&quot;Return disk partitions.&quot;&quot;&quot;</span>
    <span class="s1">rawlist = cext.disk_partitions(all)</span>
    <span class="s3">return </span><span class="s1">[_common.sdiskpart(*x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">rawlist]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- CPU</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system CPU times as a named tuple.&quot;&quot;&quot;</span>
    <span class="s1">user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle = cext.cpu_times()</span>
    <span class="s0"># Internally, GetSystemTimes() is used, and it doesn't return</span>
    <span class="s0"># interrupt and dpc times. cext.per_cpu_times() does, so we</span>
    <span class="s0"># rely on it to get those only.</span>
    <span class="s1">percpu_summed = scputimes(*[sum(n) </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">zip(*cext.per_cpu_times())])</span>
    <span class="s3">return </span><span class="s1">scputimes(user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle</span><span class="s3">,</span>
                     <span class="s1">percpu_summed.interrupt</span><span class="s3">, </span><span class="s1">percpu_summed.dpc)</span>


<span class="s3">def </span><span class="s1">per_cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system per-CPU times as a list of named tuples.&quot;&quot;&quot;</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle</span><span class="s3">, </span><span class="s1">interrupt</span><span class="s3">, </span><span class="s1">dpc </span><span class="s3">in </span><span class="s1">cext.per_cpu_times():</span>
        <span class="s1">item = scputimes(user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">idle</span><span class="s3">, </span><span class="s1">interrupt</span><span class="s3">, </span><span class="s1">dpc)</span>
        <span class="s1">ret.append(item)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">cpu_count_logical():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of logical CPUs in the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.cpu_count_logical()</span>


<span class="s3">def </span><span class="s1">cpu_count_cores():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of CPU cores in the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.cpu_count_cores()</span>


<span class="s3">def </span><span class="s1">cpu_stats():</span>
    <span class="s2">&quot;&quot;&quot;Return CPU statistics.&quot;&quot;&quot;</span>
    <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">dpcs</span><span class="s3">, </span><span class="s1">syscalls = cext.cpu_stats()</span>
    <span class="s1">soft_interrupts = </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">_common.scpustats(ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">,</span>
                             <span class="s1">syscalls)</span>


<span class="s3">def </span><span class="s1">cpu_freq():</span>
    <span class="s2">&quot;&quot;&quot;Return CPU frequency. 
    On Windows per-cpu frequency is not supported. 
    &quot;&quot;&quot;</span>
    <span class="s1">curr</span><span class="s3">, </span><span class="s1">max_ = cext.cpu_freq()</span>
    <span class="s1">min_ = </span><span class="s5">0.0</span>
    <span class="s3">return </span><span class="s1">[_common.scpufreq(float(curr)</span><span class="s3">, </span><span class="s1">min_</span><span class="s3">, </span><span class="s1">float(max_))]</span>


<span class="s1">_loadavg_inititialized = </span><span class="s3">False</span>


<span class="s3">def </span><span class="s1">getloadavg():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of processes in the system run queue averaged 
    over the last 1, 5, and 15 minutes respectively as a tuple&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_loadavg_inititialized</span>

    <span class="s3">if not </span><span class="s1">_loadavg_inititialized:</span>
        <span class="s1">cext.init_loadavg_counter()</span>
        <span class="s1">_loadavg_inititialized = </span><span class="s3">True</span>

    <span class="s0"># Drop to 2 decimal points which is what Linux does</span>
    <span class="s1">raw_loads = cext.getloadavg()</span>
    <span class="s3">return </span><span class="s1">tuple([round(load</span><span class="s3">, </span><span class="s5">2</span><span class="s1">) </span><span class="s3">for </span><span class="s1">load </span><span class="s3">in </span><span class="s1">raw_loads])</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- network</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">net_connections(kind</span><span class="s3">, </span><span class="s1">_pid=-</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return socket connections.  If pid == -1 return system-wide 
    connections (as opposed to connections opened by one process only). 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">kind </span><span class="s3">not in </span><span class="s1">conn_tmap:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid %r kind argument; choose between %s&quot;</span>
                         <span class="s1">% (kind</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">.join([repr(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">conn_tmap])))</span>
    <span class="s1">families</span><span class="s3">, </span><span class="s1">types = conn_tmap[kind]</span>
    <span class="s1">rawlist = cext.net_connections(_pid</span><span class="s3">, </span><span class="s1">families</span><span class="s3">, </span><span class="s1">types)</span>
    <span class="s1">ret = set()</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">pid = item</span>
        <span class="s1">nt = conn_to_ntuple(fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">TCP_STATUSES</span><span class="s3">,</span>
                            <span class="s1">pid=pid </span><span class="s3">if </span><span class="s1">_pid == -</span><span class="s5">1 </span><span class="s3">else None</span><span class="s1">)</span>
        <span class="s1">ret.add(nt)</span>
    <span class="s3">return </span><span class="s1">list(ret)</span>


<span class="s3">def </span><span class="s1">net_if_stats():</span>
    <span class="s2">&quot;&quot;&quot;Get NIC stats (isup, duplex, speed, mtu).&quot;&quot;&quot;</span>
    <span class="s1">ret = {}</span>
    <span class="s1">rawdict = cext.net_if_stats()</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">items </span><span class="s3">in </span><span class="s1">rawdict.items():</span>
        <span class="s3">if not </span><span class="s1">PY3:</span>
            <span class="s3">assert </span><span class="s1">isinstance(name</span><span class="s3">, </span><span class="s1">unicode)</span><span class="s3">, </span><span class="s1">type(name)</span>
            <span class="s1">name = py2_strencode(name)</span>
        <span class="s1">isup</span><span class="s3">, </span><span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">mtu = items</span>
        <span class="s3">if </span><span class="s1">hasattr(_common</span><span class="s3">, </span><span class="s4">'NicDuplex'</span><span class="s1">):</span>
            <span class="s1">duplex = _common.NicDuplex(duplex)</span>
        <span class="s1">ret[name] = _common.snicstats(isup</span><span class="s3">, </span><span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">mtu</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">net_io_counters():</span>
    <span class="s2">&quot;&quot;&quot;Return network I/O statistics for every network interface 
    installed on the system as a dict of raw tuples. 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = cext.net_io_counters()</span>
    <span class="s3">return </span><span class="s1">dict([(py2_strencode(k)</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">ret.items()])</span>


<span class="s3">def </span><span class="s1">net_if_addrs():</span>
    <span class="s2">&quot;&quot;&quot;Return the addresses associated to each NIC.&quot;&quot;&quot;</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">items </span><span class="s3">in </span><span class="s1">cext.net_if_addrs():</span>
        <span class="s1">items = list(items)</span>
        <span class="s1">items[</span><span class="s5">0</span><span class="s1">] = py2_strencode(items[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">ret.append(items)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- sensors</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">sensors_battery():</span>
    <span class="s2">&quot;&quot;&quot;Return battery information.&quot;&quot;&quot;</span>
    <span class="s0"># For constants meaning see:</span>
    <span class="s0"># https://msdn.microsoft.com/en-us/library/windows/desktop/</span>
    <span class="s0">#     aa373232(v=vs.85).aspx</span>
    <span class="s1">acline_status</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">secsleft = cext.sensors_battery()</span>
    <span class="s1">power_plugged = acline_status == </span><span class="s5">1</span>
    <span class="s1">no_battery = bool(flags &amp; </span><span class="s5">128</span><span class="s1">)</span>
    <span class="s1">charging = bool(flags &amp; </span><span class="s5">8</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">no_battery:</span>
        <span class="s3">return None</span>
    <span class="s3">if </span><span class="s1">power_plugged </span><span class="s3">or </span><span class="s1">charging:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNLIMITED</span>
    <span class="s3">elif </span><span class="s1">secsleft == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNKNOWN</span>

    <span class="s3">return </span><span class="s1">_common.sbattery(percent</span><span class="s3">, </span><span class="s1">secsleft</span><span class="s3">, </span><span class="s1">power_plugged)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- other system functions</span>
<span class="s0"># =====================================================================</span>


<span class="s1">_last_btime = </span><span class="s5">0</span>


<span class="s3">def </span><span class="s1">boot_time():</span>
    <span class="s2">&quot;&quot;&quot;The system boot time expressed in seconds since the epoch.&quot;&quot;&quot;</span>
    <span class="s0"># This dirty hack is to adjust the precision of the returned</span>
    <span class="s0"># value which may have a 1 second fluctuation, see:</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/1007</span>
    <span class="s3">global </span><span class="s1">_last_btime</span>
    <span class="s1">ret = float(cext.boot_time())</span>
    <span class="s3">if </span><span class="s1">abs(ret - _last_btime) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_last_btime</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">_last_btime = ret</span>
        <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">users():</span>
    <span class="s2">&quot;&quot;&quot;Return currently connected users as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">retlist = []</span>
    <span class="s1">rawlist = cext.users()</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp = item</span>
        <span class="s1">user = py2_strencode(user)</span>
        <span class="s1">nt = _common.suser(user</span><span class="s3">, None, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">retlist.append(nt)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- Windows services</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">win_service_iter():</span>
    <span class="s2">&quot;&quot;&quot;Yields a list of WindowsService instances.&quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">display_name </span><span class="s3">in </span><span class="s1">cext.winservice_enumerate():</span>
        <span class="s3">yield </span><span class="s1">WindowsService(py2_strencode(name)</span><span class="s3">, </span><span class="s1">py2_strencode(display_name))</span>


<span class="s3">def </span><span class="s1">win_service_get(name):</span>
    <span class="s2">&quot;&quot;&quot;Open a Windows service and return it as a WindowsService instance.&quot;&quot;&quot;</span>
    <span class="s1">service = WindowsService(name</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s1">service._display_name = service._query_config()[</span><span class="s4">'display_name'</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">service</span>


<span class="s3">class </span><span class="s1">WindowsService(object):</span>
    <span class="s2">&quot;&quot;&quot;Represents an installed Windows service.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">display_name):</span>
        <span class="s1">self._name = name</span>
        <span class="s1">self._display_name = display_name</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s1">details = </span><span class="s4">&quot;(name=%r, display_name=%r)&quot; </span><span class="s1">% (</span>
            <span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._display_name)</span>
        <span class="s3">return </span><span class="s4">&quot;%s%s&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s3">, </span><span class="s1">details)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;&lt;%s at %s&gt;&quot; </span><span class="s1">% (self.__str__()</span><span class="s3">, </span><span class="s1">id(self))</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0"># Test for equality with another WindosService object based</span>
        <span class="s0"># on name.</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">WindowsService):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">return </span><span class="s1">self._name == other._name</span>

    <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return not </span><span class="s1">self == other</span>

    <span class="s3">def </span><span class="s1">_query_config(self):</span>
        <span class="s3">with </span><span class="s1">self._wrap_exceptions():</span>
            <span class="s1">display_name</span><span class="s3">, </span><span class="s1">binpath</span><span class="s3">, </span><span class="s1">username</span><span class="s3">, </span><span class="s1">start_type = \</span>
                <span class="s1">cext.winservice_query_config(self._name)</span>
        <span class="s0"># XXX - update _self.display_name?</span>
        <span class="s3">return </span><span class="s1">dict(</span>
            <span class="s1">display_name=py2_strencode(display_name)</span><span class="s3">,</span>
            <span class="s1">binpath=py2_strencode(binpath)</span><span class="s3">,</span>
            <span class="s1">username=py2_strencode(username)</span><span class="s3">,</span>
            <span class="s1">start_type=py2_strencode(start_type))</span>

    <span class="s3">def </span><span class="s1">_query_status(self):</span>
        <span class="s3">with </span><span class="s1">self._wrap_exceptions():</span>
            <span class="s1">status</span><span class="s3">, </span><span class="s1">pid = cext.winservice_query_status(self._name)</span>
        <span class="s3">if </span><span class="s1">pid == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pid = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">dict(status=status</span><span class="s3">, </span><span class="s1">pid=pid)</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s3">def </span><span class="s1">_wrap_exceptions(self):</span>
        <span class="s2">&quot;&quot;&quot;Ctx manager which translates bare OSError and WindowsError 
        exceptions into NoSuchProcess and AccessDenied. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">yield</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if </span><span class="s1">is_permission_err(err):</span>
                <span class="s3">raise </span><span class="s1">AccessDenied(</span>
                    <span class="s1">pid=</span><span class="s3">None, </span><span class="s1">name=self._name</span><span class="s3">,</span>
                    <span class="s1">msg=</span><span class="s4">&quot;service %r is not querable (not enough privileges)&quot; </span><span class="s1">%</span>
                        <span class="s1">self._name)</span>
            <span class="s3">elif </span><span class="s1">err.winerror </span><span class="s3">in </span><span class="s1">(cext.ERROR_INVALID_NAME</span><span class="s3">,</span>
                                  <span class="s1">cext.ERROR_SERVICE_DOES_NOT_EXIST):</span>
                <span class="s3">raise </span><span class="s1">NoSuchProcess(</span>
                    <span class="s1">pid=</span><span class="s3">None, </span><span class="s1">name=self._name</span><span class="s3">,</span>
                    <span class="s1">msg=</span><span class="s4">&quot;service %r does not exist)&quot; </span><span class="s1">% self._name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise</span>

    <span class="s0"># config query</span>

    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s2">&quot;&quot;&quot;The service name. This string is how a service is referenced 
        and can be passed to win_service_get() to get a new 
        WindowsService instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._name</span>

    <span class="s3">def </span><span class="s1">display_name(self):</span>
        <span class="s2">&quot;&quot;&quot;The service display name. The value is cached when this class 
        is instantiated. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._display_name</span>

    <span class="s3">def </span><span class="s1">binpath(self):</span>
        <span class="s2">&quot;&quot;&quot;The fully qualified path to the service binary/exe file as 
        a string, including command line arguments. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._query_config()[</span><span class="s4">'binpath'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">username(self):</span>
        <span class="s2">&quot;&quot;&quot;The name of the user that owns this service.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._query_config()[</span><span class="s4">'username'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">start_type(self):</span>
        <span class="s2">&quot;&quot;&quot;A string which can either be &quot;automatic&quot;, &quot;manual&quot; or 
        &quot;disabled&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._query_config()[</span><span class="s4">'start_type'</span><span class="s1">]</span>

    <span class="s0"># status query</span>

    <span class="s3">def </span><span class="s1">pid(self):</span>
        <span class="s2">&quot;&quot;&quot;The process PID, if any, else None. This can be passed 
        to Process class to control the service's process. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._query_status()[</span><span class="s4">'pid'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">status(self):</span>
        <span class="s2">&quot;&quot;&quot;Service status as a string.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._query_status()[</span><span class="s4">'status'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">description(self):</span>
        <span class="s2">&quot;&quot;&quot;Service long description.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">py2_strencode(cext.winservice_query_descr(self.name()))</span>

    <span class="s0"># utils</span>

    <span class="s3">def </span><span class="s1">as_dict(self):</span>
        <span class="s2">&quot;&quot;&quot;Utility method retrieving all the information above as a 
        dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s1">d = self._query_config()</span>
        <span class="s1">d.update(self._query_status())</span>
        <span class="s1">d[</span><span class="s4">'name'</span><span class="s1">] = self.name()</span>
        <span class="s1">d[</span><span class="s4">'display_name'</span><span class="s1">] = self.display_name()</span>
        <span class="s1">d[</span><span class="s4">'description'</span><span class="s1">] = self.description()</span>
        <span class="s3">return </span><span class="s1">d</span>

    <span class="s0"># actions</span>
    <span class="s0"># XXX: the necessary C bindings for start() and stop() are</span>
    <span class="s0"># implemented but for now I prefer not to expose them.</span>
    <span class="s0"># I may change my mind in the future. Reasons:</span>
    <span class="s0"># - they require Administrator privileges</span>
    <span class="s0"># - can't implement a timeout for stop() (unless by using a thread,</span>
    <span class="s0">#   which sucks)</span>
    <span class="s0"># - would require adding ServiceAlreadyStarted and</span>
    <span class="s0">#   ServiceAlreadyStopped exceptions, adding two new APIs.</span>
    <span class="s0"># - we might also want to have modify(), which would basically mean</span>
    <span class="s0">#   rewriting win32serviceutil.ChangeServiceConfig, which involves a</span>
    <span class="s0">#   lot of stuff (and API constants which would pollute the API), see:</span>
    <span class="s0">#   http://pyxr.sourceforge.net/PyXR/c/python24/lib/site-packages/</span>
    <span class="s0">#       win32/lib/win32serviceutil.py.html#0175</span>
    <span class="s0"># - psutil is typically about &quot;read only&quot; monitoring stuff;</span>
    <span class="s0">#   win_service_* APIs should only be used to retrieve a service and</span>
    <span class="s0">#   check whether it's running</span>

    <span class="s0"># def start(self, timeout=None):</span>
    <span class="s0">#     with self._wrap_exceptions():</span>
    <span class="s0">#         cext.winservice_start(self.name())</span>
    <span class="s0">#         if timeout:</span>
    <span class="s0">#             giveup_at = time.time() + timeout</span>
    <span class="s0">#             while True:</span>
    <span class="s0">#                 if self.status() == &quot;running&quot;:</span>
    <span class="s0">#                     return</span>
    <span class="s0">#                 else:</span>
    <span class="s0">#                     if time.time() &gt; giveup_at:</span>
    <span class="s0">#                         raise TimeoutExpired(timeout)</span>
    <span class="s0">#                     else:</span>
    <span class="s0">#                         time.sleep(.1)</span>

    <span class="s0"># def stop(self):</span>
    <span class="s0">#     # Note: timeout is not implemented because it's just not</span>
    <span class="s0">#     # possible, see:</span>
    <span class="s0">#     # http://stackoverflow.com/questions/11973228/</span>
    <span class="s0">#     with self._wrap_exceptions():</span>
    <span class="s0">#         return cext.winservice_stop(self.name())</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- processes</span>
<span class="s0"># =====================================================================</span>


<span class="s1">pids = cext.pids</span>
<span class="s1">pid_exists = cext.pid_exists</span>
<span class="s1">ppid_map = cext.ppid_map  </span><span class="s0"># used internally by Process.children()</span>


<span class="s3">def </span><span class="s1">is_permission_err(exc):</span>
    <span class="s2">&quot;&quot;&quot;Return True if this is a permission error.&quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(exc</span><span class="s3">, </span><span class="s1">OSError)</span><span class="s3">, </span><span class="s1">exc</span>
    <span class="s0"># On Python 2 OSError doesn't always have 'winerror'. Sometimes</span>
    <span class="s0"># it does, in which case the original exception was WindowsError</span>
    <span class="s0"># (which is a subclass of OSError).</span>
    <span class="s3">return </span><span class="s1">exc.errno </span><span class="s3">in </span><span class="s1">(errno.EPERM</span><span class="s3">, </span><span class="s1">errno.EACCES) </span><span class="s3">or </span><span class="s1">\</span>
        <span class="s1">getattr(exc</span><span class="s3">, </span><span class="s4">&quot;winerror&quot;</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) </span><span class="s3">in </span><span class="s1">(cext.ERROR_ACCESS_DENIED</span><span class="s3">,</span>
                                         <span class="s1">cext.ERROR_PRIVILEGE_NOT_HELD)</span>


<span class="s3">def </span><span class="s1">convert_oserror(exc</span><span class="s3">, </span><span class="s1">pid=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert OSError into NoSuchProcess or AccessDenied.&quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(exc</span><span class="s3">, </span><span class="s1">OSError)</span><span class="s3">, </span><span class="s1">exc</span>
    <span class="s3">if </span><span class="s1">is_permission_err(exc):</span>
        <span class="s3">return </span><span class="s1">AccessDenied(pid=pid</span><span class="s3">, </span><span class="s1">name=name)</span>
    <span class="s3">if </span><span class="s1">exc.errno == errno.ESRCH:</span>
        <span class="s3">return </span><span class="s1">NoSuchProcess(pid=pid</span><span class="s3">, </span><span class="s1">name=name)</span>
    <span class="s3">raise </span><span class="s1">exc</span>


<span class="s3">def </span><span class="s1">wrap_exceptions(fun):</span>
    <span class="s2">&quot;&quot;&quot;Decorator which converts OSError into NoSuchProcess or AccessDenied.&quot;&quot;&quot;</span>
    <span class="s1">@functools.wraps(fun)</span>
    <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">raise </span><span class="s1">convert_oserror(err</span><span class="s3">, </span><span class="s1">pid=self.pid</span><span class="s3">, </span><span class="s1">name=self._name)</span>
    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">def </span><span class="s1">retry_error_partial_copy(fun):</span>
    <span class="s2">&quot;&quot;&quot;Workaround for https://github.com/giampaolo/psutil/issues/875. 
    See: https://stackoverflow.com/questions/4457745#4457745 
    &quot;&quot;&quot;</span>
    <span class="s1">@functools.wraps(fun)</span>
    <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">delay = </span><span class="s5">0.0001</span>
        <span class="s1">times = </span><span class="s5">33</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">range(times):  </span><span class="s0"># retries for roughly 1 second</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s3">except </span><span class="s1">WindowsError </span><span class="s3">as </span><span class="s1">_:</span>
                <span class="s1">err = _</span>
                <span class="s3">if </span><span class="s1">err.winerror == ERROR_PARTIAL_COPY:</span>
                    <span class="s1">time.sleep(delay)</span>
                    <span class="s1">delay = min(delay * </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0.04</span><span class="s1">)</span>
                    <span class="s3">continue</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;%s retried %s times, converted to AccessDenied as it's &quot; </span><span class="s1">\</span>
                <span class="s4">&quot;still returning %r&quot; </span><span class="s1">% (fun</span><span class="s3">, </span><span class="s1">times</span><span class="s3">, </span><span class="s1">err)</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(pid=self.pid</span><span class="s3">, </span><span class="s1">name=self._name</span><span class="s3">, </span><span class="s1">msg=msg)</span>
    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">Process(object):</span>
    <span class="s2">&quot;&quot;&quot;Wrapper class around underlying C implementation.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span><span class="s4">&quot;pid&quot;</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s3">, </span><span class="s4">&quot;_ppid&quot;</span><span class="s3">, </span><span class="s4">&quot;_cache&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pid):</span>
        <span class="s1">self.pid = pid</span>
        <span class="s1">self._name = </span><span class="s3">None</span>
        <span class="s1">self._ppid = </span><span class="s3">None</span>

    <span class="s0"># --- oneshot() stuff</span>

    <span class="s3">def </span><span class="s1">oneshot_enter(self):</span>
        <span class="s1">self._proc_info.cache_activate(self)</span>
        <span class="s1">self.exe.cache_activate(self)</span>

    <span class="s3">def </span><span class="s1">oneshot_exit(self):</span>
        <span class="s1">self._proc_info.cache_deactivate(self)</span>
        <span class="s1">self.exe.cache_deactivate(self)</span>

    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_proc_info(self):</span>
        <span class="s2">&quot;&quot;&quot;Return multiple information about this process as a 
        raw tuple. 
        &quot;&quot;&quot;</span>
        <span class="s1">ret = cext.proc_info(self.pid)</span>
        <span class="s3">assert </span><span class="s1">len(ret) == len(pinfo_map)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s2">&quot;&quot;&quot;Return process name, which on Windows is always the final 
        part of the executable. 
        &quot;&quot;&quot;</span>
        <span class="s0"># This is how PIDs 0 and 4 are always represented in taskmgr</span>
        <span class="s0"># and process-hacker.</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;System Idle Process&quot;</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;System&quot;</span>
        <span class="s3">return </span><span class="s1">os.path.basename(self.exe())</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">exe(self):</span>
        <span class="s3">if </span><span class="s1">PYPY:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">exe = cext.proc_exe(self.pid)</span>
            <span class="s3">except </span><span class="s1">WindowsError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s0"># 24 = ERROR_TOO_MANY_OPEN_FILES. Not sure why this happens</span>
                <span class="s0"># (perhaps PyPy's JIT delaying garbage collection of files?).</span>
                <span class="s3">if </span><span class="s1">err.errno == </span><span class="s5">24</span><span class="s1">:</span>
                    <span class="s1">debug(</span><span class="s4">&quot;%r translated into AccessDenied&quot; </span><span class="s1">% err)</span>
                    <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
                <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">exe = cext.proc_exe(self.pid)</span>
        <span class="s3">if not </span><span class="s1">PY3:</span>
            <span class="s1">exe = py2_strencode(exe)</span>
        <span class="s3">if </span><span class="s1">exe.startswith(</span><span class="s4">'</span><span class="s3">\\</span><span class="s4">'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">convert_dos_path(exe)</span>
        <span class="s3">return </span><span class="s1">exe  </span><span class="s0"># May be &quot;Registry&quot;, &quot;MemCompression&quot;, ...</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@retry_error_partial_copy</span>
    <span class="s3">def </span><span class="s1">cmdline(self):</span>
        <span class="s3">if </span><span class="s1">cext.WINVER &gt;= cext.WINDOWS_8_1:</span>
            <span class="s0"># PEB method detects cmdline changes but requires more</span>
            <span class="s0"># privileges: https://github.com/giampaolo/psutil/pull/1398</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">ret = cext.proc_cmdline(self.pid</span><span class="s3">, </span><span class="s1">use_peb=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">is_permission_err(err):</span>
                    <span class="s1">ret = cext.proc_cmdline(self.pid</span><span class="s3">, </span><span class="s1">use_peb=</span><span class="s3">False</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">ret = cext.proc_cmdline(self.pid</span><span class="s3">, </span><span class="s1">use_peb=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">[py2_strencode(s) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">ret]</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@retry_error_partial_copy</span>
    <span class="s3">def </span><span class="s1">environ(self):</span>
        <span class="s1">ustr = cext.proc_environ(self.pid)</span>
        <span class="s3">if </span><span class="s1">ustr </span><span class="s3">and not </span><span class="s1">PY3:</span>
            <span class="s3">assert </span><span class="s1">isinstance(ustr</span><span class="s3">, </span><span class="s1">unicode)</span><span class="s3">, </span><span class="s1">type(ustr)</span>
        <span class="s3">return </span><span class="s1">parse_environ_block(py2_strencode(ustr))</span>

    <span class="s3">def </span><span class="s1">ppid(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">ppid_map()[self.pid]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>

    <span class="s3">def </span><span class="s1">_get_raw_meminfo(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cext.proc_memory_info(self.pid)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if </span><span class="s1">is_permission_err(err):</span>
                <span class="s0"># TODO: the C ext can probably be refactored in order</span>
                <span class="s0"># to get this from cext.proc_info()</span>
                <span class="s1">info = self._proc_info()</span>
                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'num_page_faults'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'peak_wset'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'wset'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'peak_paged_pool'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'paged_pool'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'peak_non_paged_pool'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'non_paged_pool'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'pagefile'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'peak_pagefile'</span><span class="s1">]]</span><span class="s3">,</span>
                    <span class="s1">info[pinfo_map[</span><span class="s4">'mem_private'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">raise</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_info(self):</span>
        <span class="s0"># on Windows RSS == WorkingSetSize and VSM == PagefileUsage.</span>
        <span class="s0"># Underlying C function returns fields of PROCESS_MEMORY_COUNTERS</span>
        <span class="s0"># struct.</span>
        <span class="s1">t = self._get_raw_meminfo()</span>
        <span class="s1">rss = t[</span><span class="s5">2</span><span class="s1">]  </span><span class="s0"># wset</span>
        <span class="s1">vms = t[</span><span class="s5">7</span><span class="s1">]  </span><span class="s0"># pagefile</span>
        <span class="s3">return </span><span class="s1">pmem(*(rss</span><span class="s3">, </span><span class="s1">vms</span><span class="s3">, </span><span class="s1">) + t)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_full_info(self):</span>
        <span class="s1">basic_mem = self.memory_info()</span>
        <span class="s1">uss = cext.proc_memory_uss(self.pid)</span>
        <span class="s1">uss *= getpagesize()</span>
        <span class="s3">return </span><span class="s1">pfullmem(*basic_mem + (uss</span><span class="s3">, </span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">memory_maps(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">raw = cext.proc_memory_maps(self.pid)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s0"># XXX - can't use wrap_exceptions decorator as we're</span>
            <span class="s0"># returning a generator; probably needs refactoring.</span>
            <span class="s3">raise </span><span class="s1">convert_oserror(err</span><span class="s3">, </span><span class="s1">self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">perm</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">rss </span><span class="s3">in </span><span class="s1">raw:</span>
                <span class="s1">path = convert_dos_path(path)</span>
                <span class="s3">if not </span><span class="s1">PY3:</span>
                    <span class="s1">path = py2_strencode(path)</span>
                <span class="s1">addr = hex(addr)</span>
                <span class="s3">yield </span><span class="s1">(addr</span><span class="s3">, </span><span class="s1">perm</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">rss)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">kill(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_kill(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">send_signal(self</span><span class="s3">, </span><span class="s1">sig):</span>
        <span class="s3">if </span><span class="s1">sig == signal.SIGTERM:</span>
            <span class="s1">cext.proc_kill(self.pid)</span>
        <span class="s0"># py &gt;= 2.7</span>
        <span class="s3">elif </span><span class="s1">sig </span><span class="s3">in </span><span class="s1">(getattr(signal</span><span class="s3">, </span><span class="s4">&quot;CTRL_C_EVENT&quot;</span><span class="s3">, </span><span class="s1">object())</span><span class="s3">,</span>
                     <span class="s1">getattr(signal</span><span class="s3">, </span><span class="s4">&quot;CTRL_BREAK_EVENT&quot;</span><span class="s3">, </span><span class="s1">object())):</span>
            <span class="s1">os.kill(self.pid</span><span class="s3">, </span><span class="s1">sig)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;only SIGTERM, CTRL_C_EVENT and CTRL_BREAK_EVENT signals &quot;</span>
                <span class="s4">&quot;are supported on Windows&quot;</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">wait(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">timeout </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">cext_timeout = cext.INFINITE</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># WaitForSingleObject() expects time in milliseconds.</span>
            <span class="s1">cext_timeout = int(timeout * </span><span class="s5">1000</span><span class="s1">)</span>

        <span class="s1">timer = getattr(time</span><span class="s3">, </span><span class="s4">'monotonic'</span><span class="s3">, </span><span class="s1">time.time)</span>
        <span class="s1">stop_at = timer() + timeout </span><span class="s3">if </span><span class="s1">timeout </span><span class="s3">is not None else None</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># Exit code is supposed to come from GetExitCodeProcess().</span>
            <span class="s0"># May also be None if OpenProcess() failed with</span>
            <span class="s0"># ERROR_INVALID_PARAMETER, meaning PID is already gone.</span>
            <span class="s1">exit_code = cext.proc_wait(self.pid</span><span class="s3">, </span><span class="s1">cext_timeout)</span>
        <span class="s3">except </span><span class="s1">cext.TimeoutExpired:</span>
            <span class="s0"># WaitForSingleObject() returned WAIT_TIMEOUT. Just raise.</span>
            <span class="s3">raise </span><span class="s1">TimeoutExpired(timeout</span><span class="s3">, </span><span class="s1">self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">except </span><span class="s1">cext.TimeoutAbandoned:</span>
            <span class="s0"># WaitForSingleObject() returned WAIT_ABANDONED, see:</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1224</span>
            <span class="s0"># We'll just rely on the internal polling and return None</span>
            <span class="s0"># when the PID disappears. Subprocess module does the same</span>
            <span class="s0"># (return None):</span>
            <span class="s0"># https://github.com/python/cpython/blob/</span>
            <span class="s0">#     be50a7b627d0aa37e08fa8e2d5568891f19903ce/</span>
            <span class="s0">#     Lib/subprocess.py#L1193-L1194</span>
            <span class="s1">exit_code = </span><span class="s3">None</span>

        <span class="s0"># At this point WaitForSingleObject() returned WAIT_OBJECT_0,</span>
        <span class="s0"># meaning the process is gone. Stupidly there are cases where</span>
        <span class="s0"># its PID may still stick around so we do a further internal</span>
        <span class="s0"># polling.</span>
        <span class="s1">delay = </span><span class="s5">0.0001</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                <span class="s3">return </span><span class="s1">exit_code</span>
            <span class="s3">if </span><span class="s1">stop_at </span><span class="s3">and </span><span class="s1">timer() &gt;= stop_at:</span>
                <span class="s3">raise </span><span class="s1">TimeoutExpired(timeout</span><span class="s3">, </span><span class="s1">pid=self.pid</span><span class="s3">, </span><span class="s1">name=self._name)</span>
            <span class="s1">time.sleep(delay)</span>
            <span class="s1">delay = min(delay * </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0.04</span><span class="s1">)  </span><span class="s0"># incremental delay</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">username(self):</span>
        <span class="s3">if </span><span class="s1">self.pid </span><span class="s3">in </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s4">'NT AUTHORITY</span><span class="s3">\\</span><span class="s4">SYSTEM'</span>
        <span class="s1">domain</span><span class="s3">, </span><span class="s1">user = cext.proc_username(self.pid)</span>
        <span class="s3">return </span><span class="s1">py2_strencode(domain) + </span><span class="s4">'</span><span class="s3">\\</span><span class="s4">' </span><span class="s1">+ py2_strencode(user)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">create_time(self):</span>
        <span class="s0"># Note: proc_times() not put under oneshot() 'cause create_time()</span>
        <span class="s0"># is already cached by the main Process class.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">created = cext.proc_times(self.pid)</span>
            <span class="s3">return </span><span class="s1">created</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if </span><span class="s1">is_permission_err(err):</span>
                <span class="s3">return </span><span class="s1">self._proc_info()[pinfo_map[</span><span class="s4">'create_time'</span><span class="s1">]]</span>
            <span class="s3">raise</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_threads(self):</span>
        <span class="s3">return </span><span class="s1">self._proc_info()[pinfo_map[</span><span class="s4">'num_threads'</span><span class="s1">]]</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">threads(self):</span>
        <span class="s1">rawlist = cext.proc_threads(self.pid)</span>
        <span class="s1">retlist = []</span>
        <span class="s3">for </span><span class="s1">thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime </span><span class="s3">in </span><span class="s1">rawlist:</span>
            <span class="s1">ntuple = _common.pthread(thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime)</span>
            <span class="s1">retlist.append(ntuple)</span>
        <span class="s3">return </span><span class="s1">retlist</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_times(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s1">created = cext.proc_times(self.pid)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if not </span><span class="s1">is_permission_err(err):</span>
                <span class="s3">raise</span>
            <span class="s1">info = self._proc_info()</span>
            <span class="s1">user = info[pinfo_map[</span><span class="s4">'user_time'</span><span class="s1">]]</span>
            <span class="s1">system = info[pinfo_map[</span><span class="s4">'kernel_time'</span><span class="s1">]]</span>
        <span class="s0"># Children user/system times are not retrievable (set to 0).</span>
        <span class="s3">return </span><span class="s1">_common.pcputimes(user</span><span class="s3">, </span><span class="s1">system</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">suspend(self):</span>
        <span class="s1">cext.proc_suspend_or_resume(self.pid</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">resume(self):</span>
        <span class="s1">cext.proc_suspend_or_resume(self.pid</span><span class="s3">, False</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@retry_error_partial_copy</span>
    <span class="s3">def </span><span class="s1">cwd(self):</span>
        <span class="s3">if </span><span class="s1">self.pid </span><span class="s3">in </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s0"># return a normalized pathname since the native C function appends</span>
        <span class="s0"># &quot;\\&quot; at the and of the path</span>
        <span class="s1">path = cext.proc_cwd(self.pid)</span>
        <span class="s3">return </span><span class="s1">py2_strencode(os.path.normpath(path))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">open_files(self):</span>
        <span class="s3">if </span><span class="s1">self.pid </span><span class="s3">in </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s1">ret = set()</span>
        <span class="s0"># Filenames come in in native format like:</span>
        <span class="s0"># &quot;\Device\HarddiskVolume1\Windows\systemew\file.txt&quot;</span>
        <span class="s0"># Convert the first part in the corresponding drive letter</span>
        <span class="s0"># (e.g. &quot;C:\&quot;) by using Windows's QueryDosDevice()</span>
        <span class="s1">raw_file_names = cext.proc_open_files(self.pid)</span>
        <span class="s3">for </span><span class="s1">_file </span><span class="s3">in </span><span class="s1">raw_file_names:</span>
            <span class="s1">_file = convert_dos_path(_file)</span>
            <span class="s3">if </span><span class="s1">isfile_strict(_file):</span>
                <span class="s3">if not </span><span class="s1">PY3:</span>
                    <span class="s1">_file = py2_strencode(_file)</span>
                <span class="s1">ntuple = _common.popenfile(_file</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">ret.add(ntuple)</span>
        <span class="s3">return </span><span class="s1">list(ret)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">connections(self</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">'inet'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">net_connections(kind</span><span class="s3">, </span><span class="s1">_pid=self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_get(self):</span>
        <span class="s1">value = cext.proc_priority_get(self.pid)</span>
        <span class="s3">if </span><span class="s1">enum </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">value = Priority(value)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_set(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">cext.proc_priority_set(self.pid</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">ionice_get(self):</span>
        <span class="s1">ret = cext.proc_io_priority_get(self.pid)</span>
        <span class="s3">if </span><span class="s1">enum </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">ret = IOPriority(ret)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">ionice_set(self</span><span class="s3">, </span><span class="s1">ioclass</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">if </span><span class="s1">value:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;value argument not accepted on Windows&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">ioclass </span><span class="s3">not in </span><span class="s1">(IOPRIO_VERYLOW</span><span class="s3">, </span><span class="s1">IOPRIO_LOW</span><span class="s3">, </span><span class="s1">IOPRIO_NORMAL</span><span class="s3">,</span>
                           <span class="s1">IOPRIO_HIGH):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;%s is not a valid priority&quot; </span><span class="s1">% ioclass)</span>
        <span class="s1">cext.proc_io_priority_set(self.pid</span><span class="s3">, </span><span class="s1">ioclass)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">io_counters(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">ret = cext.proc_io_counters(self.pid)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if not </span><span class="s1">is_permission_err(err):</span>
                <span class="s3">raise</span>
            <span class="s1">info = self._proc_info()</span>
            <span class="s1">ret = (</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_rcount'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_wcount'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_rbytes'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_wbytes'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_count_others'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">info[pinfo_map[</span><span class="s4">'io_bytes_others'</span><span class="s1">]]</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">pio(*ret)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">status(self):</span>
        <span class="s1">suspended = cext.proc_is_suspended(self.pid)</span>
        <span class="s3">if </span><span class="s1">suspended:</span>
            <span class="s3">return </span><span class="s1">_common.STATUS_STOPPED</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">_common.STATUS_RUNNING</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_affinity_get(self):</span>
        <span class="s3">def </span><span class="s1">from_bitmask(x):</span>
            <span class="s3">return </span><span class="s1">[i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">64</span><span class="s1">) </span><span class="s3">if </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">&lt;&lt; i) &amp; x]</span>
        <span class="s1">bitmask = cext.proc_cpu_affinity_get(self.pid)</span>
        <span class="s3">return </span><span class="s1">from_bitmask(bitmask)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_affinity_set(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">def </span><span class="s1">to_bitmask(ls):</span>
            <span class="s3">if not </span><span class="s1">ls:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid argument %r&quot; </span><span class="s1">% ls)</span>
            <span class="s1">out = </span><span class="s5">0</span>
            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">ls:</span>
                <span class="s1">out |= </span><span class="s5">2 </span><span class="s1">** b</span>
            <span class="s3">return </span><span class="s1">out</span>

        <span class="s0"># SetProcessAffinityMask() states that ERROR_INVALID_PARAMETER</span>
        <span class="s0"># is returned for an invalid CPU but this seems not to be true,</span>
        <span class="s0"># therefore we check CPUs validy beforehand.</span>
        <span class="s1">allcpus = list(range(len(per_cpu_times())))</span>
        <span class="s3">for </span><span class="s1">cpu </span><span class="s3">in </span><span class="s1">value:</span>
            <span class="s3">if </span><span class="s1">cpu </span><span class="s3">not in </span><span class="s1">allcpus:</span>
                <span class="s3">if not </span><span class="s1">isinstance(cpu</span><span class="s3">, </span><span class="s1">(int</span><span class="s3">, </span><span class="s1">long)):</span>
                    <span class="s3">raise </span><span class="s1">TypeError(</span>
                        <span class="s4">&quot;invalid CPU %r; an integer is required&quot; </span><span class="s1">% cpu)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid CPU %r&quot; </span><span class="s1">% cpu)</span>

        <span class="s1">bitmask = to_bitmask(value)</span>
        <span class="s1">cext.proc_cpu_affinity_set(self.pid</span><span class="s3">, </span><span class="s1">bitmask)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_handles(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">cext.proc_num_handles(self.pid)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s3">if </span><span class="s1">is_permission_err(err):</span>
                <span class="s3">return </span><span class="s1">self._proc_info()[pinfo_map[</span><span class="s4">'num_handles'</span><span class="s1">]]</span>
            <span class="s3">raise</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_ctx_switches(self):</span>
        <span class="s1">ctx_switches = self._proc_info()[pinfo_map[</span><span class="s4">'ctx_switches'</span><span class="s1">]]</span>
        <span class="s0"># only voluntary ctx switches are supported</span>
        <span class="s3">return </span><span class="s1">_common.pctxsw(ctx_switches</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
</pre>
</body>
</html>
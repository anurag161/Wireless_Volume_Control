<html>
<head>
<title>_psaix.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_psaix.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009, Giampaolo Rodola'</span>
<span class="s0"># Copyright (c) 2017, Arnon Yaari</span>
<span class="s0"># All rights reserved.</span>
<span class="s0"># Use of this source code is governed by a BSD-style license that can be</span>
<span class="s0"># found in the LICENSE file.</span>

<span class="s2">&quot;&quot;&quot;AIX platform implementation.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">glob</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">subprocess</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_common</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psposix</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_aix </span><span class="s3">as </span><span class="s1">cext</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_posix </span><span class="s3">as </span><span class="s1">cext_posix</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_FULL</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_HALF</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_UNKNOWN</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">AccessDenied</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NoSuchProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">ZombieProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">conn_to_ntuple</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">get_procfs_path</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize_when_activated</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">usage_percent</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PY3</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">FileNotFoundError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PermissionError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">ProcessLookupError</span>


<span class="s1">__extra__all__ = [</span><span class="s4">&quot;PROCFS_PATH&quot;</span><span class="s1">]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- globals</span>
<span class="s0"># =====================================================================</span>


<span class="s1">HAS_THREADS = hasattr(cext</span><span class="s3">, </span><span class="s4">&quot;proc_threads&quot;</span><span class="s1">)</span>
<span class="s1">HAS_NET_IO_COUNTERS = hasattr(cext</span><span class="s3">, </span><span class="s4">&quot;net_io_counters&quot;</span><span class="s1">)</span>
<span class="s1">HAS_PROC_IO_COUNTERS = hasattr(cext</span><span class="s3">, </span><span class="s4">&quot;proc_io_counters&quot;</span><span class="s1">)</span>

<span class="s1">PAGE_SIZE = cext_posix.getpagesize()</span>
<span class="s1">AF_LINK = cext_posix.AF_LINK</span>

<span class="s1">PROC_STATUSES = {</span>
    <span class="s1">cext.SIDL: _common.STATUS_IDLE</span><span class="s3">,</span>
    <span class="s1">cext.SZOMB: _common.STATUS_ZOMBIE</span><span class="s3">,</span>
    <span class="s1">cext.SACTIVE: _common.STATUS_RUNNING</span><span class="s3">,</span>
    <span class="s1">cext.SSWAP: _common.STATUS_RUNNING</span><span class="s3">,      </span><span class="s0"># TODO what status is this?</span>
    <span class="s1">cext.SSTOP: _common.STATUS_STOPPED</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">TCP_STATUSES = {</span>
    <span class="s1">cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_SYN_RCVD: _common.CONN_SYN_RECV</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSED: _common.CONN_CLOSE</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_LISTEN: _common.CONN_LISTEN</span><span class="s3">,</span>
    <span class="s1">cext.TCPS_CLOSING: _common.CONN_CLOSING</span><span class="s3">,</span>
    <span class="s1">cext.PSUTIL_CONN_NONE: _common.CONN_NONE</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">proc_info_map = dict(</span>
    <span class="s1">ppid=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">rss=</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">vms=</span><span class="s5">2</span><span class="s3">,</span>
    <span class="s1">create_time=</span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">nice=</span><span class="s5">4</span><span class="s3">,</span>
    <span class="s1">num_threads=</span><span class="s5">5</span><span class="s3">,</span>
    <span class="s1">status=</span><span class="s5">6</span><span class="s3">,</span>
    <span class="s1">ttynr=</span><span class="s5">7</span><span class="s1">)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- named tuples</span>
<span class="s0"># =====================================================================</span>


<span class="s0"># psutil.Process.memory_info()</span>
<span class="s1">pmem = namedtuple(</span><span class="s4">'pmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'rss'</span><span class="s3">, </span><span class="s4">'vms'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.memory_full_info()</span>
<span class="s1">pfullmem = pmem</span>
<span class="s0"># psutil.Process.cpu_times()</span>
<span class="s1">scputimes = namedtuple(</span><span class="s4">'scputimes'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'user'</span><span class="s3">, </span><span class="s4">'system'</span><span class="s3">, </span><span class="s4">'idle'</span><span class="s3">, </span><span class="s4">'iowait'</span><span class="s1">])</span>
<span class="s0"># psutil.virtual_memory()</span>
<span class="s1">svmem = namedtuple(</span><span class="s4">'svmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s4">'total'</span><span class="s3">, </span><span class="s4">'available'</span><span class="s3">, </span><span class="s4">'percent'</span><span class="s3">, </span><span class="s4">'used'</span><span class="s3">, </span><span class="s4">'free'</span><span class="s1">])</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- memory</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">virtual_memory():</span>
    <span class="s1">total</span><span class="s3">, </span><span class="s1">avail</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">pinned</span><span class="s3">, </span><span class="s1">inuse = cext.virtual_mem()</span>
    <span class="s1">percent = usage_percent((total - avail)</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">svmem(total</span><span class="s3">, </span><span class="s1">avail</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">inuse</span><span class="s3">, </span><span class="s1">free)</span>


<span class="s3">def </span><span class="s1">swap_memory():</span>
    <span class="s2">&quot;&quot;&quot;Swap system memory as a (total, used, free, sin, sout) tuple.&quot;&quot;&quot;</span>
    <span class="s1">total</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout = cext.swap_mem()</span>
    <span class="s1">used = total - free</span>
    <span class="s1">percent = usage_percent(used</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_common.sswap(total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- CPU</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system-wide CPU times as a named tuple&quot;&quot;&quot;</span>
    <span class="s1">ret = cext.per_cpu_times()</span>
    <span class="s3">return </span><span class="s1">scputimes(*[sum(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">zip(*ret)])</span>


<span class="s3">def </span><span class="s1">per_cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return system per-CPU times as a list of named tuples&quot;&quot;&quot;</span>
    <span class="s1">ret = cext.per_cpu_times()</span>
    <span class="s3">return </span><span class="s1">[scputimes(*x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">ret]</span>


<span class="s3">def </span><span class="s1">cpu_count_logical():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of logical CPUs in the system.&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">os.sysconf(</span><span class="s4">&quot;SC_NPROCESSORS_ONLN&quot;</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
        <span class="s0"># mimic os.cpu_count() behavior</span>
        <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">cpu_count_cores():</span>
    <span class="s1">cmd = </span><span class="s4">&quot;lsdev -Cc processor&quot;</span>
    <span class="s1">p = subprocess.Popen(cmd</span><span class="s3">, </span><span class="s1">shell=</span><span class="s3">True, </span><span class="s1">stdout=subprocess.PIPE</span><span class="s3">,</span>
                         <span class="s1">stderr=subprocess.PIPE)</span>
    <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = p.communicate()</span>
    <span class="s3">if </span><span class="s1">PY3:</span>
        <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = [x.decode(sys.stdout.encoding)</span>
                          <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">(stdout</span><span class="s3">, </span><span class="s1">stderr)]</span>
    <span class="s3">if </span><span class="s1">p.returncode != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;%r command error</span><span class="s3">\n</span><span class="s4">%s&quot; </span><span class="s1">% (cmd</span><span class="s3">, </span><span class="s1">stderr))</span>
    <span class="s1">processors = stdout.strip().splitlines()</span>
    <span class="s3">return </span><span class="s1">len(processors) </span><span class="s3">or None</span>


<span class="s3">def </span><span class="s1">cpu_stats():</span>
    <span class="s2">&quot;&quot;&quot;Return various CPU stats as a named tuple.&quot;&quot;&quot;</span>
    <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">, </span><span class="s1">syscalls = cext.cpu_stats()</span>
    <span class="s3">return </span><span class="s1">_common.scpustats(</span>
        <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">, </span><span class="s1">syscalls)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- disks</span>
<span class="s0"># =====================================================================</span>


<span class="s1">disk_io_counters = cext.disk_io_counters</span>
<span class="s1">disk_usage = _psposix.disk_usage</span>


<span class="s3">def </span><span class="s1">disk_partitions(all=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return system disk partitions.&quot;&quot;&quot;</span>
    <span class="s0"># TODO - the filtering logic should be better checked so that</span>
    <span class="s0"># it tries to reflect 'df' as much as possible</span>
    <span class="s1">retlist = []</span>
    <span class="s1">partitions = cext.disk_partitions()</span>
    <span class="s3">for </span><span class="s1">partition </span><span class="s3">in </span><span class="s1">partitions:</span>
        <span class="s1">device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts = partition</span>
        <span class="s3">if </span><span class="s1">device == </span><span class="s4">'none'</span><span class="s1">:</span>
            <span class="s1">device = </span><span class="s4">''</span>
        <span class="s3">if not </span><span class="s1">all:</span>
            <span class="s0"># Differently from, say, Linux, we don't have a list of</span>
            <span class="s0"># common fs types so the best we can do, AFAIK, is to</span>
            <span class="s0"># filter by filesystem having a total size &gt; 0.</span>
            <span class="s3">if not </span><span class="s1">disk_usage(mountpoint).total:</span>
                <span class="s3">continue</span>
        <span class="s1">maxfile = maxpath = </span><span class="s3">None  </span><span class="s0"># set later</span>
        <span class="s1">ntuple = _common.sdiskpart(device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">,</span>
                                   <span class="s1">maxfile</span><span class="s3">, </span><span class="s1">maxpath)</span>
        <span class="s1">retlist.append(ntuple)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- network</span>
<span class="s0"># =====================================================================</span>


<span class="s1">net_if_addrs = cext_posix.net_if_addrs</span>

<span class="s3">if </span><span class="s1">HAS_NET_IO_COUNTERS:</span>
    <span class="s1">net_io_counters = cext.net_io_counters</span>


<span class="s3">def </span><span class="s1">net_connections(kind</span><span class="s3">, </span><span class="s1">_pid=-</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return socket connections.  If pid == -1 return system-wide 
    connections (as opposed to connections opened by one process only). 
    &quot;&quot;&quot;</span>
    <span class="s1">cmap = _common.conn_tmap</span>
    <span class="s3">if </span><span class="s1">kind </span><span class="s3">not in </span><span class="s1">cmap:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;invalid %r kind argument; choose between %s&quot;</span>
                         <span class="s1">% (kind</span><span class="s3">, </span><span class="s4">', '</span><span class="s1">.join([repr(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">cmap])))</span>
    <span class="s1">families</span><span class="s3">, </span><span class="s1">types = _common.conn_tmap[kind]</span>
    <span class="s1">rawlist = cext.net_connections(_pid)</span>
    <span class="s1">ret = []</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">pid = item</span>
        <span class="s3">if </span><span class="s1">fam </span><span class="s3">not in </span><span class="s1">families:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">type_ </span><span class="s3">not in </span><span class="s1">types:</span>
            <span class="s3">continue</span>
        <span class="s1">nt = conn_to_ntuple(fd</span><span class="s3">, </span><span class="s1">fam</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">,</span>
                            <span class="s1">TCP_STATUSES</span><span class="s3">, </span><span class="s1">pid=pid </span><span class="s3">if </span><span class="s1">_pid == -</span><span class="s5">1 </span><span class="s3">else None</span><span class="s1">)</span>
        <span class="s1">ret.append(nt)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">net_if_stats():</span>
    <span class="s2">&quot;&quot;&quot;Get NIC stats (isup, duplex, speed, mtu).&quot;&quot;&quot;</span>
    <span class="s1">duplex_map = {</span><span class="s4">&quot;Full&quot;</span><span class="s1">: NIC_DUPLEX_FULL</span><span class="s3">,</span>
                  <span class="s4">&quot;Half&quot;</span><span class="s1">: NIC_DUPLEX_HALF}</span>
    <span class="s1">names = set([x[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">net_if_addrs()])</span>
    <span class="s1">ret = {}</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s1">mtu = cext_posix.net_if_mtu(name)</span>
        <span class="s1">flags = cext_posix.net_if_flags(name)</span>

        <span class="s0"># try to get speed and duplex</span>
        <span class="s0"># TODO: rewrite this in C (entstat forks, so use truss -f to follow.</span>
        <span class="s0"># looks like it is using an undocumented ioctl?)</span>
        <span class="s1">duplex = </span><span class="s4">&quot;&quot;</span>
        <span class="s1">speed = </span><span class="s5">0</span>
        <span class="s1">p = subprocess.Popen([</span><span class="s4">&quot;/usr/bin/entstat&quot;</span><span class="s3">, </span><span class="s4">&quot;-d&quot;</span><span class="s3">, </span><span class="s1">name]</span><span class="s3">,</span>
                             <span class="s1">stdout=subprocess.PIPE</span><span class="s3">, </span><span class="s1">stderr=subprocess.PIPE)</span>
        <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = p.communicate()</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = [x.decode(sys.stdout.encoding)</span>
                              <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">(stdout</span><span class="s3">, </span><span class="s1">stderr)]</span>
        <span class="s3">if </span><span class="s1">p.returncode == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">re_result = re.search(</span>
                <span class="s4">r&quot;Running: (\d+) Mbps.*?(\w+) Duplex&quot;</span><span class="s3">, </span><span class="s1">stdout)</span>
            <span class="s3">if </span><span class="s1">re_result </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">speed = int(re_result.group(</span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">duplex = re_result.group(</span><span class="s5">2</span><span class="s1">)</span>

        <span class="s1">output_flags = </span><span class="s4">','</span><span class="s1">.join(flags)</span>
        <span class="s1">isup = </span><span class="s4">'running' </span><span class="s3">in </span><span class="s1">flags</span>
        <span class="s1">duplex = duplex_map.get(duplex</span><span class="s3">, </span><span class="s1">NIC_DUPLEX_UNKNOWN)</span>
        <span class="s1">ret[name] = _common.snicstats(isup</span><span class="s3">, </span><span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">mtu</span><span class="s3">, </span><span class="s1">output_flags)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- other system functions</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">boot_time():</span>
    <span class="s2">&quot;&quot;&quot;The system boot time expressed in seconds since the epoch.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">cext.boot_time()</span>


<span class="s3">def </span><span class="s1">users():</span>
    <span class="s2">&quot;&quot;&quot;Return currently connected users as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">retlist = []</span>
    <span class="s1">rawlist = cext.users()</span>
    <span class="s1">localhost = (</span><span class="s4">':0.0'</span><span class="s3">, </span><span class="s4">':0'</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">tty</span><span class="s3">, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">user_process</span><span class="s3">, </span><span class="s1">pid = item</span>
        <span class="s0"># note: the underlying C function includes entries about</span>
        <span class="s0"># system boot, run level and others.  We might want</span>
        <span class="s0"># to use them in the future.</span>
        <span class="s3">if not </span><span class="s1">user_process:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">hostname </span><span class="s3">in </span><span class="s1">localhost:</span>
            <span class="s1">hostname = </span><span class="s4">'localhost'</span>
        <span class="s1">nt = _common.suser(user</span><span class="s3">, </span><span class="s1">tty</span><span class="s3">, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">pid)</span>
        <span class="s1">retlist.append(nt)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- processes</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">pids():</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of PIDs currently running on the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">[int(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">os.listdir(get_procfs_path()) </span><span class="s3">if </span><span class="s1">x.isdigit()]</span>


<span class="s3">def </span><span class="s1">pid_exists(pid):</span>
    <span class="s2">&quot;&quot;&quot;Check for the existence of a unix pid.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">os.path.exists(os.path.join(get_procfs_path()</span><span class="s3">, </span><span class="s1">str(pid)</span><span class="s3">, </span><span class="s4">&quot;psinfo&quot;</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">wrap_exceptions(fun):</span>
    <span class="s2">&quot;&quot;&quot;Call callable into a try/except clause and translate ENOENT, 
    EACCES and EPERM in NoSuchProcess or AccessDenied exceptions. 
    &quot;&quot;&quot;</span>
    <span class="s1">@functools.wraps(fun)</span>
    <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
            <span class="s0"># ENOENT (no such file or directory) gets raised on open().</span>
            <span class="s0"># ESRCH (no such process) can get raised on read() if</span>
            <span class="s0"># process is gone in meantime.</span>
            <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
        <span class="s3">except </span><span class="s1">PermissionError:</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">Process(object):</span>
    <span class="s2">&quot;&quot;&quot;Wrapper class around underlying C implementation.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span><span class="s4">&quot;pid&quot;</span><span class="s3">, </span><span class="s4">&quot;_name&quot;</span><span class="s3">, </span><span class="s4">&quot;_ppid&quot;</span><span class="s3">, </span><span class="s4">&quot;_procfs_path&quot;</span><span class="s3">, </span><span class="s4">&quot;_cache&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pid):</span>
        <span class="s1">self.pid = pid</span>
        <span class="s1">self._name = </span><span class="s3">None</span>
        <span class="s1">self._ppid = </span><span class="s3">None</span>
        <span class="s1">self._procfs_path = get_procfs_path()</span>

    <span class="s3">def </span><span class="s1">oneshot_enter(self):</span>
        <span class="s1">self._proc_basic_info.cache_activate(self)</span>
        <span class="s1">self._proc_cred.cache_activate(self)</span>

    <span class="s3">def </span><span class="s1">oneshot_exit(self):</span>
        <span class="s1">self._proc_basic_info.cache_deactivate(self)</span>
        <span class="s1">self._proc_cred.cache_deactivate(self)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_proc_basic_info(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_basic_info(self.pid</span><span class="s3">, </span><span class="s1">self._procfs_path)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_proc_cred(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_cred(self.pid</span><span class="s3">, </span><span class="s1">self._procfs_path)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s4">&quot;swapper&quot;</span>
        <span class="s0"># note: max 16 characters</span>
        <span class="s3">return </span><span class="s1">cext.proc_name(self.pid</span><span class="s3">, </span><span class="s1">self._procfs_path).rstrip(</span><span class="s4">&quot;</span><span class="s3">\x00</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">exe(self):</span>
        <span class="s0"># there is no way to get executable path in AIX other than to guess,</span>
        <span class="s0"># and guessing is more complex than what's in the wrapping class</span>
        <span class="s1">cmdline = self.cmdline()</span>
        <span class="s3">if not </span><span class="s1">cmdline:</span>
            <span class="s3">return </span><span class="s4">''</span>
        <span class="s1">exe = cmdline[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">os.path.sep </span><span class="s3">in </span><span class="s1">exe:</span>
            <span class="s0"># relative or absolute path</span>
            <span class="s3">if not </span><span class="s1">os.path.isabs(exe):</span>
                <span class="s0"># if cwd has changed, we're out of luck - this may be wrong!</span>
                <span class="s1">exe = os.path.abspath(os.path.join(self.cwd()</span><span class="s3">, </span><span class="s1">exe))</span>
            <span class="s3">if </span><span class="s1">(os.path.isabs(exe) </span><span class="s3">and</span>
                    <span class="s1">os.path.isfile(exe) </span><span class="s3">and</span>
                    <span class="s1">os.access(exe</span><span class="s3">, </span><span class="s1">os.X_OK)):</span>
                <span class="s3">return </span><span class="s1">exe</span>
            <span class="s0"># not found, move to search in PATH using basename only</span>
            <span class="s1">exe = os.path.basename(exe)</span>
        <span class="s0"># search for exe name PATH</span>
        <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">os.environ[</span><span class="s4">&quot;PATH&quot;</span><span class="s1">].split(</span><span class="s4">&quot;:&quot;</span><span class="s1">):</span>
            <span class="s1">possible_exe = os.path.abspath(os.path.join(path</span><span class="s3">, </span><span class="s1">exe))</span>
            <span class="s3">if </span><span class="s1">(os.path.isfile(possible_exe) </span><span class="s3">and</span>
                    <span class="s1">os.access(possible_exe</span><span class="s3">, </span><span class="s1">os.X_OK)):</span>
                <span class="s3">return </span><span class="s1">possible_exe</span>
        <span class="s3">return </span><span class="s4">''</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cmdline(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_args(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">environ(self):</span>
        <span class="s3">return </span><span class="s1">cext.proc_environ(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">create_time(self):</span>
        <span class="s3">return </span><span class="s1">self._proc_basic_info()[proc_info_map[</span><span class="s4">'create_time'</span><span class="s1">]]</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_threads(self):</span>
        <span class="s3">return </span><span class="s1">self._proc_basic_info()[proc_info_map[</span><span class="s4">'num_threads'</span><span class="s1">]]</span>

    <span class="s3">if </span><span class="s1">HAS_THREADS:</span>
        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">threads(self):</span>
            <span class="s1">rawlist = cext.proc_threads(self.pid)</span>
            <span class="s1">retlist = []</span>
            <span class="s3">for </span><span class="s1">thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime </span><span class="s3">in </span><span class="s1">rawlist:</span>
                <span class="s1">ntuple = _common.pthread(thread_id</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime)</span>
                <span class="s1">retlist.append(ntuple)</span>
            <span class="s0"># The underlying C implementation retrieves all OS threads</span>
            <span class="s0"># and filters them by PID.  At this point we can't tell whether</span>
            <span class="s0"># an empty list means there were no connections for process or</span>
            <span class="s0"># process is no longer active so we force NSP in case the PID</span>
            <span class="s0"># is no longer there.</span>
            <span class="s3">if not </span><span class="s1">retlist:</span>
                <span class="s0"># will raise NSP if process is gone</span>
                <span class="s1">os.stat(</span><span class="s4">'%s/%s' </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
            <span class="s3">return </span><span class="s1">retlist</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">connections(self</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">'inet'</span><span class="s1">):</span>
        <span class="s1">ret = net_connections(kind</span><span class="s3">, </span><span class="s1">_pid=self.pid)</span>
        <span class="s0"># The underlying C implementation retrieves all OS connections</span>
        <span class="s0"># and filters them by PID.  At this point we can't tell whether</span>
        <span class="s0"># an empty list means there were no connections for process or</span>
        <span class="s0"># process is no longer active so we force NSP in case the PID</span>
        <span class="s0"># is no longer there.</span>
        <span class="s3">if not </span><span class="s1">ret:</span>
            <span class="s0"># will raise NSP if process is gone</span>
            <span class="s1">os.stat(</span><span class="s4">'%s/%s' </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_get(self):</span>
        <span class="s3">return </span><span class="s1">cext_posix.getpriority(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_set(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">cext_posix.setpriority(self.pid</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">ppid(self):</span>
        <span class="s1">self._ppid = self._proc_basic_info()[proc_info_map[</span><span class="s4">'ppid'</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">self._ppid</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">uids(self):</span>
        <span class="s1">real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ = self._proc_cred()</span>
        <span class="s3">return </span><span class="s1">_common.puids(real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">gids(self):</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved = self._proc_cred()</span>
        <span class="s3">return </span><span class="s1">_common.puids(real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_times(self):</span>
        <span class="s1">cpu_times = cext.proc_cpu_times(self.pid</span><span class="s3">, </span><span class="s1">self._procfs_path)</span>
        <span class="s3">return </span><span class="s1">_common.pcputimes(*cpu_times)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">terminal(self):</span>
        <span class="s1">ttydev = self._proc_basic_info()[proc_info_map[</span><span class="s4">'ttynr'</span><span class="s1">]]</span>
        <span class="s0"># convert from 64-bit dev_t to 32-bit dev_t and then map the device</span>
        <span class="s1">ttydev = (((ttydev &amp; </span><span class="s5">0x0000FFFF00000000</span><span class="s1">) &gt;&gt; </span><span class="s5">16</span><span class="s1">) | (ttydev &amp; </span><span class="s5">0xFFFF</span><span class="s1">))</span>
        <span class="s0"># try to match rdev of /dev/pts/* files ttydev</span>
        <span class="s3">for </span><span class="s1">dev </span><span class="s3">in </span><span class="s1">glob.glob(</span><span class="s4">&quot;/dev/**/*&quot;</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">os.stat(dev).st_rdev == ttydev:</span>
                <span class="s3">return </span><span class="s1">dev</span>
        <span class="s3">return None</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cwd(self):</span>
        <span class="s1">procfs_path = self._procfs_path</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">result = os.readlink(</span><span class="s4">&quot;%s/%s/cwd&quot; </span><span class="s1">% (procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
            <span class="s3">return </span><span class="s1">result.rstrip(</span><span class="s4">'/'</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">FileNotFoundError:</span>
            <span class="s1">os.stat(</span><span class="s4">&quot;%s/%s&quot; </span><span class="s1">% (procfs_path</span><span class="s3">, </span><span class="s1">self.pid))  </span><span class="s0"># raise NSP or AD</span>
            <span class="s3">return None</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_info(self):</span>
        <span class="s1">ret = self._proc_basic_info()</span>
        <span class="s1">rss = ret[proc_info_map[</span><span class="s4">'rss'</span><span class="s1">]] * </span><span class="s5">1024</span>
        <span class="s1">vms = ret[proc_info_map[</span><span class="s4">'vms'</span><span class="s1">]] * </span><span class="s5">1024</span>
        <span class="s3">return </span><span class="s1">pmem(rss</span><span class="s3">, </span><span class="s1">vms)</span>

    <span class="s1">memory_full_info = memory_info</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">status(self):</span>
        <span class="s1">code = self._proc_basic_info()[proc_info_map[</span><span class="s4">'status'</span><span class="s1">]]</span>
        <span class="s0"># XXX is '?' legit? (we're not supposed to return it anyway)</span>
        <span class="s3">return </span><span class="s1">PROC_STATUSES.get(code</span><span class="s3">, </span><span class="s4">'?'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">open_files(self):</span>
        <span class="s0"># TODO rewrite without using procfiles (stat /proc/pid/fd/* and then</span>
        <span class="s0"># find matching name of the inode)</span>
        <span class="s1">p = subprocess.Popen([</span><span class="s4">&quot;/usr/bin/procfiles&quot;</span><span class="s3">, </span><span class="s4">&quot;-n&quot;</span><span class="s3">, </span><span class="s1">str(self.pid)]</span><span class="s3">,</span>
                             <span class="s1">stdout=subprocess.PIPE</span><span class="s3">, </span><span class="s1">stderr=subprocess.PIPE)</span>
        <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = p.communicate()</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">stdout</span><span class="s3">, </span><span class="s1">stderr = [x.decode(sys.stdout.encoding)</span>
                              <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">(stdout</span><span class="s3">, </span><span class="s1">stderr)]</span>
        <span class="s3">if </span><span class="s4">&quot;no such process&quot; </span><span class="s3">in </span><span class="s1">stderr.lower():</span>
            <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s1">procfiles = re.findall(</span><span class="s4">r&quot;(\d+): S_IFREG.*\s*.*name:(.*)\n&quot;</span><span class="s3">, </span><span class="s1">stdout)</span>
        <span class="s1">retlist = []</span>
        <span class="s3">for </span><span class="s1">fd</span><span class="s3">, </span><span class="s1">path </span><span class="s3">in </span><span class="s1">procfiles:</span>
            <span class="s1">path = path.strip()</span>
            <span class="s3">if </span><span class="s1">path.startswith(</span><span class="s4">&quot;//&quot;</span><span class="s1">):</span>
                <span class="s1">path = path[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s3">if </span><span class="s1">path.lower() == </span><span class="s4">&quot;cannot be retrieved&quot;</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">retlist.append(_common.popenfile(path</span><span class="s3">, </span><span class="s1">int(fd)))</span>
        <span class="s3">return </span><span class="s1">retlist</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_fds(self):</span>
        <span class="s3">if </span><span class="s1">self.pid == </span><span class="s5">0</span><span class="s1">:       </span><span class="s0"># no /proc/0/fd</span>
            <span class="s3">return </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">len(os.listdir(</span><span class="s4">&quot;%s/%s/fd&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_ctx_switches(self):</span>
        <span class="s3">return </span><span class="s1">_common.pctxsw(</span>
            <span class="s1">*cext.proc_num_ctx_switches(self.pid))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">wait(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">_psposix.wait_pid(self.pid</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">self._name)</span>

    <span class="s3">if </span><span class="s1">HAS_PROC_IO_COUNTERS:</span>
        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">io_counters(self):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">rc</span><span class="s3">, </span><span class="s1">wc</span><span class="s3">, </span><span class="s1">rb</span><span class="s3">, </span><span class="s1">wb = cext.proc_io_counters(self.pid)</span>
            <span class="s3">except </span><span class="s1">OSError:</span>
                <span class="s0"># if process is terminated, proc_io_counters returns OSError</span>
                <span class="s0"># instead of NSP</span>
                <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                    <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
                <span class="s3">raise</span>
            <span class="s3">return </span><span class="s1">_common.pio(rc</span><span class="s3">, </span><span class="s1">wc</span><span class="s3">, </span><span class="s1">rb</span><span class="s3">, </span><span class="s1">wb)</span>
</pre>
</body>
</html>
<html>
<head>
<title>_pslinux.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_pslinux.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.</span>
<span class="s0"># Use of this source code is governed by a BSD-style license that can be</span>
<span class="s0"># found in the LICENSE file.</span>

<span class="s2">&quot;&quot;&quot;Linux platform implementation.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">division</span>

<span class="s3">import </span><span class="s1">base64</span>
<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">glob</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">socket</span>
<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">traceback</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">defaultdict</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_common</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psposix</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_linux </span><span class="s3">as </span><span class="s1">cext</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_psutil_posix </span><span class="s3">as </span><span class="s1">cext_posix</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_FULL</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_HALF</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NIC_DUPLEX_UNKNOWN</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">AccessDenied</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">NoSuchProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">ZombieProcess</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">bcat</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">cat</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">debug</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">decode</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">get_procfs_path</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">isfile_strict</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">memoize_when_activated</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">open_binary</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">open_text</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">parse_environ_block</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">path_exists_strict</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">supports_ipv6</span>
<span class="s3">from </span><span class="s1">._common </span><span class="s3">import </span><span class="s1">usage_percent</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PY3</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">FileNotFoundError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">PermissionError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">ProcessLookupError</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">b</span>
<span class="s3">from </span><span class="s1">._compat </span><span class="s3">import </span><span class="s1">basestring</span>


<span class="s3">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s1">):</span>
    <span class="s3">import </span><span class="s1">enum</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">enum = </span><span class="s3">None</span>


<span class="s1">__extra__all__ = [</span>
    <span class="s0">#</span>
    <span class="s5">'PROCFS_PATH'</span><span class="s3">,</span>
    <span class="s0"># io prio constants</span>
    <span class="s5">&quot;IOPRIO_CLASS_NONE&quot;</span><span class="s3">, </span><span class="s5">&quot;IOPRIO_CLASS_RT&quot;</span><span class="s3">, </span><span class="s5">&quot;IOPRIO_CLASS_BE&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;IOPRIO_CLASS_IDLE&quot;</span><span class="s3">,</span>
    <span class="s0"># connection status constants</span>
    <span class="s5">&quot;CONN_ESTABLISHED&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_SYN_SENT&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_SYN_RECV&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_FIN_WAIT1&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;CONN_FIN_WAIT2&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_TIME_WAIT&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_CLOSE&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_CLOSE_WAIT&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;CONN_LAST_ACK&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_LISTEN&quot;</span><span class="s3">, </span><span class="s5">&quot;CONN_CLOSING&quot;</span><span class="s3">, </span><span class="s1">]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- globals</span>
<span class="s0"># =====================================================================</span>


<span class="s1">POWER_SUPPLY_PATH = </span><span class="s5">&quot;/sys/class/power_supply&quot;</span>
<span class="s1">HAS_PROC_SMAPS = os.path.exists(</span><span class="s5">'/proc/%s/smaps' </span><span class="s1">% os.getpid())</span>
<span class="s1">HAS_PROC_SMAPS_ROLLUP = os.path.exists(</span><span class="s5">'/proc/%s/smaps_rollup' </span><span class="s1">% os.getpid())</span>
<span class="s1">HAS_PROC_IO_PRIORITY = hasattr(cext</span><span class="s3">, </span><span class="s5">&quot;proc_ioprio_get&quot;</span><span class="s1">)</span>
<span class="s1">HAS_CPU_AFFINITY = hasattr(cext</span><span class="s3">, </span><span class="s5">&quot;proc_cpu_affinity_get&quot;</span><span class="s1">)</span>

<span class="s0"># Number of clock ticks per second</span>
<span class="s1">CLOCK_TICKS = os.sysconf(</span><span class="s5">&quot;SC_CLK_TCK&quot;</span><span class="s1">)</span>
<span class="s1">PAGESIZE = cext_posix.getpagesize()</span>
<span class="s1">BOOT_TIME = </span><span class="s3">None  </span><span class="s0"># set later</span>
<span class="s1">LITTLE_ENDIAN = sys.byteorder == </span><span class="s5">'little'</span>

<span class="s0"># &quot;man iostat&quot; states that sectors are equivalent with blocks and have</span>
<span class="s0"># a size of 512 bytes. Despite this value can be queried at runtime</span>
<span class="s0"># via /sys/block/{DISK}/queue/hw_sector_size and results may vary</span>
<span class="s0"># between 1k, 2k, or 4k... 512 appears to be a magic constant used</span>
<span class="s0"># throughout Linux source code:</span>
<span class="s0"># * https://stackoverflow.com/a/38136179/376587</span>
<span class="s0"># * https://lists.gt.net/linux/kernel/2241060</span>
<span class="s0"># * https://github.com/giampaolo/psutil/issues/1305</span>
<span class="s0"># * https://github.com/torvalds/linux/blob/</span>
<span class="s0">#     4f671fe2f9523a1ea206f63fe60a7c7b3a56d5c7/include/linux/bio.h#L99</span>
<span class="s0"># * https://lkml.org/lkml/2015/8/17/234</span>
<span class="s1">DISK_SECTOR_SIZE = </span><span class="s4">512</span>

<span class="s3">if </span><span class="s1">enum </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">AF_LINK = socket.AF_PACKET</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s1">AddressFamily = enum.IntEnum(</span><span class="s5">'AddressFamily'</span><span class="s3">,</span>
                                 <span class="s1">{</span><span class="s5">'AF_LINK'</span><span class="s1">: int(socket.AF_PACKET)})</span>
    <span class="s1">AF_LINK = AddressFamily.AF_LINK</span>

<span class="s0"># ioprio_* constants http://linux.die.net/man/2/ioprio_get</span>
<span class="s3">if </span><span class="s1">enum </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">IOPRIO_CLASS_NONE = </span><span class="s4">0</span>
    <span class="s1">IOPRIO_CLASS_RT = </span><span class="s4">1</span>
    <span class="s1">IOPRIO_CLASS_BE = </span><span class="s4">2</span>
    <span class="s1">IOPRIO_CLASS_IDLE = </span><span class="s4">3</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">class </span><span class="s1">IOPriority(enum.IntEnum):</span>
        <span class="s1">IOPRIO_CLASS_NONE = </span><span class="s4">0</span>
        <span class="s1">IOPRIO_CLASS_RT = </span><span class="s4">1</span>
        <span class="s1">IOPRIO_CLASS_BE = </span><span class="s4">2</span>
        <span class="s1">IOPRIO_CLASS_IDLE = </span><span class="s4">3</span>

    <span class="s1">globals().update(IOPriority.__members__)</span>

<span class="s0"># See:</span>
<span class="s0"># https://github.com/torvalds/linux/blame/master/fs/proc/array.c</span>
<span class="s0"># ...and (TASK_* constants):</span>
<span class="s0"># https://github.com/torvalds/linux/blob/master/include/linux/sched.h</span>
<span class="s1">PROC_STATUSES = {</span>
    <span class="s5">&quot;R&quot;</span><span class="s1">: _common.STATUS_RUNNING</span><span class="s3">,</span>
    <span class="s5">&quot;S&quot;</span><span class="s1">: _common.STATUS_SLEEPING</span><span class="s3">,</span>
    <span class="s5">&quot;D&quot;</span><span class="s1">: _common.STATUS_DISK_SLEEP</span><span class="s3">,</span>
    <span class="s5">&quot;T&quot;</span><span class="s1">: _common.STATUS_STOPPED</span><span class="s3">,</span>
    <span class="s5">&quot;t&quot;</span><span class="s1">: _common.STATUS_TRACING_STOP</span><span class="s3">,</span>
    <span class="s5">&quot;Z&quot;</span><span class="s1">: _common.STATUS_ZOMBIE</span><span class="s3">,</span>
    <span class="s5">&quot;X&quot;</span><span class="s1">: _common.STATUS_DEAD</span><span class="s3">,</span>
    <span class="s5">&quot;x&quot;</span><span class="s1">: _common.STATUS_DEAD</span><span class="s3">,</span>
    <span class="s5">&quot;K&quot;</span><span class="s1">: _common.STATUS_WAKE_KILL</span><span class="s3">,</span>
    <span class="s5">&quot;W&quot;</span><span class="s1">: _common.STATUS_WAKING</span><span class="s3">,</span>
    <span class="s5">&quot;I&quot;</span><span class="s1">: _common.STATUS_IDLE</span><span class="s3">,</span>
    <span class="s5">&quot;P&quot;</span><span class="s1">: _common.STATUS_PARKED</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s0"># https://github.com/torvalds/linux/blob/master/include/net/tcp_states.h</span>
<span class="s1">TCP_STATUSES = {</span>
    <span class="s5">&quot;01&quot;</span><span class="s1">: _common.CONN_ESTABLISHED</span><span class="s3">,</span>
    <span class="s5">&quot;02&quot;</span><span class="s1">: _common.CONN_SYN_SENT</span><span class="s3">,</span>
    <span class="s5">&quot;03&quot;</span><span class="s1">: _common.CONN_SYN_RECV</span><span class="s3">,</span>
    <span class="s5">&quot;04&quot;</span><span class="s1">: _common.CONN_FIN_WAIT1</span><span class="s3">,</span>
    <span class="s5">&quot;05&quot;</span><span class="s1">: _common.CONN_FIN_WAIT2</span><span class="s3">,</span>
    <span class="s5">&quot;06&quot;</span><span class="s1">: _common.CONN_TIME_WAIT</span><span class="s3">,</span>
    <span class="s5">&quot;07&quot;</span><span class="s1">: _common.CONN_CLOSE</span><span class="s3">,</span>
    <span class="s5">&quot;08&quot;</span><span class="s1">: _common.CONN_CLOSE_WAIT</span><span class="s3">,</span>
    <span class="s5">&quot;09&quot;</span><span class="s1">: _common.CONN_LAST_ACK</span><span class="s3">,</span>
    <span class="s5">&quot;0A&quot;</span><span class="s1">: _common.CONN_LISTEN</span><span class="s3">,</span>
    <span class="s5">&quot;0B&quot;</span><span class="s1">: _common.CONN_CLOSING</span>
<span class="s1">}</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- named tuples</span>
<span class="s0"># =====================================================================</span>


<span class="s0"># psutil.virtual_memory()</span>
<span class="s1">svmem = namedtuple(</span>
    <span class="s5">'svmem'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'total'</span><span class="s3">, </span><span class="s5">'available'</span><span class="s3">, </span><span class="s5">'percent'</span><span class="s3">, </span><span class="s5">'used'</span><span class="s3">, </span><span class="s5">'free'</span><span class="s3">,</span>
              <span class="s5">'active'</span><span class="s3">, </span><span class="s5">'inactive'</span><span class="s3">, </span><span class="s5">'buffers'</span><span class="s3">, </span><span class="s5">'cached'</span><span class="s3">, </span><span class="s5">'shared'</span><span class="s3">, </span><span class="s5">'slab'</span><span class="s1">])</span>
<span class="s0"># psutil.disk_io_counters()</span>
<span class="s1">sdiskio = namedtuple(</span>
    <span class="s5">'sdiskio'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'read_count'</span><span class="s3">, </span><span class="s5">'write_count'</span><span class="s3">,</span>
                <span class="s5">'read_bytes'</span><span class="s3">, </span><span class="s5">'write_bytes'</span><span class="s3">,</span>
                <span class="s5">'read_time'</span><span class="s3">, </span><span class="s5">'write_time'</span><span class="s3">,</span>
                <span class="s5">'read_merged_count'</span><span class="s3">, </span><span class="s5">'write_merged_count'</span><span class="s3">,</span>
                <span class="s5">'busy_time'</span><span class="s1">])</span>
<span class="s0"># psutil.Process().open_files()</span>
<span class="s1">popenfile = namedtuple(</span>
    <span class="s5">'popenfile'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'path'</span><span class="s3">, </span><span class="s5">'fd'</span><span class="s3">, </span><span class="s5">'position'</span><span class="s3">, </span><span class="s5">'mode'</span><span class="s3">, </span><span class="s5">'flags'</span><span class="s1">])</span>
<span class="s0"># psutil.Process().memory_info()</span>
<span class="s1">pmem = namedtuple(</span><span class="s5">'pmem'</span><span class="s3">, </span><span class="s5">'rss vms shared text lib data dirty'</span><span class="s1">)</span>
<span class="s0"># psutil.Process().memory_full_info()</span>
<span class="s1">pfullmem = namedtuple(</span><span class="s5">'pfullmem'</span><span class="s3">, </span><span class="s1">pmem._fields + (</span><span class="s5">'uss'</span><span class="s3">, </span><span class="s5">'pss'</span><span class="s3">, </span><span class="s5">'swap'</span><span class="s1">))</span>
<span class="s0"># psutil.Process().memory_maps(grouped=True)</span>
<span class="s1">pmmap_grouped = namedtuple(</span>
    <span class="s5">'pmmap_grouped'</span><span class="s3">,</span>
    <span class="s1">[</span><span class="s5">'path'</span><span class="s3">, </span><span class="s5">'rss'</span><span class="s3">, </span><span class="s5">'size'</span><span class="s3">, </span><span class="s5">'pss'</span><span class="s3">, </span><span class="s5">'shared_clean'</span><span class="s3">, </span><span class="s5">'shared_dirty'</span><span class="s3">,</span>
     <span class="s5">'private_clean'</span><span class="s3">, </span><span class="s5">'private_dirty'</span><span class="s3">, </span><span class="s5">'referenced'</span><span class="s3">, </span><span class="s5">'anonymous'</span><span class="s3">, </span><span class="s5">'swap'</span><span class="s1">])</span>
<span class="s0"># psutil.Process().memory_maps(grouped=False)</span>
<span class="s1">pmmap_ext = namedtuple(</span>
    <span class="s5">'pmmap_ext'</span><span class="s3">, </span><span class="s5">'addr perms ' </span><span class="s1">+ </span><span class="s5">' '</span><span class="s1">.join(pmmap_grouped._fields))</span>
<span class="s0"># psutil.Process.io_counters()</span>
<span class="s1">pio = namedtuple(</span><span class="s5">'pio'</span><span class="s3">, </span><span class="s1">[</span><span class="s5">'read_count'</span><span class="s3">, </span><span class="s5">'write_count'</span><span class="s3">,</span>
                         <span class="s5">'read_bytes'</span><span class="s3">, </span><span class="s5">'write_bytes'</span><span class="s3">,</span>
                         <span class="s5">'read_chars'</span><span class="s3">, </span><span class="s5">'write_chars'</span><span class="s1">])</span>
<span class="s0"># psutil.Process.cpu_times()</span>
<span class="s1">pcputimes = namedtuple(</span><span class="s5">'pcputimes'</span><span class="s3">,</span>
                       <span class="s1">[</span><span class="s5">'user'</span><span class="s3">, </span><span class="s5">'system'</span><span class="s3">, </span><span class="s5">'children_user'</span><span class="s3">, </span><span class="s5">'children_system'</span><span class="s3">,</span>
                        <span class="s5">'iowait'</span><span class="s1">])</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- utils</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">readlink(path):</span>
    <span class="s2">&quot;&quot;&quot;Wrapper around os.readlink().&quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(path</span><span class="s3">, </span><span class="s1">basestring)</span><span class="s3">, </span><span class="s1">path</span>
    <span class="s1">path = os.readlink(path)</span>
    <span class="s0"># readlink() might return paths containing null bytes ('\x00')</span>
    <span class="s0"># resulting in &quot;TypeError: must be encoded string without NULL</span>
    <span class="s0"># bytes, not str&quot; errors when the string is passed to other</span>
    <span class="s0"># fs-related functions (os.*, open(), ...).</span>
    <span class="s0"># Apparently everything after '\x00' is garbage (we can have</span>
    <span class="s0"># ' (deleted)', 'new' and possibly others), see:</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/717</span>
    <span class="s1">path = path.split(</span><span class="s5">'</span><span class="s3">\x00</span><span class="s5">'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0"># Certain paths have ' (deleted)' appended. Usually this is</span>
    <span class="s0"># bogus as the file actually exists. Even if it doesn't we</span>
    <span class="s0"># don't care.</span>
    <span class="s3">if </span><span class="s1">path.endswith(</span><span class="s5">' (deleted)'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">path_exists_strict(path):</span>
        <span class="s1">path = path[:-</span><span class="s4">10</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">path</span>


<span class="s3">def </span><span class="s1">file_flags_to_mode(flags):</span>
    <span class="s2">&quot;&quot;&quot;Convert file's open() flags into a readable string. 
    Used by Process.open_files(). 
    &quot;&quot;&quot;</span>
    <span class="s1">modes_map = {os.O_RDONLY: </span><span class="s5">'r'</span><span class="s3">, </span><span class="s1">os.O_WRONLY: </span><span class="s5">'w'</span><span class="s3">, </span><span class="s1">os.O_RDWR: </span><span class="s5">'w+'</span><span class="s1">}</span>
    <span class="s1">mode = modes_map[flags &amp; (os.O_RDONLY | os.O_WRONLY | os.O_RDWR)]</span>
    <span class="s3">if </span><span class="s1">flags &amp; os.O_APPEND:</span>
        <span class="s1">mode = mode.replace(</span><span class="s5">'w'</span><span class="s3">, </span><span class="s5">'a'</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">mode = mode.replace(</span><span class="s5">'w+'</span><span class="s3">, </span><span class="s5">'r+'</span><span class="s1">)</span>
    <span class="s0"># possible values: r, w, a, r+, a+</span>
    <span class="s3">return </span><span class="s1">mode</span>


<span class="s3">def </span><span class="s1">is_storage_device(name):</span>
    <span class="s2">&quot;&quot;&quot;Return True if the given name refers to a root device (e.g. 
    &quot;sda&quot;, &quot;nvme0n1&quot;) as opposed to a logical partition (e.g.  &quot;sda1&quot;, 
    &quot;nvme0n1p1&quot;). If name is a virtual device (e.g. &quot;loop1&quot;, &quot;ram&quot;) 
    return True. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Re-adapted from iostat source code, see:</span>
    <span class="s0"># https://github.com/sysstat/sysstat/blob/</span>
    <span class="s0">#     97912938cd476645b267280069e83b1c8dc0e1c7/common.c#L208</span>
    <span class="s0"># Some devices may have a slash in their name (e.g. cciss/c0d0...).</span>
    <span class="s1">name = name.replace(</span><span class="s5">'/'</span><span class="s3">, </span><span class="s5">'!'</span><span class="s1">)</span>
    <span class="s1">including_virtual = </span><span class="s3">True</span>
    <span class="s3">if </span><span class="s1">including_virtual:</span>
        <span class="s1">path = </span><span class="s5">&quot;/sys/block/%s&quot; </span><span class="s1">% name</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">path = </span><span class="s5">&quot;/sys/block/%s/device&quot; </span><span class="s1">% name</span>
    <span class="s3">return </span><span class="s1">os.access(path</span><span class="s3">, </span><span class="s1">os.F_OK)</span>


<span class="s1">@memoize</span>
<span class="s3">def </span><span class="s1">set_scputimes_ntuple(procfs_path):</span>
    <span class="s2">&quot;&quot;&quot;Set a namedtuple of variable fields depending on the CPU times 
    available on this Linux kernel version which may be: 
    (user, nice, system, idle, iowait, irq, softirq, [steal, [guest, 
     [guest_nice]]]) 
    Used by cpu_times() function. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">scputimes</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/stat' </span><span class="s1">% procfs_path) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">values = f.readline().split()[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s1">fields = [</span><span class="s5">'user'</span><span class="s3">, </span><span class="s5">'nice'</span><span class="s3">, </span><span class="s5">'system'</span><span class="s3">, </span><span class="s5">'idle'</span><span class="s3">, </span><span class="s5">'iowait'</span><span class="s3">, </span><span class="s5">'irq'</span><span class="s3">, </span><span class="s5">'softirq'</span><span class="s1">]</span>
    <span class="s1">vlen = len(values)</span>
    <span class="s3">if </span><span class="s1">vlen &gt;= </span><span class="s4">8</span><span class="s1">:</span>
        <span class="s0"># Linux &gt;= 2.6.11</span>
        <span class="s1">fields.append(</span><span class="s5">'steal'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">vlen &gt;= </span><span class="s4">9</span><span class="s1">:</span>
        <span class="s0"># Linux &gt;= 2.6.24</span>
        <span class="s1">fields.append(</span><span class="s5">'guest'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">vlen &gt;= </span><span class="s4">10</span><span class="s1">:</span>
        <span class="s0"># Linux &gt;= 3.2.0</span>
        <span class="s1">fields.append(</span><span class="s5">'guest_nice'</span><span class="s1">)</span>
    <span class="s1">scputimes = namedtuple(</span><span class="s5">'scputimes'</span><span class="s3">, </span><span class="s1">fields)</span>


<span class="s3">try</span><span class="s1">:</span>
    <span class="s1">set_scputimes_ntuple(</span><span class="s5">&quot;/proc&quot;</span><span class="s1">)</span>
<span class="s3">except </span><span class="s1">Exception:  </span><span class="s0"># pragma: no cover</span>
    <span class="s0"># Don't want to crash at import time.</span>
    <span class="s1">traceback.print_exc()</span>
    <span class="s1">scputimes = namedtuple(</span><span class="s5">'scputimes'</span><span class="s3">, </span><span class="s5">'user system idle'</span><span class="s1">)(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- prlimit</span>
<span class="s0"># =====================================================================</span>

<span class="s0"># Backport of resource.prlimit() for Python 2. Originally this was done</span>
<span class="s0"># in C, but CentOS-6 which we use to create manylinux wheels is too old</span>
<span class="s0"># and does not support prlimit() syscall. As such the resulting wheel</span>
<span class="s0"># would not include prlimit(), even when installed on newer systems.</span>
<span class="s0"># This is the only part of psutil using ctypes.</span>

<span class="s1">prlimit = </span><span class="s3">None</span>
<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">resource </span><span class="s3">import </span><span class="s1">prlimit  </span><span class="s0"># python &gt;= 3.4</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">import </span><span class="s1">ctypes</span>

    <span class="s1">libc = ctypes.CDLL(</span><span class="s3">None, </span><span class="s1">use_errno=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">hasattr(libc</span><span class="s3">, </span><span class="s5">&quot;prlimit&quot;</span><span class="s1">):</span>

        <span class="s3">def </span><span class="s1">prlimit(pid</span><span class="s3">, </span><span class="s1">resource_</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s3">class </span><span class="s1">StructRlimit(ctypes.Structure):</span>
                <span class="s1">_fields_ = [(</span><span class="s5">'rlim_cur'</span><span class="s3">, </span><span class="s1">ctypes.c_longlong)</span><span class="s3">,</span>
                            <span class="s1">(</span><span class="s5">'rlim_max'</span><span class="s3">, </span><span class="s1">ctypes.c_longlong)]</span>

            <span class="s1">current = StructRlimit()</span>
            <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># get</span>
                <span class="s1">ret = libc.prlimit(pid</span><span class="s3">, </span><span class="s1">resource_</span><span class="s3">, None, </span><span class="s1">ctypes.byref(current))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># set</span>
                <span class="s1">new = StructRlimit()</span>
                <span class="s1">new.rlim_cur = limits[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">new.rlim_max = limits[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">ret = libc.prlimit(</span>
                    <span class="s1">pid</span><span class="s3">, </span><span class="s1">resource_</span><span class="s3">, </span><span class="s1">ctypes.byref(new)</span><span class="s3">, </span><span class="s1">ctypes.byref(current))</span>

            <span class="s3">if </span><span class="s1">ret != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">errno = ctypes.get_errno()</span>
                <span class="s3">raise </span><span class="s1">OSError(errno</span><span class="s3">, </span><span class="s1">os.strerror(errno))</span>
            <span class="s3">return </span><span class="s1">(current.rlim_cur</span><span class="s3">, </span><span class="s1">current.rlim_max)</span>


<span class="s3">if </span><span class="s1">prlimit </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s1">__extra__all__.extend(</span>
        <span class="s1">[x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">dir(cext) </span><span class="s3">if </span><span class="s1">x.startswith(</span><span class="s5">'RLIM'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">x.isupper()])</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- system memory</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">calculate_avail_vmem(mems):</span>
    <span class="s2">&quot;&quot;&quot;Fallback for kernels &lt; 3.14 where /proc/meminfo does not provide 
    &quot;MemAvailable:&quot; column, see: 
    https://blog.famzah.net/2014/09/24/ 
    This code reimplements the algorithm outlined here: 
    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/ 
        commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773 
 
    XXX: on recent kernels this calculation differs by ~1.5% than 
    &quot;MemAvailable:&quot; as it's calculated slightly differently, see: 
    https://gitlab.com/procps-ng/procps/issues/42 
    https://github.com/famzah/linux-memavailable-procfs/issues/2 
    It is still way more realistic than doing (free + cached) though. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Fallback for very old distros. According to</span>
    <span class="s0"># https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/</span>
    <span class="s0">#     commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773</span>
    <span class="s0"># ...long ago &quot;avail&quot; was calculated as (free + cached).</span>
    <span class="s0"># We might fallback in such cases:</span>
    <span class="s0"># &quot;Active(file)&quot; not available: 2.6.28 / Dec 2008</span>
    <span class="s0"># &quot;Inactive(file)&quot; not available: 2.6.28 / Dec 2008</span>
    <span class="s0"># &quot;SReclaimable:&quot; not available: 2.6.19 / Nov 2006</span>
    <span class="s0"># /proc/zoneinfo not available: 2.6.13 / Aug 2005</span>
    <span class="s1">free = mems[</span><span class="s6">b'MemFree:'</span><span class="s1">]</span>
    <span class="s1">fallback = free + mems.get(</span><span class="s6">b&quot;Cached:&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">lru_active_file = mems[</span><span class="s6">b'Active(file):'</span><span class="s1">]</span>
        <span class="s1">lru_inactive_file = mems[</span><span class="s6">b'Inactive(file):'</span><span class="s1">]</span>
        <span class="s1">slab_reclaimable = mems[</span><span class="s6">b'SReclaimable:'</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s3">return </span><span class="s1">fallback</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">f = open_binary(</span><span class="s5">'%s/zoneinfo' </span><span class="s1">% get_procfs_path())</span>
    <span class="s3">except </span><span class="s1">IOError:</span>
        <span class="s3">return </span><span class="s1">fallback  </span><span class="s0"># kernel 2.6.13</span>

    <span class="s1">watermark_low = </span><span class="s4">0</span>
    <span class="s3">with </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s1">line = line.strip()</span>
            <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b'low'</span><span class="s1">):</span>
                <span class="s1">watermark_low += int(line.split()[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">watermark_low *= PAGESIZE</span>

    <span class="s1">avail = free - watermark_low</span>
    <span class="s1">pagecache = lru_active_file + lru_inactive_file</span>
    <span class="s1">pagecache -= min(pagecache / </span><span class="s4">2</span><span class="s3">, </span><span class="s1">watermark_low)</span>
    <span class="s1">avail += pagecache</span>
    <span class="s1">avail += slab_reclaimable - min(slab_reclaimable / </span><span class="s4">2.0</span><span class="s3">, </span><span class="s1">watermark_low)</span>
    <span class="s3">return </span><span class="s1">int(avail)</span>


<span class="s3">def </span><span class="s1">virtual_memory():</span>
    <span class="s2">&quot;&quot;&quot;Report virtual memory stats. 
    This implementation matches &quot;free&quot; and &quot;vmstat -s&quot; cmdline 
    utility values and procps-ng-3.3.12 source was used as a reference 
    (2016-09-18): 
    https://gitlab.com/procps-ng/procps/blob/ 
        24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c 
    For reference, procps-ng-3.3.10 is the version available on Ubuntu 
    16.04. 
 
    Note about &quot;available&quot; memory: up until psutil 4.3 it was 
    calculated as &quot;avail = (free + buffers + cached)&quot;. Now 
    &quot;MemAvailable:&quot; column (kernel 3.14) from /proc/meminfo is used as 
    it's more accurate. 
    That matches &quot;available&quot; column in newer versions of &quot;free&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s1">missing_fields = []</span>
    <span class="s1">mems = {}</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/meminfo' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s1">fields = line.split()</span>
            <span class="s1">mems[fields[</span><span class="s4">0</span><span class="s1">]] = int(fields[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>

    <span class="s0"># /proc doc states that the available fields in /proc/meminfo vary</span>
    <span class="s0"># by architecture and compile options, but these 3 values are also</span>
    <span class="s0"># returned by sysinfo(2); as such we assume they are always there.</span>
    <span class="s1">total = mems[</span><span class="s6">b'MemTotal:'</span><span class="s1">]</span>
    <span class="s1">free = mems[</span><span class="s6">b'MemFree:'</span><span class="s1">]</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">buffers = mems[</span><span class="s6">b'Buffers:'</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s0"># https://github.com/giampaolo/psutil/issues/1010</span>
        <span class="s1">buffers = </span><span class="s4">0</span>
        <span class="s1">missing_fields.append(</span><span class="s5">'buffers'</span><span class="s1">)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">cached = mems[</span><span class="s6">b&quot;Cached:&quot;</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">cached = </span><span class="s4">0</span>
        <span class="s1">missing_fields.append(</span><span class="s5">'cached'</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># &quot;free&quot; cmdline utility sums reclaimable to cached.</span>
        <span class="s0"># Older versions of procps used to add slab memory instead.</span>
        <span class="s0"># This got changed in:</span>
        <span class="s0"># https://gitlab.com/procps-ng/procps/commit/</span>
        <span class="s0">#     05d751c4f076a2f0118b914c5e51cfbb4762ad8e</span>
        <span class="s1">cached += mems.get(</span><span class="s6">b&quot;SReclaimable:&quot;</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)  </span><span class="s0"># since kernel 2.6.19</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">shared = mems[</span><span class="s6">b'Shmem:'</span><span class="s1">]  </span><span class="s0"># since kernel 2.6.32</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">shared = mems[</span><span class="s6">b'MemShared:'</span><span class="s1">]  </span><span class="s0"># kernels 2.4</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s1">shared = </span><span class="s4">0</span>
            <span class="s1">missing_fields.append(</span><span class="s5">'shared'</span><span class="s1">)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">active = mems[</span><span class="s6">b&quot;Active:&quot;</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">active = </span><span class="s4">0</span>
        <span class="s1">missing_fields.append(</span><span class="s5">'active'</span><span class="s1">)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">inactive = mems[</span><span class="s6">b&quot;Inactive:&quot;</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">inactive = \</span>
                <span class="s1">mems[</span><span class="s6">b&quot;Inact_dirty:&quot;</span><span class="s1">] + \</span>
                <span class="s1">mems[</span><span class="s6">b&quot;Inact_clean:&quot;</span><span class="s1">] + \</span>
                <span class="s1">mems[</span><span class="s6">b&quot;Inact_laundry:&quot;</span><span class="s1">]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s1">inactive = </span><span class="s4">0</span>
            <span class="s1">missing_fields.append(</span><span class="s5">'inactive'</span><span class="s1">)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">slab = mems[</span><span class="s6">b&quot;Slab:&quot;</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">slab = </span><span class="s4">0</span>

    <span class="s1">used = total - free - cached - buffers</span>
    <span class="s3">if </span><span class="s1">used &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0"># May be symptomatic of running within a LCX container where such</span>
        <span class="s0"># values will be dramatically distorted over those of the host.</span>
        <span class="s1">used = total - free</span>

    <span class="s0"># - starting from 4.4.0 we match free's &quot;available&quot; column.</span>
    <span class="s0">#   Before 4.4.0 we calculated it as (free + buffers + cached)</span>
    <span class="s0">#   which matched htop.</span>
    <span class="s0"># - free and htop available memory differs as per:</span>
    <span class="s0">#   http://askubuntu.com/a/369589</span>
    <span class="s0">#   http://unix.stackexchange.com/a/65852/168884</span>
    <span class="s0"># - MemAvailable has been introduced in kernel 3.14</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">avail = mems[</span><span class="s6">b'MemAvailable:'</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">avail = calculate_avail_vmem(mems)</span>

    <span class="s3">if </span><span class="s1">avail &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">avail = </span><span class="s4">0</span>
        <span class="s1">missing_fields.append(</span><span class="s5">'available'</span><span class="s1">)</span>

    <span class="s0"># If avail is greater than total or our calculation overflows,</span>
    <span class="s0"># that's symptomatic of running within a LCX container where such</span>
    <span class="s0"># values will be dramatically distorted over those of the host.</span>
    <span class="s0"># https://gitlab.com/procps-ng/procps/blob/</span>
    <span class="s0">#     24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c#L764</span>
    <span class="s3">if </span><span class="s1">avail &gt; total:</span>
        <span class="s1">avail = free</span>

    <span class="s1">percent = usage_percent((total - avail)</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0"># Warn about missing metrics which are set to 0.</span>
    <span class="s3">if </span><span class="s1">missing_fields:</span>
        <span class="s1">msg = </span><span class="s5">&quot;%s memory stats couldn't be determined and %s set to 0&quot; </span><span class="s1">% (</span>
            <span class="s5">&quot;, &quot;</span><span class="s1">.join(missing_fields)</span><span class="s3">,</span>
            <span class="s5">&quot;was&quot; </span><span class="s3">if </span><span class="s1">len(missing_fields) == </span><span class="s4">1 </span><span class="s3">else </span><span class="s5">&quot;were&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>

    <span class="s3">return </span><span class="s1">svmem(total</span><span class="s3">, </span><span class="s1">avail</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">,</span>
                 <span class="s1">active</span><span class="s3">, </span><span class="s1">inactive</span><span class="s3">, </span><span class="s1">buffers</span><span class="s3">, </span><span class="s1">cached</span><span class="s3">, </span><span class="s1">shared</span><span class="s3">, </span><span class="s1">slab)</span>


<span class="s3">def </span><span class="s1">swap_memory():</span>
    <span class="s2">&quot;&quot;&quot;Return swap memory metrics.&quot;&quot;&quot;</span>
    <span class="s1">mems = {}</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/meminfo' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s1">fields = line.split()</span>
            <span class="s1">mems[fields[</span><span class="s4">0</span><span class="s1">]] = int(fields[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>
    <span class="s0"># We prefer /proc/meminfo over sysinfo() syscall so that</span>
    <span class="s0"># psutil.PROCFS_PATH can be used in order to allow retrieval</span>
    <span class="s0"># for linux containers, see:</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/1015</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">total = mems[</span><span class="s6">b'SwapTotal:'</span><span class="s1">]</span>
        <span class="s1">free = mems[</span><span class="s6">b'SwapFree:'</span><span class="s1">]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">unit_multiplier = cext.linux_sysinfo()</span>
        <span class="s1">total *= unit_multiplier</span>
        <span class="s1">free *= unit_multiplier</span>

    <span class="s1">used = total - free</span>
    <span class="s1">percent = usage_percent(used</span><span class="s3">, </span><span class="s1">total</span><span class="s3">, </span><span class="s1">round_=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># get pgin/pgouts</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">f = open_binary(</span><span class="s5">&quot;%s/vmstat&quot; </span><span class="s1">% get_procfs_path())</span>
    <span class="s3">except </span><span class="s1">IOError </span><span class="s3">as </span><span class="s1">err:</span>
        <span class="s0"># see https://github.com/giampaolo/psutil/issues/722</span>
        <span class="s1">msg = </span><span class="s5">&quot;'sin' and 'sout' swap memory stats couldn't &quot; </span><span class="s1">\</span>
              <span class="s5">&quot;be determined and were set to 0 (%s)&quot; </span><span class="s1">% str(err)</span>
        <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">sin = sout = </span><span class="s4">0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">f:</span>
            <span class="s1">sin = sout = </span><span class="s3">None</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                <span class="s0"># values are expressed in 4 kilo bytes, we want</span>
                <span class="s0"># bytes instead</span>
                <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b'pswpin'</span><span class="s1">):</span>
                    <span class="s1">sin = int(line.split(</span><span class="s6">b' '</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">4 </span><span class="s1">* </span><span class="s4">1024</span>
                <span class="s3">elif </span><span class="s1">line.startswith(</span><span class="s6">b'pswpout'</span><span class="s1">):</span>
                    <span class="s1">sout = int(line.split(</span><span class="s6">b' '</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">4 </span><span class="s1">* </span><span class="s4">1024</span>
                <span class="s3">if </span><span class="s1">sin </span><span class="s3">is not None and </span><span class="s1">sout </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># we might get here when dealing with exotic Linux</span>
                <span class="s0"># flavors, see:</span>
                <span class="s0"># https://github.com/giampaolo/psutil/issues/313</span>
                <span class="s1">msg = </span><span class="s5">&quot;'sin' and 'sout' swap memory stats couldn't &quot; </span><span class="s1">\</span>
                      <span class="s5">&quot;be determined and were set to 0&quot;</span>
                <span class="s1">warnings.warn(msg</span><span class="s3">, </span><span class="s1">RuntimeWarning)</span>
                <span class="s1">sin = sout = </span><span class="s4">0</span>
    <span class="s3">return </span><span class="s1">_common.sswap(total</span><span class="s3">, </span><span class="s1">used</span><span class="s3">, </span><span class="s1">free</span><span class="s3">, </span><span class="s1">percent</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">sout)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- CPU</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return a named tuple representing the following system-wide 
    CPU times: 
    (user, nice, system, idle, iowait, irq, softirq [steal, [guest, 
     [guest_nice]]]) 
    Last 3 fields may not be available on all Linux kernel versions. 
    &quot;&quot;&quot;</span>
    <span class="s1">procfs_path = get_procfs_path()</span>
    <span class="s1">set_scputimes_ntuple(procfs_path)</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/stat' </span><span class="s1">% procfs_path) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">values = f.readline().split()</span>
    <span class="s1">fields = values[</span><span class="s4">1</span><span class="s1">:len(scputimes._fields) + </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">fields = [float(x) / CLOCK_TICKS </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">fields]</span>
    <span class="s3">return </span><span class="s1">scputimes(*fields)</span>


<span class="s3">def </span><span class="s1">per_cpu_times():</span>
    <span class="s2">&quot;&quot;&quot;Return a list of namedtuple representing the CPU times 
    for every CPU available on the system. 
    &quot;&quot;&quot;</span>
    <span class="s1">procfs_path = get_procfs_path()</span>
    <span class="s1">set_scputimes_ntuple(procfs_path)</span>
    <span class="s1">cpus = []</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/stat' </span><span class="s1">% procfs_path) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s0"># get rid of the first line which refers to system wide CPU stats</span>
        <span class="s1">f.readline()</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b'cpu'</span><span class="s1">):</span>
                <span class="s1">values = line.split()</span>
                <span class="s1">fields = values[</span><span class="s4">1</span><span class="s1">:len(scputimes._fields) + </span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">fields = [float(x) / CLOCK_TICKS </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">fields]</span>
                <span class="s1">entry = scputimes(*fields)</span>
                <span class="s1">cpus.append(entry)</span>
        <span class="s3">return </span><span class="s1">cpus</span>


<span class="s3">def </span><span class="s1">cpu_count_logical():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of logical CPUs in the system.&quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">os.sysconf(</span><span class="s5">&quot;SC_NPROCESSORS_ONLN&quot;</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
        <span class="s0"># as a second fallback we try to parse /proc/cpuinfo</span>
        <span class="s1">num = </span><span class="s4">0</span>
        <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/cpuinfo' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                <span class="s3">if </span><span class="s1">line.lower().startswith(</span><span class="s6">b'processor'</span><span class="s1">):</span>
                    <span class="s1">num += </span><span class="s4">1</span>

        <span class="s0"># unknown format (e.g. amrel/sparc architectures), see:</span>
        <span class="s0"># https://github.com/giampaolo/psutil/issues/200</span>
        <span class="s0"># try to parse /proc/stat as a last resort</span>
        <span class="s3">if </span><span class="s1">num == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">search = re.compile(</span><span class="s5">r'cpu\d'</span><span class="s1">)</span>
            <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">'%s/stat' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                    <span class="s1">line = line.split(</span><span class="s5">' '</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">search.match(line):</span>
                        <span class="s1">num += </span><span class="s4">1</span>

        <span class="s3">if </span><span class="s1">num == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># mimic os.cpu_count()</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s1">num</span>


<span class="s3">def </span><span class="s1">cpu_count_cores():</span>
    <span class="s2">&quot;&quot;&quot;Return the number of CPU cores in the system.&quot;&quot;&quot;</span>
    <span class="s0"># Method #1</span>
    <span class="s1">ls = set()</span>
    <span class="s0"># These 2 files are the same but */core_cpus_list is newer while</span>
    <span class="s0"># */thread_siblings_list is deprecated and may disappear in the future.</span>
    <span class="s0"># https://www.kernel.org/doc/Documentation/admin-guide/cputopology.rst</span>
    <span class="s0"># https://github.com/giampaolo/psutil/pull/1727#issuecomment-707624964</span>
    <span class="s0"># https://lkml.org/lkml/2019/2/26/41</span>
    <span class="s1">p1 = </span><span class="s5">&quot;/sys/devices/system/cpu/cpu[0-9]*/topology/core_cpus_list&quot;</span>
    <span class="s1">p2 = </span><span class="s5">&quot;/sys/devices/system/cpu/cpu[0-9]*/topology/thread_siblings_list&quot;</span>
    <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">glob.glob(p1) </span><span class="s3">or </span><span class="s1">glob.glob(p2):</span>
        <span class="s3">with </span><span class="s1">open_binary(path) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">ls.add(f.read().strip())</span>
    <span class="s1">result = len(ls)</span>
    <span class="s3">if </span><span class="s1">result != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s0"># Method #2</span>
    <span class="s1">mapping = {}</span>
    <span class="s1">current_info = {}</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/cpuinfo' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s1">line = line.strip().lower()</span>
            <span class="s3">if not </span><span class="s1">line:</span>
                <span class="s0"># new section</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">mapping[current_info[</span><span class="s6">b'physical id'</span><span class="s1">]] = \</span>
                        <span class="s1">current_info[</span><span class="s6">b'cpu cores'</span><span class="s1">]</span>
                <span class="s3">except </span><span class="s1">KeyError:</span>
                    <span class="s3">pass</span>
                <span class="s1">current_info = {}</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># ongoing section</span>
                <span class="s3">if </span><span class="s1">line.startswith((</span><span class="s6">b'physical id'</span><span class="s3">, </span><span class="s6">b'cpu cores'</span><span class="s1">)):</span>
                    <span class="s1">key</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s6">b'</span><span class="s3">\t</span><span class="s6">:'</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
                    <span class="s1">current_info[key] = int(value)</span>

    <span class="s1">result = sum(mapping.values())</span>
    <span class="s3">return </span><span class="s1">result </span><span class="s3">or None  </span><span class="s0"># mimic os.cpu_count()</span>


<span class="s3">def </span><span class="s1">cpu_stats():</span>
    <span class="s2">&quot;&quot;&quot;Return various CPU stats as a named tuple.&quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/stat' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">ctx_switches = </span><span class="s3">None</span>
        <span class="s1">interrupts = </span><span class="s3">None</span>
        <span class="s1">soft_interrupts = </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b'ctxt'</span><span class="s1">):</span>
                <span class="s1">ctx_switches = int(line.split()[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">line.startswith(</span><span class="s6">b'intr'</span><span class="s1">):</span>
                <span class="s1">interrupts = int(line.split()[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">line.startswith(</span><span class="s6">b'softirq'</span><span class="s1">):</span>
                <span class="s1">soft_interrupts = int(line.split()[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">ctx_switches </span><span class="s3">is not None and </span><span class="s1">soft_interrupts </span><span class="s3">is not None </span><span class="s1">\</span>
                    <span class="s3">and </span><span class="s1">interrupts </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">break</span>
    <span class="s1">syscalls = </span><span class="s4">0</span>
    <span class="s3">return </span><span class="s1">_common.scpustats(</span>
        <span class="s1">ctx_switches</span><span class="s3">, </span><span class="s1">interrupts</span><span class="s3">, </span><span class="s1">soft_interrupts</span><span class="s3">, </span><span class="s1">syscalls)</span>


<span class="s3">def </span><span class="s1">_cpu_get_cpuinfo_freq():</span>
    <span class="s2">&quot;&quot;&quot;Return current CPU frequency from cpuinfo if available. 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = []</span>
    <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">'%s/cpuinfo' </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s3">if </span><span class="s1">line.lower().startswith(</span><span class="s6">b'cpu mhz'</span><span class="s1">):</span>
                <span class="s1">ret.append(float(line.split(</span><span class="s6">b':'</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">if </span><span class="s1">os.path.exists(</span><span class="s5">&quot;/sys/devices/system/cpu/cpufreq/policy0&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">\</span>
        <span class="s1">os.path.exists(</span><span class="s5">&quot;/sys/devices/system/cpu/cpu0/cpufreq&quot;</span><span class="s1">):</span>
    <span class="s3">def </span><span class="s1">cpu_freq():</span>
        <span class="s2">&quot;&quot;&quot;Return frequency metrics for all CPUs. 
        Contrarily to other OSes, Linux updates these values in 
        real-time. 
        &quot;&quot;&quot;</span>
        <span class="s1">cpuinfo_freqs = _cpu_get_cpuinfo_freq()</span>
        <span class="s1">paths = \</span>
            <span class="s1">glob.glob(</span><span class="s5">&quot;/sys/devices/system/cpu/cpufreq/policy[0-9]*&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">\</span>
            <span class="s1">glob.glob(</span><span class="s5">&quot;/sys/devices/system/cpu/cpu[0-9]*/cpufreq&quot;</span><span class="s1">)</span>
        <span class="s1">paths.sort(key=</span><span class="s3">lambda </span><span class="s1">x: int(re.search(</span><span class="s5">r&quot;[0-9]+&quot;</span><span class="s3">, </span><span class="s1">x).group()))</span>
        <span class="s1">ret = []</span>
        <span class="s1">pjoin = os.path.join</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">path </span><span class="s3">in </span><span class="s1">enumerate(paths):</span>
            <span class="s3">if </span><span class="s1">len(paths) == len(cpuinfo_freqs):</span>
                <span class="s0"># take cached value from cpuinfo if available, see:</span>
                <span class="s0"># https://github.com/giampaolo/psutil/issues/1851</span>
                <span class="s1">curr = cpuinfo_freqs[i] * </span><span class="s4">1000</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">curr = bcat(pjoin(path</span><span class="s3">, </span><span class="s5">&quot;scaling_cur_freq&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">curr </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s0"># Likely an old RedHat, see:</span>
                <span class="s0"># https://github.com/giampaolo/psutil/issues/1071</span>
                <span class="s1">curr = bcat(pjoin(path</span><span class="s3">, </span><span class="s5">&quot;cpuinfo_cur_freq&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">curr </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                        <span class="s5">&quot;can't find current frequency file&quot;</span><span class="s1">)</span>
            <span class="s1">curr = int(curr) / </span><span class="s4">1000</span>
            <span class="s1">max_ = int(bcat(pjoin(path</span><span class="s3">, </span><span class="s5">&quot;scaling_max_freq&quot;</span><span class="s1">))) / </span><span class="s4">1000</span>
            <span class="s1">min_ = int(bcat(pjoin(path</span><span class="s3">, </span><span class="s5">&quot;scaling_min_freq&quot;</span><span class="s1">))) / </span><span class="s4">1000</span>
            <span class="s1">ret.append(_common.scpufreq(curr</span><span class="s3">, </span><span class="s1">min_</span><span class="s3">, </span><span class="s1">max_))</span>
        <span class="s3">return </span><span class="s1">ret</span>

<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">def </span><span class="s1">cpu_freq():</span>
        <span class="s2">&quot;&quot;&quot;Alternate implementation using /proc/cpuinfo. 
        min and max frequencies are not available and are set to None. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">[_common.scpufreq(x</span><span class="s3">, </span><span class="s4">0.</span><span class="s3">, </span><span class="s4">0.</span><span class="s1">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">_cpu_get_cpuinfo_freq()]</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- network</span>
<span class="s0"># =====================================================================</span>


<span class="s1">net_if_addrs = cext_posix.net_if_addrs</span>


<span class="s3">class </span><span class="s1">_Ipv6UnsupportedError(Exception):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">Connections:</span>
    <span class="s2">&quot;&quot;&quot;A wrapper on top of /proc/net/* files, retrieving per-process 
    and system-wide open connections (TCP, UDP, UNIX) similarly to 
    &quot;netstat -an&quot;. 
 
    Note: in case of UNIX sockets we're only able to determine the 
    local endpoint/path, not the one it's connected to. 
    According to [1] it would be possible but not easily. 
 
    [1] http://serverfault.com/a/417946 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s0"># The string represents the basename of the corresponding</span>
        <span class="s0"># /proc/net/{proto_name} file.</span>
        <span class="s1">tcp4 = (</span><span class="s5">&quot;tcp&quot;</span><span class="s3">, </span><span class="s1">socket.AF_INET</span><span class="s3">, </span><span class="s1">socket.SOCK_STREAM)</span>
        <span class="s1">tcp6 = (</span><span class="s5">&quot;tcp6&quot;</span><span class="s3">, </span><span class="s1">socket.AF_INET6</span><span class="s3">, </span><span class="s1">socket.SOCK_STREAM)</span>
        <span class="s1">udp4 = (</span><span class="s5">&quot;udp&quot;</span><span class="s3">, </span><span class="s1">socket.AF_INET</span><span class="s3">, </span><span class="s1">socket.SOCK_DGRAM)</span>
        <span class="s1">udp6 = (</span><span class="s5">&quot;udp6&quot;</span><span class="s3">, </span><span class="s1">socket.AF_INET6</span><span class="s3">, </span><span class="s1">socket.SOCK_DGRAM)</span>
        <span class="s1">unix = (</span><span class="s5">&quot;unix&quot;</span><span class="s3">, </span><span class="s1">socket.AF_UNIX</span><span class="s3">, None</span><span class="s1">)</span>
        <span class="s1">self.tmap = {</span>
            <span class="s5">&quot;all&quot;</span><span class="s1">: (tcp4</span><span class="s3">, </span><span class="s1">tcp6</span><span class="s3">, </span><span class="s1">udp4</span><span class="s3">, </span><span class="s1">udp6</span><span class="s3">, </span><span class="s1">unix)</span><span class="s3">,</span>
            <span class="s5">&quot;tcp&quot;</span><span class="s1">: (tcp4</span><span class="s3">, </span><span class="s1">tcp6)</span><span class="s3">,</span>
            <span class="s5">&quot;tcp4&quot;</span><span class="s1">: (tcp4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;tcp6&quot;</span><span class="s1">: (tcp6</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;udp&quot;</span><span class="s1">: (udp4</span><span class="s3">, </span><span class="s1">udp6)</span><span class="s3">,</span>
            <span class="s5">&quot;udp4&quot;</span><span class="s1">: (udp4</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;udp6&quot;</span><span class="s1">: (udp6</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;unix&quot;</span><span class="s1">: (unix</span><span class="s3">,</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s5">&quot;inet&quot;</span><span class="s1">: (tcp4</span><span class="s3">, </span><span class="s1">tcp6</span><span class="s3">, </span><span class="s1">udp4</span><span class="s3">, </span><span class="s1">udp6)</span><span class="s3">,</span>
            <span class="s5">&quot;inet4&quot;</span><span class="s1">: (tcp4</span><span class="s3">, </span><span class="s1">udp4)</span><span class="s3">,</span>
            <span class="s5">&quot;inet6&quot;</span><span class="s1">: (tcp6</span><span class="s3">, </span><span class="s1">udp6)</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s1">self._procfs_path = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">get_proc_inodes(self</span><span class="s3">, </span><span class="s1">pid):</span>
        <span class="s1">inodes = defaultdict(list)</span>
        <span class="s3">for </span><span class="s1">fd </span><span class="s3">in </span><span class="s1">os.listdir(</span><span class="s5">&quot;%s/%s/fd&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">pid)):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">inode = readlink(</span><span class="s5">&quot;%s/%s/fd/%s&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">pid</span><span class="s3">, </span><span class="s1">fd))</span>
            <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
                <span class="s0"># ENOENT == file which is gone in the meantime;</span>
                <span class="s0"># os.stat('/proc/%s' % self.pid) will be done later</span>
                <span class="s0"># to force NSP (if it's the case)</span>
                <span class="s3">continue</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">err.errno == errno.EINVAL:</span>
                    <span class="s0"># not a link</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">err.errno == errno.ENAMETOOLONG:</span>
                    <span class="s0"># file name too long</span>
                    <span class="s1">debug(err)</span>
                    <span class="s3">continue</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">inode.startswith(</span><span class="s5">'socket:['</span><span class="s1">):</span>
                    <span class="s0"># the process is using a socket</span>
                    <span class="s1">inode = inode[</span><span class="s4">8</span><span class="s1">:][:-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">inodes[inode].append((pid</span><span class="s3">, </span><span class="s1">int(fd)))</span>
        <span class="s3">return </span><span class="s1">inodes</span>

    <span class="s3">def </span><span class="s1">get_all_inodes(self):</span>
        <span class="s1">inodes = {}</span>
        <span class="s3">for </span><span class="s1">pid </span><span class="s3">in </span><span class="s1">pids():</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">inodes.update(self.get_proc_inodes(pid))</span>
            <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError</span><span class="s3">, </span><span class="s1">PermissionError):</span>
                <span class="s0"># os.listdir() is gonna raise a lot of access denied</span>
                <span class="s0"># exceptions in case of unprivileged user; that's fine</span>
                <span class="s0"># as we'll just end up returning a connection with PID</span>
                <span class="s0"># and fd set to None anyway.</span>
                <span class="s0"># Both netstat -an and lsof does the same so it's</span>
                <span class="s0"># unlikely we can do any better.</span>
                <span class="s0"># ENOENT just means a PID disappeared on us.</span>
                <span class="s3">continue</span>
        <span class="s3">return </span><span class="s1">inodes</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">decode_address(addr</span><span class="s3">, </span><span class="s1">family):</span>
        <span class="s2">&quot;&quot;&quot;Accept an &quot;ip:port&quot; address as displayed in /proc/net/* 
        and convert it into a human readable form, like: 
 
        &quot;0500000A:0016&quot; -&gt; (&quot;10.0.0.5&quot;, 22) 
        &quot;0000000000000000FFFF00000100007F:9E49&quot; -&gt; (&quot;::ffff:127.0.0.1&quot;, 40521) 
 
        The IP address portion is a little or big endian four-byte 
        hexadecimal number; that is, the least significant byte is listed 
        first, so we need to reverse the order of the bytes to convert it 
        to an IP address. 
        The port is represented as a two-byte hexadecimal number. 
 
        Reference: 
        http://linuxdevcenter.com/pub/a/linux/2000/11/16/LinuxAdmin.html 
        &quot;&quot;&quot;</span>
        <span class="s1">ip</span><span class="s3">, </span><span class="s1">port = addr.split(</span><span class="s5">':'</span><span class="s1">)</span>
        <span class="s1">port = int(port</span><span class="s3">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s0"># this usually refers to a local socket in listen mode with</span>
        <span class="s0"># no end-points connected</span>
        <span class="s3">if not </span><span class="s1">port:</span>
            <span class="s3">return </span><span class="s1">()</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">ip = ip.encode(</span><span class="s5">'ascii'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">family == socket.AF_INET:</span>
            <span class="s0"># see: https://github.com/giampaolo/psutil/issues/201</span>
            <span class="s3">if </span><span class="s1">LITTLE_ENDIAN:</span>
                <span class="s1">ip = socket.inet_ntop(family</span><span class="s3">, </span><span class="s1">base64.b16decode(ip)[::-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ip = socket.inet_ntop(family</span><span class="s3">, </span><span class="s1">base64.b16decode(ip))</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s0"># IPv6</span>
            <span class="s1">ip = base64.b16decode(ip)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s0"># see: https://github.com/giampaolo/psutil/issues/201</span>
                <span class="s3">if </span><span class="s1">LITTLE_ENDIAN:</span>
                    <span class="s1">ip = socket.inet_ntop(</span>
                        <span class="s1">socket.AF_INET6</span><span class="s3">,</span>
                        <span class="s1">struct.pack(</span><span class="s5">'&gt;4I'</span><span class="s3">, </span><span class="s1">*struct.unpack(</span><span class="s5">'&lt;4I'</span><span class="s3">, </span><span class="s1">ip)))</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">ip = socket.inet_ntop(</span>
                        <span class="s1">socket.AF_INET6</span><span class="s3">,</span>
                        <span class="s1">struct.pack(</span><span class="s5">'&lt;4I'</span><span class="s3">, </span><span class="s1">*struct.unpack(</span><span class="s5">'&lt;4I'</span><span class="s3">, </span><span class="s1">ip)))</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s0"># see: https://github.com/giampaolo/psutil/issues/623</span>
                <span class="s3">if not </span><span class="s1">supports_ipv6():</span>
                    <span class="s3">raise </span><span class="s1">_Ipv6UnsupportedError</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>
        <span class="s3">return </span><span class="s1">_common.addr(ip</span><span class="s3">, </span><span class="s1">port)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">process_inet(file</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">inodes</span><span class="s3">, </span><span class="s1">filter_pid=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse /proc/net/tcp* and /proc/net/udp* files.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">file.endswith(</span><span class="s5">'6'</span><span class="s1">) </span><span class="s3">and not </span><span class="s1">os.path.exists(file):</span>
            <span class="s0"># IPv6 not supported</span>
            <span class="s3">return</span>
        <span class="s3">with </span><span class="s1">open_text(file) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.readline()  </span><span class="s0"># skip the first line</span>
            <span class="s3">for </span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">line </span><span class="s3">in </span><span class="s1">enumerate(f</span><span class="s3">, </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">inode = \</span>
                        <span class="s1">line.split()[:</span><span class="s4">10</span><span class="s1">]</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s3">raise </span><span class="s1">RuntimeError(</span>
                        <span class="s5">&quot;error while parsing %s; malformed line %s %r&quot; </span><span class="s1">% (</span>
                            <span class="s1">file</span><span class="s3">, </span><span class="s1">lineno</span><span class="s3">, </span><span class="s1">line))</span>
                <span class="s3">if </span><span class="s1">inode </span><span class="s3">in </span><span class="s1">inodes:</span>
                    <span class="s0"># # We assume inet sockets are unique, so we error</span>
                    <span class="s0"># # out if there are multiple references to the</span>
                    <span class="s0"># # same inode. We won't do this for UNIX sockets.</span>
                    <span class="s0"># if len(inodes[inode]) &gt; 1 and family != socket.AF_UNIX:</span>
                    <span class="s0">#     raise ValueError(&quot;ambiguous inode with multiple &quot;</span>
                    <span class="s0">#                      &quot;PIDs references&quot;)</span>
                    <span class="s1">pid</span><span class="s3">, </span><span class="s1">fd = inodes[inode][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">pid</span><span class="s3">, </span><span class="s1">fd = </span><span class="s3">None, </span><span class="s1">-</span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">filter_pid </span><span class="s3">is not None and </span><span class="s1">filter_pid != pid:</span>
                    <span class="s3">continue</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">type_ == socket.SOCK_STREAM:</span>
                        <span class="s1">status = TCP_STATUSES[status]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">status = _common.CONN_NONE</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">laddr = Connections.decode_address(laddr</span><span class="s3">, </span><span class="s1">family)</span>
                        <span class="s1">raddr = Connections.decode_address(raddr</span><span class="s3">, </span><span class="s1">family)</span>
                    <span class="s3">except </span><span class="s1">_Ipv6UnsupportedError:</span>
                        <span class="s3">continue</span>
                    <span class="s3">yield </span><span class="s1">(fd</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">pid)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">process_unix(file</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">inodes</span><span class="s3">, </span><span class="s1">filter_pid=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot;Parse /proc/net/unix files.&quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">open_text(file) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">f.readline()  </span><span class="s0"># skip the first line</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                <span class="s1">tokens = line.split()</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">inode = tokens[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">7</span><span class="s1">]</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s3">if </span><span class="s5">' ' </span><span class="s3">not in </span><span class="s1">line:</span>
                        <span class="s0"># see: https://github.com/giampaolo/psutil/issues/766</span>
                        <span class="s3">continue</span>
                    <span class="s3">raise </span><span class="s1">RuntimeError(</span>
                        <span class="s5">&quot;error while parsing %s; malformed line %r&quot; </span><span class="s1">% (</span>
                            <span class="s1">file</span><span class="s3">, </span><span class="s1">line))</span>
                <span class="s3">if </span><span class="s1">inode </span><span class="s3">in </span><span class="s1">inodes:</span>
                    <span class="s0"># With UNIX sockets we can have a single inode</span>
                    <span class="s0"># referencing many file descriptors.</span>
                    <span class="s1">pairs = inodes[inode]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">pairs = [(</span><span class="s3">None, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)]</span>
                <span class="s3">for </span><span class="s1">pid</span><span class="s3">, </span><span class="s1">fd </span><span class="s3">in </span><span class="s1">pairs:</span>
                    <span class="s3">if </span><span class="s1">filter_pid </span><span class="s3">is not None and </span><span class="s1">filter_pid != pid:</span>
                        <span class="s3">continue</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">if </span><span class="s1">len(tokens) == </span><span class="s4">8</span><span class="s1">:</span>
                            <span class="s1">path = tokens[-</span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">path = </span><span class="s5">&quot;&quot;</span>
                        <span class="s1">type_ = _common.socktype_to_enum(int(type_))</span>
                        <span class="s0"># XXX: determining the remote endpoint of a</span>
                        <span class="s0"># UNIX socket on Linux is not possible, see:</span>
                        <span class="s0"># https://serverfault.com/questions/252723/</span>
                        <span class="s1">raddr = </span><span class="s5">&quot;&quot;</span>
                        <span class="s1">status = _common.CONN_NONE</span>
                        <span class="s3">yield </span><span class="s1">(fd</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">pid)</span>

    <span class="s3">def </span><span class="s1">retrieve(self</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">pid=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">kind </span><span class="s3">not in </span><span class="s1">self.tmap:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;invalid %r kind argument; choose between %s&quot;</span>
                             <span class="s1">% (kind</span><span class="s3">, </span><span class="s5">', '</span><span class="s1">.join([repr(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self.tmap])))</span>
        <span class="s1">self._procfs_path = get_procfs_path()</span>
        <span class="s3">if </span><span class="s1">pid </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">inodes = self.get_proc_inodes(pid)</span>
            <span class="s3">if not </span><span class="s1">inodes:</span>
                <span class="s0"># no connections for this process</span>
                <span class="s3">return </span><span class="s1">[]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">inodes = self.get_all_inodes()</span>
        <span class="s1">ret = set()</span>
        <span class="s3">for </span><span class="s1">proto_name</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">self.tmap[kind]:</span>
            <span class="s1">path = </span><span class="s5">&quot;%s/net/%s&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">proto_name)</span>
            <span class="s3">if </span><span class="s1">family </span><span class="s3">in </span><span class="s1">(socket.AF_INET</span><span class="s3">, </span><span class="s1">socket.AF_INET6):</span>
                <span class="s1">ls = self.process_inet(</span>
                    <span class="s1">path</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">inodes</span><span class="s3">, </span><span class="s1">filter_pid=pid)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">ls = self.process_unix(</span>
                    <span class="s1">path</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">inodes</span><span class="s3">, </span><span class="s1">filter_pid=pid)</span>
            <span class="s3">for </span><span class="s1">fd</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">bound_pid </span><span class="s3">in </span><span class="s1">ls:</span>
                <span class="s3">if </span><span class="s1">pid:</span>
                    <span class="s1">conn = _common.pconn(fd</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">,</span>
                                         <span class="s1">status)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">conn = _common.sconn(fd</span><span class="s3">, </span><span class="s1">family</span><span class="s3">, </span><span class="s1">type_</span><span class="s3">, </span><span class="s1">laddr</span><span class="s3">, </span><span class="s1">raddr</span><span class="s3">,</span>
                                         <span class="s1">status</span><span class="s3">, </span><span class="s1">bound_pid)</span>
                <span class="s1">ret.add(conn)</span>
        <span class="s3">return </span><span class="s1">list(ret)</span>


<span class="s1">_connections = Connections()</span>


<span class="s3">def </span><span class="s1">net_connections(kind=</span><span class="s5">'inet'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return system-wide open connections.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_connections.retrieve(kind)</span>


<span class="s3">def </span><span class="s1">net_io_counters():</span>
    <span class="s2">&quot;&quot;&quot;Return network I/O statistics for every network interface 
    installed on the system as a dict of raw tuples. 
    &quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/net/dev&quot; </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">lines = f.readlines()</span>
    <span class="s1">retdict = {}</span>
    <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines[</span><span class="s4">2</span><span class="s1">:]:</span>
        <span class="s1">colon = line.rfind(</span><span class="s5">':'</span><span class="s1">)</span>
        <span class="s3">assert </span><span class="s1">colon &gt; </span><span class="s4">0</span><span class="s3">, </span><span class="s1">repr(line)</span>
        <span class="s1">name = line[:colon].strip()</span>
        <span class="s1">fields = line[colon + </span><span class="s4">1</span><span class="s1">:].strip().split()</span>

        <span class="s0"># in</span>
        <span class="s1">(bytes_recv</span><span class="s3">,</span>
         <span class="s1">packets_recv</span><span class="s3">,</span>
         <span class="s1">errin</span><span class="s3">,</span>
         <span class="s1">dropin</span><span class="s3">,</span>
         <span class="s1">fifoin</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">framein</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">compressedin</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">multicastin</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s0"># out</span>
         <span class="s1">bytes_sent</span><span class="s3">,</span>
         <span class="s1">packets_sent</span><span class="s3">,</span>
         <span class="s1">errout</span><span class="s3">,</span>
         <span class="s1">dropout</span><span class="s3">,</span>
         <span class="s1">fifoout</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">collisionsout</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">carrierout</span><span class="s3">,  </span><span class="s0"># unused</span>
         <span class="s1">compressedout) = map(int</span><span class="s3">, </span><span class="s1">fields)</span>

        <span class="s1">retdict[name] = (bytes_sent</span><span class="s3">, </span><span class="s1">bytes_recv</span><span class="s3">, </span><span class="s1">packets_sent</span><span class="s3">, </span><span class="s1">packets_recv</span><span class="s3">,</span>
                         <span class="s1">errin</span><span class="s3">, </span><span class="s1">errout</span><span class="s3">, </span><span class="s1">dropin</span><span class="s3">, </span><span class="s1">dropout)</span>
    <span class="s3">return </span><span class="s1">retdict</span>


<span class="s3">def </span><span class="s1">net_if_stats():</span>
    <span class="s2">&quot;&quot;&quot;Get NIC stats (isup, duplex, speed, mtu).&quot;&quot;&quot;</span>
    <span class="s1">duplex_map = {cext.DUPLEX_FULL: NIC_DUPLEX_FULL</span><span class="s3">,</span>
                  <span class="s1">cext.DUPLEX_HALF: NIC_DUPLEX_HALF</span><span class="s3">,</span>
                  <span class="s1">cext.DUPLEX_UNKNOWN: NIC_DUPLEX_UNKNOWN}</span>
    <span class="s1">names = net_io_counters().keys()</span>
    <span class="s1">ret = {}</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">mtu = cext_posix.net_if_mtu(name)</span>
            <span class="s1">flags = cext_posix.net_if_flags(name)</span>
            <span class="s1">duplex</span><span class="s3">, </span><span class="s1">speed = cext.net_if_duplex_speed(name)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1279</span>
            <span class="s3">if </span><span class="s1">err.errno != errno.ENODEV:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">debug(err)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">output_flags = </span><span class="s5">','</span><span class="s1">.join(flags)</span>
            <span class="s1">isup = </span><span class="s5">'running' </span><span class="s3">in </span><span class="s1">flags</span>
            <span class="s1">ret[name] = _common.snicstats(isup</span><span class="s3">, </span><span class="s1">duplex_map[duplex]</span><span class="s3">, </span><span class="s1">speed</span><span class="s3">, </span><span class="s1">mtu</span><span class="s3">,</span>
                                          <span class="s1">output_flags)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- disks</span>
<span class="s0"># =====================================================================</span>


<span class="s1">disk_usage = _psposix.disk_usage</span>


<span class="s3">def </span><span class="s1">disk_io_counters(perdisk=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return disk I/O statistics for every disk installed on the 
    system as a dict of raw tuples. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">read_procfs():</span>
        <span class="s0"># OK, this is a bit confusing. The format of /proc/diskstats can</span>
        <span class="s0"># have 3 variations.</span>
        <span class="s0"># On Linux 2.4 each line has always 15 fields, e.g.:</span>
        <span class="s0"># &quot;3     0   8 hda 8 8 8 8 8 8 8 8 8 8 8&quot;</span>
        <span class="s0"># On Linux 2.6+ each line *usually* has 14 fields, and the disk</span>
        <span class="s0"># name is in another position, like this:</span>
        <span class="s0"># &quot;3    0   hda 8 8 8 8 8 8 8 8 8 8 8&quot;</span>
        <span class="s0"># ...unless (Linux 2.6) the line refers to a partition instead</span>
        <span class="s0"># of a disk, in which case the line has less fields (7):</span>
        <span class="s0"># &quot;3    1   hda1 8 8 8 8&quot;</span>
        <span class="s0"># 4.18+ has 4 fields added:</span>
        <span class="s0"># &quot;3    0   hda 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0&quot;</span>
        <span class="s0"># 5.5 has 2 more fields.</span>
        <span class="s0"># See:</span>
        <span class="s0"># https://www.kernel.org/doc/Documentation/iostats.txt</span>
        <span class="s0"># https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats</span>
        <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/diskstats&quot; </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">lines = f.readlines()</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines:</span>
            <span class="s1">fields = line.split()</span>
            <span class="s1">flen = len(fields)</span>
            <span class="s3">if </span><span class="s1">flen == </span><span class="s4">15</span><span class="s1">:</span>
                <span class="s0"># Linux 2.4</span>
                <span class="s1">name = fields[</span><span class="s4">3</span><span class="s1">]</span>
                <span class="s1">reads = int(fields[</span><span class="s4">2</span><span class="s1">])</span>
                <span class="s1">(reads_merged</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">,</span>
                    <span class="s1">wbytes</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">busy_time</span><span class="s3">, </span><span class="s1">_) = map(int</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">14</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">flen == </span><span class="s4">14 </span><span class="s3">or </span><span class="s1">flen &gt;= </span><span class="s4">18</span><span class="s1">:</span>
                <span class="s0"># Linux 2.6+, line referring to a disk</span>
                <span class="s1">name = fields[</span><span class="s4">2</span><span class="s1">]</span>
                <span class="s1">(reads</span><span class="s3">, </span><span class="s1">reads_merged</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">,</span>
                    <span class="s1">wbytes</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">busy_time</span><span class="s3">, </span><span class="s1">_) = map(int</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">3</span><span class="s1">:</span><span class="s4">14</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">flen == </span><span class="s4">7</span><span class="s1">:</span>
                <span class="s0"># Linux 2.6+, line referring to a partition</span>
                <span class="s1">name = fields[</span><span class="s4">2</span><span class="s1">]</span>
                <span class="s1">reads</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">wbytes = map(int</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">3</span><span class="s1">:])</span>
                <span class="s1">rtime = wtime = reads_merged = writes_merged = busy_time = </span><span class="s4">0</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;not sure how to interpret line %r&quot; </span><span class="s1">% line)</span>
            <span class="s3">yield </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">reads</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">wbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">,</span>
                   <span class="s1">reads_merged</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">, </span><span class="s1">busy_time)</span>

    <span class="s3">def </span><span class="s1">read_sysfs():</span>
        <span class="s3">for </span><span class="s1">block </span><span class="s3">in </span><span class="s1">os.listdir(</span><span class="s5">'/sys/block'</span><span class="s1">):</span>
            <span class="s3">for </span><span class="s1">root</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">files </span><span class="s3">in </span><span class="s1">os.walk(os.path.join(</span><span class="s5">'/sys/block'</span><span class="s3">, </span><span class="s1">block)):</span>
                <span class="s3">if </span><span class="s5">'stat' </span><span class="s3">not in </span><span class="s1">files:</span>
                    <span class="s3">continue</span>
                <span class="s3">with </span><span class="s1">open_text(os.path.join(root</span><span class="s3">, </span><span class="s5">'stat'</span><span class="s1">)) </span><span class="s3">as </span><span class="s1">f:</span>
                    <span class="s1">fields = f.read().strip().split()</span>
                <span class="s1">name = os.path.basename(root)</span>
                <span class="s1">(reads</span><span class="s3">, </span><span class="s1">reads_merged</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">,</span>
                    <span class="s1">wbytes</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">busy_time) = map(int</span><span class="s3">, </span><span class="s1">fields[:</span><span class="s4">10</span><span class="s1">])</span>
                <span class="s3">yield </span><span class="s1">(name</span><span class="s3">, </span><span class="s1">reads</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">wbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">,</span>
                       <span class="s1">wtime</span><span class="s3">, </span><span class="s1">reads_merged</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">, </span><span class="s1">busy_time)</span>

    <span class="s3">if </span><span class="s1">os.path.exists(</span><span class="s5">'%s/diskstats' </span><span class="s1">% get_procfs_path()):</span>
        <span class="s1">gen = read_procfs()</span>
    <span class="s3">elif </span><span class="s1">os.path.exists(</span><span class="s5">'/sys/block'</span><span class="s1">):</span>
        <span class="s1">gen = read_sysfs()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s5">&quot;%s/diskstats nor /sys/block filesystem are available on this &quot;</span>
            <span class="s5">&quot;system&quot; </span><span class="s1">% get_procfs_path())</span>

    <span class="s1">retdict = {}</span>
    <span class="s3">for </span><span class="s1">entry </span><span class="s3">in </span><span class="s1">gen:</span>
        <span class="s1">(name</span><span class="s3">, </span><span class="s1">reads</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">wbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">, </span><span class="s1">reads_merged</span><span class="s3">,</span>
            <span class="s1">writes_merged</span><span class="s3">, </span><span class="s1">busy_time) = entry</span>
        <span class="s3">if not </span><span class="s1">perdisk </span><span class="s3">and not </span><span class="s1">is_storage_device(name):</span>
            <span class="s0"># perdisk=False means we want to calculate totals so we skip</span>
            <span class="s0"># partitions (e.g. 'sda1', 'nvme0n1p1') and only include</span>
            <span class="s0"># base disk devices (e.g. 'sda', 'nvme0n1'). Base disks</span>
            <span class="s0"># include a total of all their partitions + some extra size</span>
            <span class="s0"># of their own:</span>
            <span class="s0">#     $ cat /proc/diskstats</span>
            <span class="s0">#     259       0 sda 10485760 ...</span>
            <span class="s0">#     259       1 sda1 5186039 ...</span>
            <span class="s0">#     259       1 sda2 5082039 ...</span>
            <span class="s0"># See:</span>
            <span class="s0"># https://github.com/giampaolo/psutil/pull/1313</span>
            <span class="s3">continue</span>

        <span class="s1">rbytes *= DISK_SECTOR_SIZE</span>
        <span class="s1">wbytes *= DISK_SECTOR_SIZE</span>
        <span class="s1">retdict[name] = (reads</span><span class="s3">, </span><span class="s1">writes</span><span class="s3">, </span><span class="s1">rbytes</span><span class="s3">, </span><span class="s1">wbytes</span><span class="s3">, </span><span class="s1">rtime</span><span class="s3">, </span><span class="s1">wtime</span><span class="s3">,</span>
                         <span class="s1">reads_merged</span><span class="s3">, </span><span class="s1">writes_merged</span><span class="s3">, </span><span class="s1">busy_time)</span>

    <span class="s3">return </span><span class="s1">retdict</span>


<span class="s3">class </span><span class="s1">RootFsDeviceFinder:</span>
    <span class="s2">&quot;&quot;&quot;disk_partitions() may return partitions with device == &quot;/dev/root&quot; 
    or &quot;rootfs&quot;. This container class uses different strategies to try to 
    obtain the real device path. Resources: 
    https://bootlin.com/blog/find-root-device/ 
    https://www.systutorials.com/how-to-find-the-disk-where-root-is-on-in-bash-on-linux/ 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = [</span><span class="s5">'major'</span><span class="s3">, </span><span class="s5">'minor'</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">dev = os.stat(</span><span class="s5">&quot;/&quot;</span><span class="s1">).st_dev</span>
        <span class="s1">self.major = os.major(dev)</span>
        <span class="s1">self.minor = os.minor(dev)</span>

    <span class="s3">def </span><span class="s1">ask_proc_partitions(self):</span>
        <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/partitions&quot; </span><span class="s1">% get_procfs_path()) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f.readlines()[</span><span class="s4">2</span><span class="s1">:]:</span>
                <span class="s1">fields = line.split()</span>
                <span class="s3">if </span><span class="s1">len(fields) &lt; </span><span class="s4">4</span><span class="s1">:  </span><span class="s0"># just for extra safety</span>
                    <span class="s3">continue</span>
                <span class="s1">major = int(fields[</span><span class="s4">0</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">].isdigit() </span><span class="s3">else None</span>
                <span class="s1">minor = int(fields[</span><span class="s4">1</span><span class="s1">]) </span><span class="s3">if </span><span class="s1">fields[</span><span class="s4">1</span><span class="s1">].isdigit() </span><span class="s3">else None</span>
                <span class="s1">name = fields[</span><span class="s4">3</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">major == self.major </span><span class="s3">and </span><span class="s1">minor == self.minor:</span>
                    <span class="s3">if </span><span class="s1">name:  </span><span class="s0"># just for extra safety</span>
                        <span class="s3">return </span><span class="s5">&quot;/dev/%s&quot; </span><span class="s1">% name</span>

    <span class="s3">def </span><span class="s1">ask_sys_dev_block(self):</span>
        <span class="s1">path = </span><span class="s5">&quot;/sys/dev/block/%s:%s/uevent&quot; </span><span class="s1">% (self.major</span><span class="s3">, </span><span class="s1">self.minor)</span>
        <span class="s3">with </span><span class="s1">open_text(path) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s5">&quot;DEVNAME=&quot;</span><span class="s1">):</span>
                    <span class="s1">name = line.strip().rpartition(</span><span class="s5">&quot;DEVNAME=&quot;</span><span class="s1">)[</span><span class="s4">2</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">name:  </span><span class="s0"># just for extra safety</span>
                        <span class="s3">return </span><span class="s5">&quot;/dev/%s&quot; </span><span class="s1">% name</span>

    <span class="s3">def </span><span class="s1">ask_sys_class_block(self):</span>
        <span class="s1">needle = </span><span class="s5">&quot;%s:%s&quot; </span><span class="s1">% (self.major</span><span class="s3">, </span><span class="s1">self.minor)</span>
        <span class="s1">files = glob.iglob(</span><span class="s5">&quot;/sys/class/block/*/dev&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">file </span><span class="s3">in </span><span class="s1">files:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">f = open_text(file)</span>
            <span class="s3">except </span><span class="s1">FileNotFoundError:  </span><span class="s0"># race condition</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">with </span><span class="s1">f:</span>
                    <span class="s1">data = f.read().strip()</span>
                    <span class="s3">if </span><span class="s1">data == needle:</span>
                        <span class="s1">name = os.path.basename(os.path.dirname(file))</span>
                        <span class="s3">return </span><span class="s5">&quot;/dev/%s&quot; </span><span class="s1">% name</span>

    <span class="s3">def </span><span class="s1">find(self):</span>
        <span class="s1">path = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">path = self.ask_proc_partitions()</span>
            <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError) </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s1">debug(err)</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">path = self.ask_sys_dev_block()</span>
            <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError) </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s1">debug(err)</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">path = self.ask_sys_class_block()</span>
            <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError) </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s1">debug(err)</span>
        <span class="s0"># We use exists() because the &quot;/dev/*&quot; part of the path is hard</span>
        <span class="s0"># coded, so we want to be sure.</span>
        <span class="s3">if </span><span class="s1">path </span><span class="s3">is not None and </span><span class="s1">os.path.exists(path):</span>
            <span class="s3">return </span><span class="s1">path</span>


<span class="s3">def </span><span class="s1">disk_partitions(all=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Return mounted disk partitions as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">fstypes = set()</span>
    <span class="s1">procfs_path = get_procfs_path()</span>
    <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/filesystems&quot; </span><span class="s1">% procfs_path) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s1">line = line.strip()</span>
            <span class="s3">if not </span><span class="s1">line.startswith(</span><span class="s5">&quot;nodev&quot;</span><span class="s1">):</span>
                <span class="s1">fstypes.add(line.strip())</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># ignore all lines starting with &quot;nodev&quot; except &quot;nodev zfs&quot;</span>
                <span class="s1">fstype = line.split(</span><span class="s5">&quot;</span><span class="s3">\t</span><span class="s5">&quot;</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s3">if </span><span class="s1">fstype == </span><span class="s5">&quot;zfs&quot;</span><span class="s1">:</span>
                    <span class="s1">fstypes.add(</span><span class="s5">&quot;zfs&quot;</span><span class="s1">)</span>

    <span class="s0"># See: https://github.com/giampaolo/psutil/issues/1307</span>
    <span class="s3">if </span><span class="s1">procfs_path == </span><span class="s5">&quot;/proc&quot; </span><span class="s3">and </span><span class="s1">os.path.isfile(</span><span class="s5">'/etc/mtab'</span><span class="s1">):</span>
        <span class="s1">mounts_path = os.path.realpath(</span><span class="s5">&quot;/etc/mtab&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">mounts_path = os.path.realpath(</span><span class="s5">&quot;%s/self/mounts&quot; </span><span class="s1">% procfs_path)</span>

    <span class="s1">retlist = []</span>
    <span class="s1">partitions = cext.disk_partitions(mounts_path)</span>
    <span class="s3">for </span><span class="s1">partition </span><span class="s3">in </span><span class="s1">partitions:</span>
        <span class="s1">device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts = partition</span>
        <span class="s3">if </span><span class="s1">device == </span><span class="s5">'none'</span><span class="s1">:</span>
            <span class="s1">device = </span><span class="s5">''</span>
        <span class="s3">if </span><span class="s1">device </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;/dev/root&quot;</span><span class="s3">, </span><span class="s5">&quot;rootfs&quot;</span><span class="s1">):</span>
            <span class="s1">device = RootFsDeviceFinder().find() </span><span class="s3">or </span><span class="s1">device</span>
        <span class="s3">if not </span><span class="s1">all:</span>
            <span class="s3">if </span><span class="s1">device == </span><span class="s5">'' </span><span class="s3">or </span><span class="s1">fstype </span><span class="s3">not in </span><span class="s1">fstypes:</span>
                <span class="s3">continue</span>
        <span class="s1">maxfile = maxpath = </span><span class="s3">None  </span><span class="s0"># set later</span>
        <span class="s1">ntuple = _common.sdiskpart(device</span><span class="s3">, </span><span class="s1">mountpoint</span><span class="s3">, </span><span class="s1">fstype</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">,</span>
                                   <span class="s1">maxfile</span><span class="s3">, </span><span class="s1">maxpath)</span>
        <span class="s1">retlist.append(ntuple)</span>

    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- sensors</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">sensors_temperatures():</span>
    <span class="s2">&quot;&quot;&quot;Return hardware (CPU and others) temperatures as a dict 
    including hardware name, label, current, max and critical 
    temperatures. 
 
    Implementation notes: 
    - /sys/class/hwmon looks like the most recent interface to 
      retrieve this info, and this implementation relies on it 
      only (old distros will probably use something else) 
    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon 
    - /sys/class/thermal/thermal_zone* is another one but it's more 
      difficult to parse 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = collections.defaultdict(list)</span>
    <span class="s1">basenames = glob.glob(</span><span class="s5">'/sys/class/hwmon/hwmon*/temp*_*'</span><span class="s1">)</span>
    <span class="s0"># CentOS has an intermediate /device directory:</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/971</span>
    <span class="s0"># https://github.com/nicolargo/glances/issues/1060</span>
    <span class="s1">basenames.extend(glob.glob(</span><span class="s5">'/sys/class/hwmon/hwmon*/device/temp*_*'</span><span class="s1">))</span>
    <span class="s1">basenames = sorted(set([x.split(</span><span class="s5">'_'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">basenames]))</span>

    <span class="s0"># Only add the coretemp hwmon entries if they're not already in</span>
    <span class="s0"># /sys/class/hwmon/</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/1708</span>
    <span class="s0"># https://github.com/giampaolo/psutil/pull/1648</span>
    <span class="s1">basenames2 = glob.glob(</span>
        <span class="s5">'/sys/devices/platform/coretemp.*/hwmon/hwmon*/temp*_*'</span><span class="s1">)</span>
    <span class="s1">repl = re.compile(</span><span class="s5">'/sys/devices/platform/coretemp.*/hwmon/'</span><span class="s1">)</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">basenames2:</span>
        <span class="s1">altname = repl.sub(</span><span class="s5">'/sys/class/hwmon/'</span><span class="s3">, </span><span class="s1">name)</span>
        <span class="s3">if </span><span class="s1">altname </span><span class="s3">not in </span><span class="s1">basenames:</span>
            <span class="s1">basenames.append(name)</span>

    <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">basenames:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">path = base + </span><span class="s5">'_input'</span>
            <span class="s1">current = float(bcat(path)) / </span><span class="s4">1000.0</span>
            <span class="s1">path = os.path.join(os.path.dirname(base)</span><span class="s3">, </span><span class="s5">'name'</span><span class="s1">)</span>
            <span class="s1">unit_name = cat(path).strip()</span>
        <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">ValueError):</span>
            <span class="s0"># A lot of things can go wrong here, so let's just skip the</span>
            <span class="s0"># whole entry. Sure thing is Linux's /sys/class/hwmon really</span>
            <span class="s0"># is a stinky broken mess.</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1009</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1101</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1129</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1245</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/1323</span>
            <span class="s3">continue</span>

        <span class="s1">high = bcat(base + </span><span class="s5">'_max'</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">critical = bcat(base + </span><span class="s5">'_crit'</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">label = cat(base + </span><span class="s5">'_label'</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s5">''</span><span class="s1">).strip()</span>

        <span class="s3">if </span><span class="s1">high </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">high = float(high) / </span><span class="s4">1000.0</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s1">high = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">critical </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">critical = float(critical) / </span><span class="s4">1000.0</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s1">critical = </span><span class="s3">None</span>

        <span class="s1">ret[unit_name].append((label</span><span class="s3">, </span><span class="s1">current</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">critical))</span>

    <span class="s0"># Indication that no sensors were detected in /sys/class/hwmon/</span>
    <span class="s3">if not </span><span class="s1">basenames:</span>
        <span class="s1">basenames = glob.glob(</span><span class="s5">'/sys/class/thermal/thermal_zone*'</span><span class="s1">)</span>
        <span class="s1">basenames = sorted(set(basenames))</span>

        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">basenames:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">path = os.path.join(base</span><span class="s3">, </span><span class="s5">'temp'</span><span class="s1">)</span>
                <span class="s1">current = float(bcat(path)) / </span><span class="s4">1000.0</span>
                <span class="s1">path = os.path.join(base</span><span class="s3">, </span><span class="s5">'type'</span><span class="s1">)</span>
                <span class="s1">unit_name = cat(path).strip()</span>
            <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">ValueError) </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s1">debug(err)</span>
                <span class="s3">continue</span>

            <span class="s1">trip_paths = glob.glob(base + </span><span class="s5">'/trip_point*'</span><span class="s1">)</span>
            <span class="s1">trip_points = set([</span><span class="s5">'_'</span><span class="s1">.join(</span>
                <span class="s1">os.path.basename(p).split(</span><span class="s5">'_'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">3</span><span class="s1">]) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">trip_paths])</span>
            <span class="s1">critical = </span><span class="s3">None</span>
            <span class="s1">high = </span><span class="s3">None</span>
            <span class="s3">for </span><span class="s1">trip_point </span><span class="s3">in </span><span class="s1">trip_points:</span>
                <span class="s1">path = os.path.join(base</span><span class="s3">, </span><span class="s1">trip_point + </span><span class="s5">&quot;_type&quot;</span><span class="s1">)</span>
                <span class="s1">trip_type = cat(path</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s5">''</span><span class="s1">).strip()</span>
                <span class="s3">if </span><span class="s1">trip_type == </span><span class="s5">'critical'</span><span class="s1">:</span>
                    <span class="s1">critical = bcat(os.path.join(base</span><span class="s3">, </span><span class="s1">trip_point + </span><span class="s5">&quot;_temp&quot;</span><span class="s1">)</span><span class="s3">,</span>
                                    <span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>
                <span class="s3">elif </span><span class="s1">trip_type == </span><span class="s5">'high'</span><span class="s1">:</span>
                    <span class="s1">high = bcat(os.path.join(base</span><span class="s3">, </span><span class="s1">trip_point + </span><span class="s5">&quot;_temp&quot;</span><span class="s1">)</span><span class="s3">,</span>
                                <span class="s1">fallback=</span><span class="s3">None</span><span class="s1">)</span>

                <span class="s3">if </span><span class="s1">high </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">high = float(high) / </span><span class="s4">1000.0</span>
                    <span class="s3">except </span><span class="s1">ValueError:</span>
                        <span class="s1">high = </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">critical </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s1">critical = float(critical) / </span><span class="s4">1000.0</span>
                    <span class="s3">except </span><span class="s1">ValueError:</span>
                        <span class="s1">critical = </span><span class="s3">None</span>

            <span class="s1">ret[unit_name].append((</span><span class="s5">''</span><span class="s3">, </span><span class="s1">current</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">critical))</span>

    <span class="s3">return </span><span class="s1">dict(ret)</span>


<span class="s3">def </span><span class="s1">sensors_fans():</span>
    <span class="s2">&quot;&quot;&quot;Return hardware fans info (for CPU and other peripherals) as a 
    dict including hardware label and current speed. 
 
    Implementation notes: 
    - /sys/class/hwmon looks like the most recent interface to 
      retrieve this info, and this implementation relies on it 
      only (old distros will probably use something else) 
    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = collections.defaultdict(list)</span>
    <span class="s1">basenames = glob.glob(</span><span class="s5">'/sys/class/hwmon/hwmon*/fan*_*'</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">basenames:</span>
        <span class="s0"># CentOS has an intermediate /device directory:</span>
        <span class="s0"># https://github.com/giampaolo/psutil/issues/971</span>
        <span class="s1">basenames = glob.glob(</span><span class="s5">'/sys/class/hwmon/hwmon*/device/fan*_*'</span><span class="s1">)</span>

    <span class="s1">basenames = sorted(set([x.split(</span><span class="s5">'_'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">basenames]))</span>
    <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">basenames:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">current = int(bcat(base + </span><span class="s5">'_input'</span><span class="s1">))</span>
        <span class="s3">except </span><span class="s1">(IOError</span><span class="s3">, </span><span class="s1">OSError) </span><span class="s3">as </span><span class="s1">err:</span>
            <span class="s1">debug(err)</span>
            <span class="s3">continue</span>
        <span class="s1">unit_name = cat(os.path.join(os.path.dirname(base)</span><span class="s3">, </span><span class="s5">'name'</span><span class="s1">)).strip()</span>
        <span class="s1">label = cat(base + </span><span class="s5">'_label'</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s5">''</span><span class="s1">).strip()</span>
        <span class="s1">ret[unit_name].append(_common.sfan(label</span><span class="s3">, </span><span class="s1">current))</span>

    <span class="s3">return </span><span class="s1">dict(ret)</span>


<span class="s3">def </span><span class="s1">sensors_battery():</span>
    <span class="s2">&quot;&quot;&quot;Return battery information. 
    Implementation note: it appears /sys/class/power_supply/BAT0/ 
    directory structure may vary and provide files with the same 
    meaning but under different names, see: 
    https://github.com/giampaolo/psutil/issues/966 
    &quot;&quot;&quot;</span>
    <span class="s1">null = object()</span>

    <span class="s3">def </span><span class="s1">multi_bcat(*paths):</span>
        <span class="s2">&quot;&quot;&quot;Attempt to read the content of multiple files which may 
        not exist. If none of them exist return None. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">path </span><span class="s3">in </span><span class="s1">paths:</span>
            <span class="s1">ret = bcat(path</span><span class="s3">, </span><span class="s1">fallback=null)</span>
            <span class="s3">if </span><span class="s1">ret != null:</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">int(ret)</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s3">return </span><span class="s1">ret.strip()</span>
        <span class="s3">return None</span>

    <span class="s1">bats = [x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">os.listdir(POWER_SUPPLY_PATH) </span><span class="s3">if </span><span class="s1">x.startswith(</span><span class="s5">'BAT'</span><span class="s1">) </span><span class="s3">or</span>
            <span class="s5">'battery' </span><span class="s3">in </span><span class="s1">x.lower()]</span>
    <span class="s3">if not </span><span class="s1">bats:</span>
        <span class="s3">return None</span>
    <span class="s0"># Get the first available battery. Usually this is &quot;BAT0&quot;, except</span>
    <span class="s0"># some rare exceptions:</span>
    <span class="s0"># https://github.com/giampaolo/psutil/issues/1238</span>
    <span class="s1">root = os.path.join(POWER_SUPPLY_PATH</span><span class="s3">, </span><span class="s1">sorted(bats)[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s0"># Base metrics.</span>
    <span class="s1">energy_now = multi_bcat(</span>
        <span class="s1">root + </span><span class="s5">&quot;/energy_now&quot;</span><span class="s3">,</span>
        <span class="s1">root + </span><span class="s5">&quot;/charge_now&quot;</span><span class="s1">)</span>
    <span class="s1">power_now = multi_bcat(</span>
        <span class="s1">root + </span><span class="s5">&quot;/power_now&quot;</span><span class="s3">,</span>
        <span class="s1">root + </span><span class="s5">&quot;/current_now&quot;</span><span class="s1">)</span>
    <span class="s1">energy_full = multi_bcat(</span>
        <span class="s1">root + </span><span class="s5">&quot;/energy_full&quot;</span><span class="s3">,</span>
        <span class="s1">root + </span><span class="s5">&quot;/charge_full&quot;</span><span class="s1">)</span>
    <span class="s1">time_to_empty = multi_bcat(root + </span><span class="s5">&quot;/time_to_empty_now&quot;</span><span class="s1">)</span>

    <span class="s0"># Percent. If we have energy_full the percentage will be more</span>
    <span class="s0"># accurate compared to reading /capacity file (float vs. int).</span>
    <span class="s3">if </span><span class="s1">energy_full </span><span class="s3">is not None and </span><span class="s1">energy_now </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">percent = </span><span class="s4">100.0 </span><span class="s1">* energy_now / energy_full</span>
        <span class="s3">except </span><span class="s1">ZeroDivisionError:</span>
            <span class="s1">percent = </span><span class="s4">0.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">percent = int(cat(root + </span><span class="s5">&quot;/capacity&quot;</span><span class="s3">, </span><span class="s1">fallback=-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">percent == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">return None</span>

    <span class="s0"># Is AC power cable plugged in?</span>
    <span class="s0"># Note: AC0 is not always available and sometimes (e.g. CentOS7)</span>
    <span class="s0"># it's called &quot;AC&quot;.</span>
    <span class="s1">power_plugged = </span><span class="s3">None</span>
    <span class="s1">online = multi_bcat(</span>
        <span class="s1">os.path.join(POWER_SUPPLY_PATH</span><span class="s3">, </span><span class="s5">&quot;AC0/online&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">os.path.join(POWER_SUPPLY_PATH</span><span class="s3">, </span><span class="s5">&quot;AC/online&quot;</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">online </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">power_plugged = online == </span><span class="s4">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">status = cat(root + </span><span class="s5">&quot;/status&quot;</span><span class="s3">, </span><span class="s1">fallback=</span><span class="s5">&quot;&quot;</span><span class="s1">).strip().lower()</span>
        <span class="s3">if </span><span class="s1">status == </span><span class="s5">&quot;discharging&quot;</span><span class="s1">:</span>
            <span class="s1">power_plugged = </span><span class="s3">False</span>
        <span class="s3">elif </span><span class="s1">status </span><span class="s3">in </span><span class="s1">(</span><span class="s5">&quot;charging&quot;</span><span class="s3">, </span><span class="s5">&quot;full&quot;</span><span class="s1">):</span>
            <span class="s1">power_plugged = </span><span class="s3">True</span>

    <span class="s0"># Seconds left.</span>
    <span class="s0"># Note to self: we may also calculate the charging ETA as per:</span>
    <span class="s0"># https://github.com/thialfihar/dotfiles/blob/</span>
    <span class="s0">#     013937745fd9050c30146290e8f963d65c0179e6/bin/battery.py#L55</span>
    <span class="s3">if </span><span class="s1">power_plugged:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNLIMITED</span>
    <span class="s3">elif </span><span class="s1">energy_now </span><span class="s3">is not None and </span><span class="s1">power_now </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">secsleft = int(energy_now / power_now * </span><span class="s4">3600</span><span class="s1">)</span>
        <span class="s3">except </span><span class="s1">ZeroDivisionError:</span>
            <span class="s1">secsleft = _common.POWER_TIME_UNKNOWN</span>
    <span class="s3">elif </span><span class="s1">time_to_empty </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">secsleft = int(time_to_empty * </span><span class="s4">60</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">secsleft &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">secsleft = _common.POWER_TIME_UNKNOWN</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">secsleft = _common.POWER_TIME_UNKNOWN</span>

    <span class="s3">return </span><span class="s1">_common.sbattery(percent</span><span class="s3">, </span><span class="s1">secsleft</span><span class="s3">, </span><span class="s1">power_plugged)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- other system functions</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">users():</span>
    <span class="s2">&quot;&quot;&quot;Return currently connected users as a list of namedtuples.&quot;&quot;&quot;</span>
    <span class="s1">retlist = []</span>
    <span class="s1">rawlist = cext.users()</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">rawlist:</span>
        <span class="s1">user</span><span class="s3">, </span><span class="s1">tty</span><span class="s3">, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">user_process</span><span class="s3">, </span><span class="s1">pid = item</span>
        <span class="s0"># note: the underlying C function includes entries about</span>
        <span class="s0"># system boot, run level and others.  We might want</span>
        <span class="s0"># to use them in the future.</span>
        <span class="s3">if not </span><span class="s1">user_process:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">hostname </span><span class="s3">in </span><span class="s1">(</span><span class="s5">':0.0'</span><span class="s3">, </span><span class="s5">':0'</span><span class="s1">):</span>
            <span class="s1">hostname = </span><span class="s5">'localhost'</span>
        <span class="s1">nt = _common.suser(user</span><span class="s3">, </span><span class="s1">tty </span><span class="s3">or None, </span><span class="s1">hostname</span><span class="s3">, </span><span class="s1">tstamp</span><span class="s3">, </span><span class="s1">pid)</span>
        <span class="s1">retlist.append(nt)</span>
    <span class="s3">return </span><span class="s1">retlist</span>


<span class="s3">def </span><span class="s1">boot_time():</span>
    <span class="s2">&quot;&quot;&quot;Return the system boot time expressed in seconds since the epoch.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">BOOT_TIME</span>
    <span class="s1">path = </span><span class="s5">'%s/stat' </span><span class="s1">% get_procfs_path()</span>
    <span class="s3">with </span><span class="s1">open_binary(path) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
            <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b'btime'</span><span class="s1">):</span>
                <span class="s1">ret = float(line.strip().split()[</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">BOOT_TIME = ret</span>
                <span class="s3">return </span><span class="s1">ret</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span>
            <span class="s5">&quot;line 'btime' not found in %s&quot; </span><span class="s1">% path)</span>


<span class="s0"># =====================================================================</span>
<span class="s0"># --- processes</span>
<span class="s0"># =====================================================================</span>


<span class="s3">def </span><span class="s1">pids():</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of PIDs currently running on the system.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">[int(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">os.listdir(b(get_procfs_path())) </span><span class="s3">if </span><span class="s1">x.isdigit()]</span>


<span class="s3">def </span><span class="s1">pid_exists(pid):</span>
    <span class="s2">&quot;&quot;&quot;Check for the existence of a unix PID. Linux TIDs are not 
    supported (always return False). 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">_psposix.pid_exists(pid):</span>
        <span class="s3">return False</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Linux's apparently does not distinguish between PIDs and TIDs</span>
        <span class="s0"># (thread IDs).</span>
        <span class="s0"># listdir(&quot;/proc&quot;) won't show any TID (only PIDs) but</span>
        <span class="s0"># os.stat(&quot;/proc/{tid}&quot;) will succeed if {tid} exists.</span>
        <span class="s0"># os.kill() can also be passed a TID. This is quite confusing.</span>
        <span class="s0"># In here we want to enforce this distinction and support PIDs</span>
        <span class="s0"># only, see:</span>
        <span class="s0"># https://github.com/giampaolo/psutil/issues/687</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s0"># Note: already checked that this is faster than using a</span>
            <span class="s0"># regular expr. Also (a lot) faster than doing</span>
            <span class="s0"># 'return pid in pids()'</span>
            <span class="s1">path = </span><span class="s5">&quot;%s/%s/status&quot; </span><span class="s1">% (get_procfs_path()</span><span class="s3">, </span><span class="s1">pid)</span>
            <span class="s3">with </span><span class="s1">open_binary(path) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                    <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b&quot;Tgid:&quot;</span><span class="s1">):</span>
                        <span class="s1">tgid = int(line.split()[</span><span class="s4">1</span><span class="s1">])</span>
                        <span class="s0"># If tgid and pid are the same then we're</span>
                        <span class="s0"># dealing with a process PID.</span>
                        <span class="s3">return </span><span class="s1">tgid == pid</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;'Tgid' line not found in %s&quot; </span><span class="s1">% path)</span>
        <span class="s3">except </span><span class="s1">(EnvironmentError</span><span class="s3">, </span><span class="s1">ValueError):</span>
            <span class="s3">return </span><span class="s1">pid </span><span class="s3">in </span><span class="s1">pids()</span>


<span class="s3">def </span><span class="s1">ppid_map():</span>
    <span class="s2">&quot;&quot;&quot;Obtain a {pid: ppid, ...} dict for all running processes in 
    one shot. Used to speed up Process.children(). 
    &quot;&quot;&quot;</span>
    <span class="s1">ret = {}</span>
    <span class="s1">procfs_path = get_procfs_path()</span>
    <span class="s3">for </span><span class="s1">pid </span><span class="s3">in </span><span class="s1">pids():</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">&quot;%s/%s/stat&quot; </span><span class="s1">% (procfs_path</span><span class="s3">, </span><span class="s1">pid)) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">data = f.read()</span>
        <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
            <span class="s0"># Note: we should be able to access /stat for all processes</span>
            <span class="s0"># aka it's unlikely we'll bump into EPERM, which is good.</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rpar = data.rfind(</span><span class="s6">b')'</span><span class="s1">)</span>
            <span class="s1">dset = data[rpar + </span><span class="s4">2</span><span class="s1">:].split()</span>
            <span class="s1">ppid = int(dset[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">ret[pid] = ppid</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">wrap_exceptions(fun):</span>
    <span class="s2">&quot;&quot;&quot;Decorator which translates bare OSError and IOError exceptions 
    into NoSuchProcess and AccessDenied. 
    &quot;&quot;&quot;</span>
    <span class="s1">@functools.wraps(fun)</span>
    <span class="s3">def </span><span class="s1">wrapper(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fun(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">except </span><span class="s1">PermissionError:</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">except </span><span class="s1">ProcessLookupError:</span>
            <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
        <span class="s3">except </span><span class="s1">FileNotFoundError:</span>
            <span class="s3">if not </span><span class="s1">os.path.exists(</span><span class="s5">&quot;%s/%s&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)):</span>
                <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
            <span class="s0"># Note: zombies will keep existing under /proc until they're</span>
            <span class="s0"># gone so there's no way to distinguish them in here.</span>
            <span class="s3">raise</span>
    <span class="s3">return </span><span class="s1">wrapper</span>


<span class="s3">class </span><span class="s1">Process(object):</span>
    <span class="s2">&quot;&quot;&quot;Linux process implementation.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = [</span><span class="s5">&quot;pid&quot;</span><span class="s3">, </span><span class="s5">&quot;_name&quot;</span><span class="s3">, </span><span class="s5">&quot;_ppid&quot;</span><span class="s3">, </span><span class="s5">&quot;_procfs_path&quot;</span><span class="s3">, </span><span class="s5">&quot;_cache&quot;</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">pid):</span>
        <span class="s1">self.pid = pid</span>
        <span class="s1">self._name = </span><span class="s3">None</span>
        <span class="s1">self._ppid = </span><span class="s3">None</span>
        <span class="s1">self._procfs_path = get_procfs_path()</span>

    <span class="s3">def </span><span class="s1">_assert_alive(self):</span>
        <span class="s2">&quot;&quot;&quot;Raise NSP if the process disappeared on us.&quot;&quot;&quot;</span>
        <span class="s0"># For those C function who do not raise NSP, possibly returning</span>
        <span class="s0"># incorrect or incomplete result.</span>
        <span class="s1">os.stat(</span><span class="s5">'%s/%s' </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_parse_stat_file(self):</span>
        <span class="s2">&quot;&quot;&quot;Parse /proc/{pid}/stat file and return a dict with various 
        process info. 
        Using &quot;man proc&quot; as a reference: where &quot;man proc&quot; refers to 
        position N always subtract 3 (e.g ppid position 4 in 
        'man proc' == position 1 in here). 
        The return value is cached in case oneshot() ctx manager is 
        in use. 
        &quot;&quot;&quot;</span>
        <span class="s1">data = bcat(</span><span class="s5">&quot;%s/%s/stat&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s0"># Process name is between parentheses. It can contain spaces and</span>
        <span class="s0"># other parentheses. This is taken into account by looking for</span>
        <span class="s0"># the first occurrence of &quot;(&quot; and the last occurrence of &quot;)&quot;.</span>
        <span class="s1">rpar = data.rfind(</span><span class="s6">b')'</span><span class="s1">)</span>
        <span class="s1">name = data[data.find(</span><span class="s6">b'('</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">:rpar]</span>
        <span class="s1">fields = data[rpar + </span><span class="s4">2</span><span class="s1">:].split()</span>

        <span class="s1">ret = {}</span>
        <span class="s1">ret[</span><span class="s5">'name'</span><span class="s1">] = name</span>
        <span class="s1">ret[</span><span class="s5">'status'</span><span class="s1">] = fields[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'ppid'</span><span class="s1">] = fields[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'ttynr'</span><span class="s1">] = fields[</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'utime'</span><span class="s1">] = fields[</span><span class="s4">11</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'stime'</span><span class="s1">] = fields[</span><span class="s4">12</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'children_utime'</span><span class="s1">] = fields[</span><span class="s4">13</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'children_stime'</span><span class="s1">] = fields[</span><span class="s4">14</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'create_time'</span><span class="s1">] = fields[</span><span class="s4">19</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'cpu_num'</span><span class="s1">] = fields[</span><span class="s4">36</span><span class="s1">]</span>
        <span class="s1">ret[</span><span class="s5">'blkio_ticks'</span><span class="s1">] = fields[</span><span class="s4">39</span><span class="s1">]  </span><span class="s0"># aka 'delayacct_blkio_ticks'</span>

        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_read_status_file(self):</span>
        <span class="s2">&quot;&quot;&quot;Read /proc/{pid}/stat file and return its content. 
        The return value is cached in case oneshot() ctx manager is 
        in use. 
        &quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">&quot;%s/%s/status&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">return </span><span class="s1">f.read()</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s1">@memoize_when_activated</span>
    <span class="s3">def </span><span class="s1">_read_smaps_file(self):</span>
        <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">&quot;%s/%s/smaps&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">return </span><span class="s1">f.read().strip()</span>

    <span class="s3">def </span><span class="s1">oneshot_enter(self):</span>
        <span class="s1">self._parse_stat_file.cache_activate(self)</span>
        <span class="s1">self._read_status_file.cache_activate(self)</span>
        <span class="s1">self._read_smaps_file.cache_activate(self)</span>

    <span class="s3">def </span><span class="s1">oneshot_exit(self):</span>
        <span class="s1">self._parse_stat_file.cache_deactivate(self)</span>
        <span class="s1">self._read_status_file.cache_deactivate(self)</span>
        <span class="s1">self._read_smaps_file.cache_deactivate(self)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">name(self):</span>
        <span class="s1">name = self._parse_stat_file()[</span><span class="s5">'name'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">name = decode(name)</span>
        <span class="s0"># XXX - gets changed later and probably needs refactoring</span>
        <span class="s3">return </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">exe(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">readlink(</span><span class="s5">&quot;%s/%s/exe&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
            <span class="s0"># no such file error; might be raised also if the</span>
            <span class="s0"># path actually exists for system processes with</span>
            <span class="s0"># low pids (about 0-20)</span>
            <span class="s3">if </span><span class="s1">os.path.lexists(</span><span class="s5">&quot;%s/%s&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)):</span>
                <span class="s3">return </span><span class="s5">&quot;&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                    <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
        <span class="s3">except </span><span class="s1">PermissionError:</span>
            <span class="s3">raise </span><span class="s1">AccessDenied(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cmdline(self):</span>
        <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/%s/cmdline&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">data = f.read()</span>
        <span class="s3">if not </span><span class="s1">data:</span>
            <span class="s0"># may happen in case of zombie process</span>
            <span class="s3">return </span><span class="s1">[]</span>
        <span class="s0"># 'man proc' states that args are separated by null bytes '\0'</span>
        <span class="s0"># and last char is supposed to be a null byte. Nevertheless</span>
        <span class="s0"># some processes may change their cmdline after being started</span>
        <span class="s0"># (via setproctitle() or similar), they are usually not</span>
        <span class="s0"># compliant with this rule and use spaces instead. Google</span>
        <span class="s0"># Chrome process is an example. See:</span>
        <span class="s0"># https://github.com/giampaolo/psutil/issues/1179</span>
        <span class="s1">sep = </span><span class="s5">'</span><span class="s3">\x00</span><span class="s5">' </span><span class="s3">if </span><span class="s1">data.endswith(</span><span class="s5">'</span><span class="s3">\x00</span><span class="s5">'</span><span class="s1">) </span><span class="s3">else </span><span class="s5">' '</span>
        <span class="s3">if </span><span class="s1">data.endswith(sep):</span>
            <span class="s1">data = data[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">cmdline = data.split(sep)</span>
        <span class="s0"># Sometimes last char is a null byte '\0' but the args are</span>
        <span class="s0"># separated by spaces, see: https://github.com/giampaolo/psutil/</span>
        <span class="s0"># issues/1179#issuecomment-552984549</span>
        <span class="s3">if </span><span class="s1">sep == </span><span class="s5">'</span><span class="s3">\x00</span><span class="s5">' </span><span class="s3">and </span><span class="s1">len(cmdline) == </span><span class="s4">1 </span><span class="s3">and </span><span class="s5">' ' </span><span class="s3">in </span><span class="s1">data:</span>
            <span class="s1">cmdline = data.split(</span><span class="s5">' '</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">cmdline</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">environ(self):</span>
        <span class="s3">with </span><span class="s1">open_text(</span><span class="s5">&quot;%s/%s/environ&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">data = f.read()</span>
        <span class="s3">return </span><span class="s1">parse_environ_block(data)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">terminal(self):</span>
        <span class="s1">tty_nr = int(self._parse_stat_file()[</span><span class="s5">'ttynr'</span><span class="s1">])</span>
        <span class="s1">tmap = _psposix.get_terminal_map()</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">tmap[tty_nr]</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">return None</span>

    <span class="s0"># May not be available on old kernels.</span>
    <span class="s3">if </span><span class="s1">os.path.exists(</span><span class="s5">'/proc/%s/io' </span><span class="s1">% os.getpid()):</span>
        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">io_counters(self):</span>
            <span class="s1">fname = </span><span class="s5">&quot;%s/%s/io&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)</span>
            <span class="s1">fields = {}</span>
            <span class="s3">with </span><span class="s1">open_binary(fname) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                    <span class="s0"># https://github.com/giampaolo/psutil/issues/1004</span>
                    <span class="s1">line = line.strip()</span>
                    <span class="s3">if </span><span class="s1">line:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">name</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s6">b': '</span><span class="s1">)</span>
                        <span class="s3">except </span><span class="s1">ValueError:</span>
                            <span class="s0"># https://github.com/giampaolo/psutil/issues/1004</span>
                            <span class="s3">continue</span>
                        <span class="s3">else</span><span class="s1">:</span>
                            <span class="s1">fields[name] = int(value)</span>
            <span class="s3">if not </span><span class="s1">fields:</span>
                <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;%s file was empty&quot; </span><span class="s1">% fname)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">pio(</span>
                    <span class="s1">fields[</span><span class="s6">b'syscr'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># read syscalls</span>
                    <span class="s1">fields[</span><span class="s6">b'syscw'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># write syscalls</span>
                    <span class="s1">fields[</span><span class="s6">b'read_bytes'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># read bytes</span>
                    <span class="s1">fields[</span><span class="s6">b'write_bytes'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># write bytes</span>
                    <span class="s1">fields[</span><span class="s6">b'rchar'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># read chars</span>
                    <span class="s1">fields[</span><span class="s6">b'wchar'</span><span class="s1">]</span><span class="s3">,  </span><span class="s0"># write chars</span>
                <span class="s1">)</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;%r field was not found in %s; found fields &quot;</span>
                                 <span class="s5">&quot;are %r&quot; </span><span class="s1">% (err[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">, </span><span class="s1">fields))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_times(self):</span>
        <span class="s1">values = self._parse_stat_file()</span>
        <span class="s1">utime = float(values[</span><span class="s5">'utime'</span><span class="s1">]) / CLOCK_TICKS</span>
        <span class="s1">stime = float(values[</span><span class="s5">'stime'</span><span class="s1">]) / CLOCK_TICKS</span>
        <span class="s1">children_utime = float(values[</span><span class="s5">'children_utime'</span><span class="s1">]) / CLOCK_TICKS</span>
        <span class="s1">children_stime = float(values[</span><span class="s5">'children_stime'</span><span class="s1">]) / CLOCK_TICKS</span>
        <span class="s1">iowait = float(values[</span><span class="s5">'blkio_ticks'</span><span class="s1">]) / CLOCK_TICKS</span>
        <span class="s3">return </span><span class="s1">pcputimes(utime</span><span class="s3">, </span><span class="s1">stime</span><span class="s3">, </span><span class="s1">children_utime</span><span class="s3">, </span><span class="s1">children_stime</span><span class="s3">, </span><span class="s1">iowait)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cpu_num(self):</span>
        <span class="s2">&quot;&quot;&quot;What CPU the process is on.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">int(self._parse_stat_file()[</span><span class="s5">'cpu_num'</span><span class="s1">])</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">wait(self</span><span class="s3">, </span><span class="s1">timeout=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">_psposix.wait_pid(self.pid</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">self._name)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">create_time(self):</span>
        <span class="s1">ctime = float(self._parse_stat_file()[</span><span class="s5">'create_time'</span><span class="s1">])</span>
        <span class="s0"># According to documentation, starttime is in field 21 and the</span>
        <span class="s0"># unit is jiffies (clock ticks).</span>
        <span class="s0"># We first divide it for clock ticks and then add uptime returning</span>
        <span class="s0"># seconds since the epoch.</span>
        <span class="s0"># Also use cached value if available.</span>
        <span class="s1">bt = BOOT_TIME </span><span class="s3">or </span><span class="s1">boot_time()</span>
        <span class="s3">return </span><span class="s1">(ctime / CLOCK_TICKS) + bt</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">memory_info(self):</span>
        <span class="s0">#  ============================================================</span>
        <span class="s0"># | FIELD  | DESCRIPTION                         | AKA  | TOP  |</span>
        <span class="s0">#  ============================================================</span>
        <span class="s0"># | rss    | resident set size                   |      | RES  |</span>
        <span class="s0"># | vms    | total program size                  | size | VIRT |</span>
        <span class="s0"># | shared | shared pages (from shared mappings) |      | SHR  |</span>
        <span class="s0"># | text   | text ('code')                       | trs  | CODE |</span>
        <span class="s0"># | lib    | library (unused in Linux 2.6)       | lrs  |      |</span>
        <span class="s0"># | data   | data + stack                        | drs  | DATA |</span>
        <span class="s0"># | dirty  | dirty pages (unused in Linux 2.6)   | dt   |      |</span>
        <span class="s0">#  ============================================================</span>
        <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">&quot;%s/%s/statm&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s1">vms</span><span class="s3">, </span><span class="s1">rss</span><span class="s3">, </span><span class="s1">shared</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">dirty = \</span>
                <span class="s1">[int(x) * PAGESIZE </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">f.readline().split()[:</span><span class="s4">7</span><span class="s1">]]</span>
        <span class="s3">return </span><span class="s1">pmem(rss</span><span class="s3">, </span><span class="s1">vms</span><span class="s3">, </span><span class="s1">shared</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">lib</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">dirty)</span>

    <span class="s3">if </span><span class="s1">HAS_PROC_SMAPS_ROLLUP </span><span class="s3">or </span><span class="s1">HAS_PROC_SMAPS:</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">_parse_smaps_rollup(self):</span>
            <span class="s0"># /proc/pid/smaps_rollup was added to Linux in 2017. Faster</span>
            <span class="s0"># than /proc/pid/smaps. It reports higher PSS than */smaps</span>
            <span class="s0"># (from 1k up to 200k higher; tested against all processes).</span>
            <span class="s1">uss = pss = swap = </span><span class="s4">0</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">with </span><span class="s1">open_binary(</span><span class="s5">&quot;{}/{}/smaps_rollup&quot;</span><span class="s1">.format(</span>
                        <span class="s1">self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)) </span><span class="s3">as </span><span class="s1">f:</span>
                    <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">f:</span>
                        <span class="s3">if </span><span class="s1">line.startswith(</span><span class="s6">b&quot;Private_&quot;</span><span class="s1">):</span>
                            <span class="s0"># Private_Clean, Private_Dirty, Private_Hugetlb</span>
                            <span class="s1">uss += int(line.split()[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>
                        <span class="s3">elif </span><span class="s1">line.startswith(</span><span class="s6">b&quot;Pss:&quot;</span><span class="s1">):</span>
                            <span class="s1">pss = int(line.split()[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>
                        <span class="s3">elif </span><span class="s1">line.startswith(</span><span class="s6">b&quot;Swap:&quot;</span><span class="s1">):</span>
                            <span class="s1">swap = int(line.split()[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>
            <span class="s3">except </span><span class="s1">ProcessLookupError:  </span><span class="s0"># happens on readline()</span>
                <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                    <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
            <span class="s3">return </span><span class="s1">(uss</span><span class="s3">, </span><span class="s1">pss</span><span class="s3">, </span><span class="s1">swap)</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">_parse_smaps(</span>
                <span class="s1">self</span><span class="s3">,</span>
                <span class="s0"># Gets Private_Clean, Private_Dirty, Private_Hugetlb.</span>
                <span class="s1">_private_re=re.compile(</span><span class="s6">br&quot;\nPrivate.*:\s+(\d+)&quot;</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">_pss_re=re.compile(</span><span class="s6">br&quot;\nPss\:\s+(\d+)&quot;</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">_swap_re=re.compile(</span><span class="s6">br&quot;\nSwap\:\s+(\d+)&quot;</span><span class="s1">)):</span>
            <span class="s0"># /proc/pid/smaps does not exist on kernels &lt; 2.6.14 or if</span>
            <span class="s0"># CONFIG_MMU kernel configuration option is not enabled.</span>

            <span class="s0"># Note: using 3 regexes is faster than reading the file</span>
            <span class="s0"># line by line.</span>
            <span class="s0"># XXX: on Python 3 the 2 regexes are 30% slower than on</span>
            <span class="s0"># Python 2 though. Figure out why.</span>
            <span class="s0">#</span>
            <span class="s0"># You might be tempted to calculate USS by subtracting</span>
            <span class="s0"># the &quot;shared&quot; value from the &quot;resident&quot; value in</span>
            <span class="s0"># /proc/&lt;pid&gt;/statm. But at least on Linux, statm's &quot;shared&quot;</span>
            <span class="s0"># value actually counts pages backed by files, which has</span>
            <span class="s0"># little to do with whether the pages are actually shared.</span>
            <span class="s0"># /proc/self/smaps on the other hand appears to give us the</span>
            <span class="s0"># correct information.</span>
            <span class="s1">smaps_data = self._read_smaps_file()</span>
            <span class="s0"># Note: smaps file can be empty for certain processes.</span>
            <span class="s0"># The code below will not crash though and will result to 0.</span>
            <span class="s1">uss = sum(map(int</span><span class="s3">, </span><span class="s1">_private_re.findall(smaps_data))) * </span><span class="s4">1024</span>
            <span class="s1">pss = sum(map(int</span><span class="s3">, </span><span class="s1">_pss_re.findall(smaps_data))) * </span><span class="s4">1024</span>
            <span class="s1">swap = sum(map(int</span><span class="s3">, </span><span class="s1">_swap_re.findall(smaps_data))) * </span><span class="s4">1024</span>
            <span class="s3">return </span><span class="s1">(uss</span><span class="s3">, </span><span class="s1">pss</span><span class="s3">, </span><span class="s1">swap)</span>

        <span class="s3">def </span><span class="s1">memory_full_info(self):</span>
            <span class="s3">if </span><span class="s1">HAS_PROC_SMAPS_ROLLUP:  </span><span class="s0"># faster</span>
                <span class="s1">uss</span><span class="s3">, </span><span class="s1">pss</span><span class="s3">, </span><span class="s1">swap = self._parse_smaps_rollup()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">uss</span><span class="s3">, </span><span class="s1">pss</span><span class="s3">, </span><span class="s1">swap = self._parse_smaps()</span>
            <span class="s1">basic_mem = self.memory_info()</span>
            <span class="s3">return </span><span class="s1">pfullmem(*basic_mem + (uss</span><span class="s3">, </span><span class="s1">pss</span><span class="s3">, </span><span class="s1">swap))</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">memory_full_info = memory_info</span>

    <span class="s3">if </span><span class="s1">HAS_PROC_SMAPS:</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">memory_maps(self):</span>
            <span class="s2">&quot;&quot;&quot;Return process's mapped memory regions as a list of named 
            tuples. Fields are explained in 'man proc'; here is an updated 
            (Apr 2012) version: http://goo.gl/fmebo 
 
            /proc/{PID}/smaps does not exist on kernels &lt; 2.6.14 or if 
            CONFIG_MMU kernel configuration option is not enabled. 
            &quot;&quot;&quot;</span>
            <span class="s3">def </span><span class="s1">get_blocks(lines</span><span class="s3">, </span><span class="s1">current_block):</span>
                <span class="s1">data = {}</span>
                <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">lines:</span>
                    <span class="s1">fields = line.split(</span><span class="s3">None, </span><span class="s4">5</span><span class="s1">)</span>
                    <span class="s3">if not </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">].endswith(</span><span class="s6">b':'</span><span class="s1">):</span>
                        <span class="s0"># new block section</span>
                        <span class="s3">yield </span><span class="s1">(current_block.pop()</span><span class="s3">, </span><span class="s1">data)</span>
                        <span class="s1">current_block.append(line)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s3">try</span><span class="s1">:</span>
                            <span class="s1">data[fields[</span><span class="s4">0</span><span class="s1">]] = int(fields[</span><span class="s4">1</span><span class="s1">]) * </span><span class="s4">1024</span>
                        <span class="s3">except </span><span class="s1">ValueError:</span>
                            <span class="s3">if </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">].startswith(</span><span class="s6">b'VmFlags:'</span><span class="s1">):</span>
                                <span class="s0"># see issue #369</span>
                                <span class="s3">continue</span>
                            <span class="s3">else</span><span class="s1">:</span>
                                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;don't know how to inte&quot;</span>
                                                 <span class="s5">&quot;rpret line %r&quot; </span><span class="s1">% line)</span>
                <span class="s3">yield </span><span class="s1">(current_block.pop()</span><span class="s3">, </span><span class="s1">data)</span>

            <span class="s1">data = self._read_smaps_file()</span>
            <span class="s0"># Note: smaps file can be empty for certain processes.</span>
            <span class="s3">if not </span><span class="s1">data:</span>
                <span class="s3">return </span><span class="s1">[]</span>
            <span class="s1">lines = data.split(</span><span class="s6">b'</span><span class="s3">\n</span><span class="s6">'</span><span class="s1">)</span>
            <span class="s1">ls = []</span>
            <span class="s1">first_line = lines.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">current_block = [first_line]</span>
            <span class="s3">for </span><span class="s1">header</span><span class="s3">, </span><span class="s1">data </span><span class="s3">in </span><span class="s1">get_blocks(lines</span><span class="s3">, </span><span class="s1">current_block):</span>
                <span class="s1">hfields = header.split(</span><span class="s3">None, </span><span class="s4">5</span><span class="s1">)</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">addr</span><span class="s3">, </span><span class="s1">perms</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">dev</span><span class="s3">, </span><span class="s1">inode</span><span class="s3">, </span><span class="s1">path = hfields</span>
                <span class="s3">except </span><span class="s1">ValueError:</span>
                    <span class="s1">addr</span><span class="s3">, </span><span class="s1">perms</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">, </span><span class="s1">dev</span><span class="s3">, </span><span class="s1">inode</span><span class="s3">, </span><span class="s1">path = \</span>
                        <span class="s1">hfields + [</span><span class="s5">''</span><span class="s1">]</span>
                <span class="s3">if not </span><span class="s1">path:</span>
                    <span class="s1">path = </span><span class="s5">'[anon]'</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if </span><span class="s1">PY3:</span>
                        <span class="s1">path = decode(path)</span>
                    <span class="s1">path = path.strip()</span>
                    <span class="s3">if </span><span class="s1">(path.endswith(</span><span class="s5">' (deleted)'</span><span class="s1">) </span><span class="s3">and not</span>
                            <span class="s1">path_exists_strict(path)):</span>
                        <span class="s1">path = path[:-</span><span class="s4">10</span><span class="s1">]</span>
                <span class="s1">ls.append((</span>
                    <span class="s1">decode(addr)</span><span class="s3">, </span><span class="s1">decode(perms)</span><span class="s3">, </span><span class="s1">path</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Rss:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Size:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Pss:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Shared_Clean:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Shared_Dirty:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Private_Clean:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Private_Dirty:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Referenced:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Anonymous:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">data.get(</span><span class="s6">b'Swap:'</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">))</span>
            <span class="s3">return </span><span class="s1">ls</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">cwd(self):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">readlink(</span><span class="s5">&quot;%s/%s/cwd&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
            <span class="s0"># https://github.com/giampaolo/psutil/issues/986</span>
            <span class="s3">if not </span><span class="s1">pid_exists(self.pid):</span>
                <span class="s3">raise </span><span class="s1">NoSuchProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_ctx_switches(self</span><span class="s3">,</span>
                         <span class="s1">_ctxsw_re=re.compile(</span><span class="s6">br'ctxt_switches:\t(\d+)'</span><span class="s1">)):</span>
        <span class="s1">data = self._read_status_file()</span>
        <span class="s1">ctxsw = _ctxsw_re.findall(data)</span>
        <span class="s3">if not </span><span class="s1">ctxsw:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">&quot;'voluntary_ctxt_switches' and 'nonvoluntary_ctxt_switches'&quot;</span>
                <span class="s5">&quot;lines were not found in %s/%s/status; the kernel is &quot;</span>
                <span class="s5">&quot;probably older than 2.6.23&quot; </span><span class="s1">% (</span>
                    <span class="s1">self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">_common.pctxsw(int(ctxsw[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">int(ctxsw[</span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_threads(self</span><span class="s3">, </span><span class="s1">_num_threads_re=re.compile(</span><span class="s6">br'Threads:\t(\d+)'</span><span class="s1">)):</span>
        <span class="s0"># Note: on Python 3 using a re is faster than iterating over file</span>
        <span class="s0"># line by line. On Python 2 is the exact opposite, and iterating</span>
        <span class="s0"># over a file on Python 3 is slower than on Python 2.</span>
        <span class="s1">data = self._read_status_file()</span>
        <span class="s3">return </span><span class="s1">int(_num_threads_re.findall(data)[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">threads(self):</span>
        <span class="s1">thread_ids = os.listdir(</span><span class="s5">&quot;%s/%s/task&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s1">thread_ids.sort()</span>
        <span class="s1">retlist = []</span>
        <span class="s1">hit_enoent = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">thread_id </span><span class="s3">in </span><span class="s1">thread_ids:</span>
            <span class="s1">fname = </span><span class="s5">&quot;%s/%s/task/%s/stat&quot; </span><span class="s1">% (</span>
                <span class="s1">self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid</span><span class="s3">, </span><span class="s1">thread_id)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">with </span><span class="s1">open_binary(fname) </span><span class="s3">as </span><span class="s1">f:</span>
                    <span class="s1">st = f.read().strip()</span>
            <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
                <span class="s0"># no such file or directory or no such process;</span>
                <span class="s0"># it means thread disappeared on us</span>
                <span class="s1">hit_enoent = </span><span class="s3">True</span>
                <span class="s3">continue</span>
            <span class="s0"># ignore the first two values (&quot;pid (exe)&quot;)</span>
            <span class="s1">st = st[st.find(</span><span class="s6">b')'</span><span class="s1">) + </span><span class="s4">2</span><span class="s1">:]</span>
            <span class="s1">values = st.split(</span><span class="s6">b' '</span><span class="s1">)</span>
            <span class="s1">utime = float(values[</span><span class="s4">11</span><span class="s1">]) / CLOCK_TICKS</span>
            <span class="s1">stime = float(values[</span><span class="s4">12</span><span class="s1">]) / CLOCK_TICKS</span>
            <span class="s1">ntuple = _common.pthread(int(thread_id)</span><span class="s3">, </span><span class="s1">utime</span><span class="s3">, </span><span class="s1">stime)</span>
            <span class="s1">retlist.append(ntuple)</span>
        <span class="s3">if </span><span class="s1">hit_enoent:</span>
            <span class="s1">self._assert_alive()</span>
        <span class="s3">return </span><span class="s1">retlist</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_get(self):</span>
        <span class="s0"># with open_text('%s/%s/stat' % (self._procfs_path, self.pid)) as f:</span>
        <span class="s0">#   data = f.read()</span>
        <span class="s0">#   return int(data.split()[18])</span>

        <span class="s0"># Use C implementation</span>
        <span class="s3">return </span><span class="s1">cext_posix.getpriority(self.pid)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">nice_set(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">cext_posix.setpriority(self.pid</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s0"># starting from CentOS 6.</span>
    <span class="s3">if </span><span class="s1">HAS_CPU_AFFINITY:</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">cpu_affinity_get(self):</span>
            <span class="s3">return </span><span class="s1">cext.proc_cpu_affinity_get(self.pid)</span>

        <span class="s3">def </span><span class="s1">_get_eligible_cpus(</span>
                <span class="s1">self</span><span class="s3">, </span><span class="s1">_re=re.compile(</span><span class="s6">br&quot;Cpus_allowed_list:\t(\d+)-(\d+)&quot;</span><span class="s1">)):</span>
            <span class="s0"># See: https://github.com/giampaolo/psutil/issues/956</span>
            <span class="s1">data = self._read_status_file()</span>
            <span class="s1">match = _re.findall(data)</span>
            <span class="s3">if </span><span class="s1">match:</span>
                <span class="s3">return </span><span class="s1">list(range(int(match[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">int(match[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]) + </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">list(range(len(per_cpu_times())))</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">cpu_affinity_set(self</span><span class="s3">, </span><span class="s1">cpus):</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">cext.proc_cpu_affinity_set(self.pid</span><span class="s3">, </span><span class="s1">cpus)</span>
            <span class="s3">except </span><span class="s1">(OSError</span><span class="s3">, </span><span class="s1">ValueError) </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">isinstance(err</span><span class="s3">, </span><span class="s1">ValueError) </span><span class="s3">or </span><span class="s1">err.errno == errno.EINVAL:</span>
                    <span class="s1">eligible_cpus = self._get_eligible_cpus()</span>
                    <span class="s1">all_cpus = tuple(range(len(per_cpu_times())))</span>
                    <span class="s3">for </span><span class="s1">cpu </span><span class="s3">in </span><span class="s1">cpus:</span>
                        <span class="s3">if </span><span class="s1">cpu </span><span class="s3">not in </span><span class="s1">all_cpus:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;invalid CPU number %r; choose between %s&quot; </span><span class="s1">% (</span>
                                    <span class="s1">cpu</span><span class="s3">, </span><span class="s1">eligible_cpus))</span>
                        <span class="s3">if </span><span class="s1">cpu </span><span class="s3">not in </span><span class="s1">eligible_cpus:</span>
                            <span class="s3">raise </span><span class="s1">ValueError(</span>
                                <span class="s5">&quot;CPU number %r is not eligible; choose &quot;</span>
                                <span class="s5">&quot;between %s&quot; </span><span class="s1">% (cpu</span><span class="s3">, </span><span class="s1">eligible_cpus))</span>
                <span class="s3">raise</span>

    <span class="s0"># only starting from kernel 2.6.13</span>
    <span class="s3">if </span><span class="s1">HAS_PROC_IO_PRIORITY:</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">ionice_get(self):</span>
            <span class="s1">ioclass</span><span class="s3">, </span><span class="s1">value = cext.proc_ioprio_get(self.pid)</span>
            <span class="s3">if </span><span class="s1">enum </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">ioclass = IOPriority(ioclass)</span>
            <span class="s3">return </span><span class="s1">_common.pionice(ioclass</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">ionice_set(self</span><span class="s3">, </span><span class="s1">ioclass</span><span class="s3">, </span><span class="s1">value):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">value = </span><span class="s4">0</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">and </span><span class="s1">ioclass </span><span class="s3">in </span><span class="s1">(IOPRIO_CLASS_IDLE</span><span class="s3">, </span><span class="s1">IOPRIO_CLASS_NONE):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;%r ioclass accepts no value&quot; </span><span class="s1">% ioclass)</span>
            <span class="s3">if </span><span class="s1">value &lt; </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">value &gt; </span><span class="s4">7</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;value not in 0-7 range&quot;</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">cext.proc_ioprio_set(self.pid</span><span class="s3">, </span><span class="s1">ioclass</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">if </span><span class="s1">prlimit </span><span class="s3">is not None</span><span class="s1">:</span>

        <span class="s1">@wrap_exceptions</span>
        <span class="s3">def </span><span class="s1">rlimit(self</span><span class="s3">, </span><span class="s1">resource_</span><span class="s3">, </span><span class="s1">limits=</span><span class="s3">None</span><span class="s1">):</span>
            <span class="s0"># If pid is 0 prlimit() applies to the calling process and</span>
            <span class="s0"># we don't want that. We should never get here though as</span>
            <span class="s0"># PID 0 is not supported on Linux.</span>
            <span class="s3">if </span><span class="s1">self.pid == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;can't use prlimit() against PID 0 process&quot;</span><span class="s1">)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">limits </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s0"># get</span>
                    <span class="s3">return </span><span class="s1">prlimit(self.pid</span><span class="s3">, </span><span class="s1">resource_)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s0"># set</span>
                    <span class="s3">if </span><span class="s1">len(limits) != </span><span class="s4">2</span><span class="s1">:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span>
                            <span class="s5">&quot;second argument must be a (soft, hard) tuple, &quot;</span>
                            <span class="s5">&quot;got %s&quot; </span><span class="s1">% repr(limits))</span>
                    <span class="s1">prlimit(self.pid</span><span class="s3">, </span><span class="s1">resource_</span><span class="s3">, </span><span class="s1">limits)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">err.errno == errno.ENOSYS </span><span class="s3">and </span><span class="s1">pid_exists(self.pid):</span>
                    <span class="s0"># I saw this happening on Travis:</span>
                    <span class="s0"># https://travis-ci.org/giampaolo/psutil/jobs/51368273</span>
                    <span class="s3">raise </span><span class="s1">ZombieProcess(self.pid</span><span class="s3">, </span><span class="s1">self._name</span><span class="s3">, </span><span class="s1">self._ppid)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">raise</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">status(self):</span>
        <span class="s1">letter = self._parse_stat_file()[</span><span class="s5">'status'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">PY3:</span>
            <span class="s1">letter = letter.decode()</span>
        <span class="s0"># XXX is '?' legit? (we're not supposed to return it anyway)</span>
        <span class="s3">return </span><span class="s1">PROC_STATUSES.get(letter</span><span class="s3">, </span><span class="s5">'?'</span><span class="s1">)</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">open_files(self):</span>
        <span class="s1">retlist = []</span>
        <span class="s1">files = os.listdir(</span><span class="s5">&quot;%s/%s/fd&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid))</span>
        <span class="s1">hit_enoent = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">fd </span><span class="s3">in </span><span class="s1">files:</span>
            <span class="s1">file = </span><span class="s5">&quot;%s/%s/fd/%s&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid</span><span class="s3">, </span><span class="s1">fd)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">path = readlink(file)</span>
            <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
                <span class="s0"># ENOENT == file which is gone in the meantime</span>
                <span class="s1">hit_enoent = </span><span class="s3">True</span>
                <span class="s3">continue</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">err:</span>
                <span class="s3">if </span><span class="s1">err.errno == errno.EINVAL:</span>
                    <span class="s0"># not a link</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">err.errno == errno.ENAMETOOLONG:</span>
                    <span class="s0"># file name too long</span>
                    <span class="s1">debug(err)</span>
                    <span class="s3">continue</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># If path is not an absolute there's no way to tell</span>
                <span class="s0"># whether it's a regular file or not, so we skip it.</span>
                <span class="s0"># A regular file is always supposed to be have an</span>
                <span class="s0"># absolute path though.</span>
                <span class="s3">if </span><span class="s1">path.startswith(</span><span class="s5">'/'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">isfile_strict(path):</span>
                    <span class="s0"># Get file position and flags.</span>
                    <span class="s1">file = </span><span class="s5">&quot;%s/%s/fdinfo/%s&quot; </span><span class="s1">% (</span>
                        <span class="s1">self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid</span><span class="s3">, </span><span class="s1">fd)</span>
                    <span class="s3">try</span><span class="s1">:</span>
                        <span class="s3">with </span><span class="s1">open_binary(file) </span><span class="s3">as </span><span class="s1">f:</span>
                            <span class="s1">pos = int(f.readline().split()[</span><span class="s4">1</span><span class="s1">])</span>
                            <span class="s1">flags = int(f.readline().split()[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">8</span><span class="s1">)</span>
                    <span class="s3">except </span><span class="s1">(FileNotFoundError</span><span class="s3">, </span><span class="s1">ProcessLookupError):</span>
                        <span class="s0"># fd gone in the meantime; process may</span>
                        <span class="s0"># still be alive</span>
                        <span class="s1">hit_enoent = </span><span class="s3">True</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">mode = file_flags_to_mode(flags)</span>
                        <span class="s1">ntuple = popenfile(</span>
                            <span class="s1">path</span><span class="s3">, </span><span class="s1">int(fd)</span><span class="s3">, </span><span class="s1">int(pos)</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">flags)</span>
                        <span class="s1">retlist.append(ntuple)</span>
        <span class="s3">if </span><span class="s1">hit_enoent:</span>
            <span class="s1">self._assert_alive()</span>
        <span class="s3">return </span><span class="s1">retlist</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">connections(self</span><span class="s3">, </span><span class="s1">kind=</span><span class="s5">'inet'</span><span class="s1">):</span>
        <span class="s1">ret = _connections.retrieve(kind</span><span class="s3">, </span><span class="s1">self.pid)</span>
        <span class="s1">self._assert_alive()</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">num_fds(self):</span>
        <span class="s3">return </span><span class="s1">len(os.listdir(</span><span class="s5">&quot;%s/%s/fd&quot; </span><span class="s1">% (self._procfs_path</span><span class="s3">, </span><span class="s1">self.pid)))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">ppid(self):</span>
        <span class="s3">return </span><span class="s1">int(self._parse_stat_file()[</span><span class="s5">'ppid'</span><span class="s1">])</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">uids(self</span><span class="s3">, </span><span class="s1">_uids_re=re.compile(</span><span class="s6">br'Uid:\t(\d+)\t(\d+)\t(\d+)'</span><span class="s1">)):</span>
        <span class="s1">data = self._read_status_file()</span>
        <span class="s1">real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved = _uids_re.findall(data)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">_common.puids(int(real)</span><span class="s3">, </span><span class="s1">int(effective)</span><span class="s3">, </span><span class="s1">int(saved))</span>

    <span class="s1">@wrap_exceptions</span>
    <span class="s3">def </span><span class="s1">gids(self</span><span class="s3">, </span><span class="s1">_gids_re=re.compile(</span><span class="s6">br'Gid:\t(\d+)\t(\d+)\t(\d+)'</span><span class="s1">)):</span>
        <span class="s1">data = self._read_status_file()</span>
        <span class="s1">real</span><span class="s3">, </span><span class="s1">effective</span><span class="s3">, </span><span class="s1">saved = _gids_re.findall(data)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">_common.pgids(int(real)</span><span class="s3">, </span><span class="s1">int(effective)</span><span class="s3">, </span><span class="s1">int(saved))</span>
</pre>
</body>
</html>
<html>
<head>
<title>codegenerator.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
codegenerator.py</font>
</center></td></tr></table>
<pre><span class="s0"># Code generator to generate code for everything contained in COM type</span>
<span class="s0"># libraries.</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s1">):</span>
    <span class="s2">import </span><span class="s1">io</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">cStringIO </span><span class="s2">as </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">keyword</span>
<span class="s2">import </span><span class="s1">ctypes</span>
<span class="s2">import </span><span class="s1">textwrap</span>

<span class="s2">from </span><span class="s1">comtypes.tools </span><span class="s2">import </span><span class="s1">typedesc</span>
<span class="s2">import </span><span class="s1">comtypes</span>
<span class="s2">import </span><span class="s1">comtypes.client</span>
<span class="s2">import </span><span class="s1">comtypes.client._generate</span>

<span class="s1">version = comtypes.__version__</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">__warn_on_munge__ = </span><span class="s2">__debug__</span>


<span class="s2">class </span><span class="s1">lcid(object):</span>
    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;_lcid&quot;</span>
<span class="s1">lcid = lcid()</span>

<span class="s2">class </span><span class="s1">dispid(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">memid):</span>
        <span class="s1">self.memid = memid</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;dispid(%s)&quot; </span><span class="s1">% self.memid</span>

<span class="s2">class </span><span class="s1">helpstring(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">text):</span>
        <span class="s1">self.text = text</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;helpstring(%r)&quot; </span><span class="s1">% self.text</span>


<span class="s0"># XXX Should this be in ctypes itself?</span>
<span class="s1">ctypes_names = {</span>
    <span class="s4">&quot;unsigned char&quot;</span><span class="s1">: </span><span class="s4">&quot;c_ubyte&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;signed char&quot;</span><span class="s1">: </span><span class="s4">&quot;c_byte&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;char&quot;</span><span class="s1">: </span><span class="s4">&quot;c_char&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;wchar_t&quot;</span><span class="s1">: </span><span class="s4">&quot;c_wchar&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;short unsigned int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_ushort&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;short int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_short&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;long unsigned int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_ulong&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;long int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_long&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;long signed int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_long&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;unsigned int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_uint&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_int&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;long long unsigned int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_ulonglong&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;long long int&quot;</span><span class="s1">: </span><span class="s4">&quot;c_longlong&quot;</span><span class="s2">,</span>

    <span class="s4">&quot;double&quot;</span><span class="s1">: </span><span class="s4">&quot;c_double&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;float&quot;</span><span class="s1">: </span><span class="s4">&quot;c_float&quot;</span><span class="s2">,</span>

    <span class="s0"># Hm...</span>
    <span class="s4">&quot;void&quot;</span><span class="s1">: </span><span class="s4">&quot;None&quot;</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s2">def </span><span class="s1">get_real_type(tp):</span>
    <span class="s2">if </span><span class="s1">type(tp) </span><span class="s2">is </span><span class="s1">typedesc.Typedef:</span>
        <span class="s2">return </span><span class="s1">get_real_type(tp.typ)</span>
    <span class="s2">elif </span><span class="s1">isinstance(tp</span><span class="s2">, </span><span class="s1">typedesc.CvQualifiedType):</span>
        <span class="s2">return </span><span class="s1">get_real_type(tp.typ)</span>
    <span class="s2">return </span><span class="s1">tp</span>

<span class="s1">ASSUME_STRINGS = </span><span class="s2">True</span>

<span class="s2">def </span><span class="s1">_calc_packing(struct</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">, </span><span class="s1">isStruct):</span>
    <span class="s0"># Try a certain packing, raise PackingError if field offsets,</span>
    <span class="s0"># total size ot total alignment is wrong.</span>
    <span class="s2">if </span><span class="s1">struct.size </span><span class="s2">is None</span><span class="s1">: </span><span class="s0"># incomplete struct</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s3">1</span>
    <span class="s2">if </span><span class="s1">struct.name </span><span class="s2">in </span><span class="s1">dont_assert_size:</span>
        <span class="s2">return None</span>
    <span class="s2">if </span><span class="s1">struct.bases:</span>
        <span class="s1">size = struct.bases[</span><span class="s3">0</span><span class="s1">].size</span>
        <span class="s1">total_align = struct.bases[</span><span class="s3">0</span><span class="s1">].align</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">size = </span><span class="s3">0</span>
        <span class="s1">total_align = </span><span class="s3">8 </span><span class="s0"># in bits</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">enumerate(fields):</span>
        <span class="s2">if </span><span class="s1">f.bits: </span><span class="s0"># this code cannot handle bit field sizes.</span>
            <span class="s0"># print &quot;##XXX FIXME&quot;</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s3">2 </span><span class="s0"># XXX FIXME</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">a = storage(f.typ)</span>
        <span class="s2">if </span><span class="s1">pack </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">a = min(pack</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s2">if </span><span class="s1">size % a:</span>
            <span class="s1">size += a - size % a</span>
        <span class="s2">if </span><span class="s1">isStruct:</span>
            <span class="s2">if </span><span class="s1">size != f.offset:</span>
                <span class="s2">raise </span><span class="s1">PackingError(</span><span class="s4">&quot;field %s offset (%s/%s)&quot; </span><span class="s1">% (f.name</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">f.offset))</span>
            <span class="s1">size += s</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">size = max(size</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s1">total_align = max(total_align</span><span class="s2">, </span><span class="s1">a)</span>
    <span class="s2">if </span><span class="s1">total_align != struct.align:</span>
        <span class="s2">raise </span><span class="s1">PackingError(</span><span class="s4">&quot;total alignment (%s/%s)&quot; </span><span class="s1">% (total_align</span><span class="s2">, </span><span class="s1">struct.align))</span>
    <span class="s1">a = total_align</span>
    <span class="s2">if </span><span class="s1">pack </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">a = min(pack</span><span class="s2">, </span><span class="s1">a)</span>
    <span class="s2">if </span><span class="s1">size % a:</span>
        <span class="s1">size += a - size % a</span>
    <span class="s2">if </span><span class="s1">size != struct.size:</span>
        <span class="s2">raise </span><span class="s1">PackingError(</span><span class="s4">&quot;total size (%s/%s)&quot; </span><span class="s1">% (size</span><span class="s2">, </span><span class="s1">struct.size))</span>

<span class="s2">def </span><span class="s1">calc_packing(struct</span><span class="s2">, </span><span class="s1">fields):</span>
    <span class="s0"># try several packings, starting with unspecified packing</span>
    <span class="s1">isStruct = isinstance(struct</span><span class="s2">, </span><span class="s1">typedesc.Structure)</span>
    <span class="s2">for </span><span class="s1">pack </span><span class="s2">in </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">16</span><span class="s1">*</span><span class="s3">8</span><span class="s2">, </span><span class="s3">8</span><span class="s1">*</span><span class="s3">8</span><span class="s2">, </span><span class="s3">4</span><span class="s1">*</span><span class="s3">8</span><span class="s2">, </span><span class="s3">2</span><span class="s1">*</span><span class="s3">8</span><span class="s2">, </span><span class="s3">1</span><span class="s1">*</span><span class="s3">8</span><span class="s1">]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">_calc_packing(struct</span><span class="s2">, </span><span class="s1">fields</span><span class="s2">, </span><span class="s1">pack</span><span class="s2">, </span><span class="s1">isStruct)</span>
        <span class="s2">except </span><span class="s1">PackingError </span><span class="s2">as </span><span class="s1">details:</span>
            <span class="s2">continue</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pack </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>

            <span class="s2">return </span><span class="s1">int(pack / </span><span class="s3">8</span><span class="s1">)</span>

    <span class="s2">raise </span><span class="s1">PackingError(</span><span class="s4">&quot;PACKING FAILED: %s&quot; </span><span class="s1">% details)</span>

<span class="s2">class </span><span class="s1">PackingError(Exception):</span>
    <span class="s2">pass</span>

<span class="s0"># XXX These should be filtered out in gccxmlparser.</span>
<span class="s1">dont_assert_size = set(</span>
    <span class="s1">[</span>
    <span class="s4">&quot;__si_class_type_info_pseudo&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;__class_type_info_pseudo&quot;</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">)</span>

<span class="s2">def </span><span class="s1">storage(t):</span>
    <span class="s0"># return the size and alignment of a type</span>
    <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.Typedef):</span>
        <span class="s2">return </span><span class="s1">storage(t.typ)</span>
    <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.ArrayType):</span>
        <span class="s1">s</span><span class="s2">, </span><span class="s1">a = storage(t.typ)</span>
        <span class="s2">return </span><span class="s1">s * (int(t.max) - int(t.min) + </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a</span>
    <span class="s2">return </span><span class="s1">int(t.size)</span><span class="s2">, </span><span class="s1">int(t.align)</span>

<span class="s0">################################################################</span>

<span class="s2">class </span><span class="s1">Generator(object):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ofi</span><span class="s2">, </span><span class="s1">known_symbols=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.output = ofi</span>
        <span class="s1">self.stream = io.StringIO()</span>
        <span class="s1">self.imports = ImportedNamespaces()</span>
        <span class="s1">self.declarations = DeclaredNamespaces()</span>
        <span class="s1">self.known_symbols = known_symbols </span><span class="s2">or </span><span class="s1">{}</span>

        <span class="s1">self.done = set() </span><span class="s0"># type descriptions that have been generated</span>
        <span class="s1">self.names = set() </span><span class="s0"># names that have been generated</span>
        <span class="s1">self.last_item_class = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">generate(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s2">if </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.done:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">typedesc.StructureHead):</span>
            <span class="s1">name = getattr(item.struct</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = getattr(item</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.known_symbols:</span>
            <span class="s1">self.imports.add(name</span><span class="s2">, </span><span class="s1">symbols=self.known_symbols)</span>

            <span class="s1">self.done.add(item)</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">typedesc.Structure):</span>
                <span class="s1">self.done.add(item.get_head())</span>
                <span class="s1">self.done.add(item.get_body())</span>
            <span class="s2">return</span>
        <span class="s1">mth = getattr(self</span><span class="s2">, </span><span class="s1">type(item).__name__)</span>
        <span class="s0"># to avoid infinite recursion, we have to mark it as done</span>
        <span class="s0"># before actually generating the code.</span>
        <span class="s1">self.done.add(item)</span>
        <span class="s1">mth(item)</span>

    <span class="s2">def </span><span class="s1">generate_all(self</span><span class="s2">, </span><span class="s1">items):</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s1">self.generate(item)</span>

    <span class="s2">def </span><span class="s1">_make_relative_path(self</span><span class="s2">, </span><span class="s1">path1</span><span class="s2">, </span><span class="s1">path2):</span>
        <span class="s5">&quot;&quot;&quot;path1 and path2 are pathnames. 
        Return path1 as a relative path to path2, if possible. 
        &quot;&quot;&quot;</span>
        <span class="s1">path1 = os.path.abspath(path1)</span>
        <span class="s1">path2 = os.path.abspath(path2)</span>
        <span class="s1">common = os.path.commonprefix([os.path.normcase(path1)</span><span class="s2">,</span>
                                       <span class="s1">os.path.normcase(path2)])</span>
        <span class="s2">if not </span><span class="s1">os.path.isdir(common):</span>
            <span class="s2">return </span><span class="s1">path1</span>
        <span class="s2">if not </span><span class="s1">common.endswith(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">path1</span>
        <span class="s2">if not </span><span class="s1">os.path.isdir(path2):</span>
            <span class="s1">path2 = os.path.dirname(path2)</span>
        <span class="s0"># strip the common prefix</span>
        <span class="s1">path1 = path1[len(common):]</span>
        <span class="s1">path2 = path2[len(common):]</span>

        <span class="s1">parts2 = path2.split(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s4">&quot;..</span><span class="s2">\\</span><span class="s4">&quot; </span><span class="s1">* len(parts2) + path1</span>

    <span class="s2">def </span><span class="s1">_generate_typelib_path(self</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s0"># NOTE: the logic in this function appears completely different from that</span>
        <span class="s0"># of the handling of tlib (given as a string) in GetModule. There, relative</span>
        <span class="s0"># references are resolved wrt to the directory of the calling module. Here,</span>
        <span class="s0"># resolution is with respect to current working directory -- later to be</span>
        <span class="s0"># relativized to comtypes.gen.</span>
        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">os.path.isabs(filename):</span>
                <span class="s0"># absolute path</span>
                <span class="s1">self.declarations.add(</span><span class="s4">&quot;typelib_path&quot;</span><span class="s2">, </span><span class="s1">repr(filename))</span>
            <span class="s2">elif not </span><span class="s1">os.path.dirname(filename) </span><span class="s2">and not </span><span class="s1">os.path.isfile(filename):</span>
                <span class="s0"># no directory given, and not in current directory.</span>
                <span class="s1">self.declarations.add(</span><span class="s4">&quot;typelib_path&quot;</span><span class="s2">, </span><span class="s1">repr(filename))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># relative path; make relative to comtypes.gen.</span>
                <span class="s1">path = self._make_relative_path(filename</span><span class="s2">, </span><span class="s1">comtypes.gen.__path__[</span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">self.imports.add(</span><span class="s4">'os'</span><span class="s1">)</span>
                <span class="s1">definition = </span><span class="s4">&quot;os.path.normpath(</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s1">\</span>
                    <span class="s4">&quot;    os.path.abspath(os.path.join(os.path.dirname(__file__),</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s1">\</span>
                    <span class="s4">&quot;                                 %r)))&quot; </span><span class="s1">% path</span>
                <span class="s1">self.declarations.add(</span><span class="s4">&quot;typelib_path&quot;</span><span class="s2">, </span><span class="s1">definition)</span>
                <span class="s1">p = os.path.normpath(os.path.abspath(os.path.join(comtypes.gen.__path__[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                                                                  <span class="s1">path)))</span>
                <span class="s2">assert </span><span class="s1">os.path.isfile(p)</span>

    <span class="s2">def </span><span class="s1">generate_code(self</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, </span><span class="s1">filename):</span>

        <span class="s1">tlib_mtime = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># get full path to DLL first (os.stat can't work with relative DLL paths properly)</span>
            <span class="s1">loaded_typelib = comtypes.typeinfo.LoadTypeLib(filename)</span>
            <span class="s1">full_filename = comtypes.tools.tlbparser.get_tlib_filename(</span>
                <span class="s1">loaded_typelib)</span>

            <span class="s2">while </span><span class="s1">full_filename </span><span class="s2">and not </span><span class="s1">os.path.exists(full_filename):</span>
                <span class="s1">full_filename = os.path.split(full_filename)[</span><span class="s3">0</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">full_filename </span><span class="s2">and </span><span class="s1">os.path.isfile(full_filename):</span>
                <span class="s0"># get DLL timestamp at the moment of wrapper generation</span>

                <span class="s1">tlib_mtime = os.stat(full_filename).st_mtime</span>

                <span class="s2">if not </span><span class="s1">full_filename.endswith(filename):</span>
                    <span class="s1">filename = full_filename</span>

        <span class="s1">self.filename = filename</span>
        <span class="s1">self.declarations.add(</span><span class="s4">&quot;_lcid&quot;</span><span class="s2">, </span><span class="s4">&quot;0&quot;</span><span class="s2">, </span><span class="s4">&quot;change this if required&quot;</span><span class="s1">)</span>
        <span class="s1">self._generate_typelib_path(filename)</span>

        <span class="s1">items = set(items)</span>
        <span class="s1">loops = </span><span class="s3">0</span>
        <span class="s2">while </span><span class="s1">items:</span>
            <span class="s1">loops += </span><span class="s3">1</span>
            <span class="s1">self.more = set()</span>
            <span class="s1">self.generate_all(items)</span>

            <span class="s1">items |= self.more</span>
            <span class="s1">items -= self.done</span>

        <span class="s1">self.imports.add(</span><span class="s4">&quot;ctypes&quot;</span><span class="s2">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)  </span><span class="s0"># HACK: wildcard import is so ugly.</span>
        <span class="s2">if </span><span class="s1">tlib_mtime </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">logger.debug(</span><span class="s4">&quot;filename: </span><span class="s2">\&quot;</span><span class="s4">%s</span><span class="s2">\&quot;</span><span class="s4">: tlib_mtime: %s&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">tlib_mtime)</span>
            <span class="s1">self.imports.add(</span><span class="s4">'comtypes'</span><span class="s2">, </span><span class="s4">'_check_version'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">filename </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># Hm, what is the CORRECT encoding?</span>
            <span class="s1">print(</span><span class="s4">&quot;# -*- coding: mbcs -*-&quot;</span><span class="s2">, </span><span class="s1">file=self.output)</span>
            <span class="s1">print(file=self.output)</span>
        <span class="s1">print(self.imports.getvalue()</span><span class="s2">, </span><span class="s1">file=self.output)</span>
        <span class="s1">print(file=self.output)</span>
        <span class="s1">print(self.declarations.getvalue()</span><span class="s2">, </span><span class="s1">file=self.output)</span>
        <span class="s1">print(file=self.output)</span>
        <span class="s1">print(self.stream.getvalue()</span><span class="s2">, </span><span class="s1">file=self.output)</span>
        <span class="s1">dunder_all = </span><span class="s4">&quot;__all__ = [%s]&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(repr(str(n)) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.names)</span>
        <span class="s2">if </span><span class="s1">len(dunder_all) &gt; </span><span class="s3">80</span><span class="s1">:</span>
            <span class="s1">wrapper = textwrap.TextWrapper(subsequent_indent=</span><span class="s4">&quot;    &quot;</span><span class="s2">,</span>
                                           <span class="s1">initial_indent=</span><span class="s4">&quot;    &quot;</span><span class="s2">,</span>
                                           <span class="s1">break_long_words=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">names = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(repr(str(n)) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">self.names)</span>
            <span class="s1">dunder_all = </span><span class="s4">&quot;__all__ = [</span><span class="s2">\n</span><span class="s4">%s</span><span class="s2">\n</span><span class="s4">]&quot; </span><span class="s1">% </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(wrapper.wrap(names))</span>
        <span class="s1">print(dunder_all</span><span class="s2">, </span><span class="s1">file=self.output)</span>
        <span class="s1">print(file=self.output)</span>
        <span class="s2">if </span><span class="s1">tlib_mtime </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;_check_version(%r, %f)&quot; </span><span class="s1">% (version</span><span class="s2">, </span><span class="s1">tlib_mtime)</span><span class="s2">,</span>
                    <span class="s1">file=self.output)</span>

        <span class="s2">return </span><span class="s1">loops</span>

    <span class="s2">def </span><span class="s1">type_name(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0"># Return a string, containing an expression which can be used</span>
        <span class="s0"># to refer to the type. Assumes the 'from ctypes import *'</span>
        <span class="s0"># namespace is available.</span>
        <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.SAFEARRAYType):</span>
            <span class="s2">return </span><span class="s4">&quot;_midlSAFEARRAY(%s)&quot; </span><span class="s1">% self.type_name(t.typ)</span>
        <span class="s0"># if isinstance(t, typedesc.CoClass):</span>
        <span class="s0">#     return &quot;%s._com_interfaces_[0]&quot; % t.name</span>
        <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.Typedef):</span>
            <span class="s2">return </span><span class="s1">t.name</span>
        <span class="s2">if </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.PointerType):</span>
            <span class="s2">if </span><span class="s1">ASSUME_STRINGS:</span>
                <span class="s1">x = get_real_type(t.typ)</span>
                <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">typedesc.FundamentalType):</span>
                    <span class="s2">if </span><span class="s1">x.name == </span><span class="s4">&quot;char&quot;</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s4">&quot;STRING&quot;</span>
                    <span class="s2">elif </span><span class="s1">x.name == </span><span class="s4">&quot;wchar_t&quot;</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s4">&quot;WSTRING&quot;</span>

            <span class="s1">result = </span><span class="s4">&quot;POINTER(%s)&quot; </span><span class="s1">% self.type_name(t.typ)</span>
            <span class="s0"># XXX Better to inspect t.typ!</span>
            <span class="s2">if </span><span class="s1">result.startswith(</span><span class="s4">&quot;POINTER(WINFUNCTYPE&quot;</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">result[len(</span><span class="s4">&quot;POINTER(&quot;</span><span class="s1">):-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">result.startswith(</span><span class="s4">&quot;POINTER(CFUNCTYPE&quot;</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">result[len(</span><span class="s4">&quot;POINTER(&quot;</span><span class="s1">):-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">result == </span><span class="s4">&quot;POINTER(None)&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s4">&quot;c_void_p&quot;</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.ArrayType):</span>
            <span class="s2">return </span><span class="s4">&quot;%s * %s&quot; </span><span class="s1">% (self.type_name(t.typ)</span><span class="s2">, </span><span class="s1">int(t.max)+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.FunctionType):</span>
            <span class="s1">args = [self.type_name(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">[t.returns] + list(t.iterArgTypes())]</span>
            <span class="s2">if </span><span class="s4">&quot;__stdcall__&quot; </span><span class="s2">in </span><span class="s1">t.attributes:</span>
                <span class="s2">return </span><span class="s4">&quot;WINFUNCTYPE(%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(args)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s4">&quot;CFUNCTYPE(%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(args)</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.CvQualifiedType):</span>
            <span class="s0"># const and volatile are ignored</span>
            <span class="s2">return </span><span class="s4">&quot;%s&quot; </span><span class="s1">% self.type_name(t.typ)</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.FundamentalType):</span>
            <span class="s2">return </span><span class="s1">ctypes_names[t.name]</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.Structure):</span>
            <span class="s2">return </span><span class="s1">t.name</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.Enumeration):</span>
            <span class="s2">if </span><span class="s1">t.name:</span>
                <span class="s2">return </span><span class="s1">t.name</span>
            <span class="s2">return </span><span class="s4">&quot;c_int&quot; </span><span class="s0"># enums are integers</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.EnumValue):</span>
            <span class="s2">if </span><span class="s1">keyword.iskeyword(t.name):</span>
                <span class="s2">return </span><span class="s1">t.name + </span><span class="s4">&quot;_&quot;</span>
            <span class="s2">return </span><span class="s1">t.name</span>
        <span class="s2">elif </span><span class="s1">isinstance(t</span><span class="s2">, </span><span class="s1">typedesc.External):</span>
            <span class="s0"># t.symbol_name - symbol to generate</span>
            <span class="s0"># t.tlib - the ITypeLib pointer to the typelibrary containing the symbols definition</span>
            <span class="s1">modname = comtypes.client._generate._name_module(t.tlib)</span>
            <span class="s2">return </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (modname</span><span class="s2">, </span><span class="s1">t.symbol_name)</span>
        <span class="s2">return </span><span class="s1">t.name</span>

    <span class="s2">def </span><span class="s1">need_VARIANT_imports(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">text = repr(value)</span>
        <span class="s2">if </span><span class="s4">&quot;Decimal(&quot; </span><span class="s2">in </span><span class="s1">text:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;decimal&quot;</span><span class="s2">, </span><span class="s4">&quot;Decimal&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s4">&quot;datetime.datetime(&quot; </span><span class="s2">in </span><span class="s1">text:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;datetime&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">need_GUID(self):</span>
        <span class="s2">if </span><span class="s4">&quot;GUID&quot; </span><span class="s2">in </span><span class="s1">self.known_symbols:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;GUID&quot;</span><span class="s2">, </span><span class="s1">symbols=self.known_symbols)</span>

    <span class="s2">def </span><span class="s1">_to_docstring(self</span><span class="s2">, </span><span class="s1">orig</span><span class="s2">, </span><span class="s1">depth=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s0"># type: (str, int) -&gt; str</span>
        <span class="s0"># increasing `depth` by one increases indentation by one</span>
        <span class="s1">indent = </span><span class="s4">&quot;    &quot; </span><span class="s1">* depth</span>
        <span class="s0"># some chars are replaced to avoid causing a `SyntaxError`</span>
        <span class="s1">repled = orig.replace(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s4">r&quot;\\&quot;</span><span class="s1">).replace(</span><span class="s4">&quot;</span><span class="s2">\&quot;</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s4">r&quot;'&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s4">'%s&quot;&quot;&quot;%s&quot;&quot;&quot;' </span><span class="s1">% (indent</span><span class="s2">, </span><span class="s1">repled)</span>

    <span class="s1">_arraytypes = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">ArrayType(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self._arraytypes += </span><span class="s3">1</span>
        <span class="s1">self.generate(get_real_type(tp.typ))</span>
        <span class="s1">self.generate(tp.typ)</span>

    <span class="s1">_enumvalues = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">EnumValue(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s1">value = int(tp.value)</span>
        <span class="s2">if </span><span class="s1">keyword.iskeyword(tp.name):</span>
            <span class="s0"># XXX use logging!</span>
            <span class="s2">if </span><span class="s1">__warn_on_munge__:</span>
                <span class="s1">print(</span><span class="s4">&quot;# Fixing keyword as EnumValue for %s&quot; </span><span class="s1">% tp.name)</span>
        <span class="s1">tp_name = self.type_name(tp)</span>
        <span class="s1">print(</span><span class="s4">&quot;%s = %d&quot; </span><span class="s1">% (tp_name</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">self.names.add(tp_name)</span>
        <span class="s1">self._enumvalues += </span><span class="s3">1</span>

    <span class="s1">_enumtypes = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">Enumeration(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self._enumtypes += </span><span class="s3">1</span>
        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">tp.name:</span>
            <span class="s1">print(</span><span class="s4">&quot;# values for enumeration '%s'&quot; </span><span class="s1">% tp.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;# values for unnamed enumeration&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s0"># Some enumerations have the same name for the enum type</span>
        <span class="s0"># and an enum value.  Excel's XlDisplayShapes is such an example.</span>
        <span class="s0"># Since we don't have separate namespaces for the type and the values,</span>
        <span class="s0"># we generate the TYPE last, overwriting the value. XXX</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">tp.values:</span>
            <span class="s1">self.generate(item)</span>
        <span class="s2">if </span><span class="s1">tp.name:</span>
            <span class="s1">print(</span><span class="s4">&quot;%s = c_int  # enum&quot; </span><span class="s1">% tp.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">self.names.add(tp.name)</span>

    <span class="s1">_typedefs = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">Typedef(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self._typedefs += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">type(tp.typ) </span><span class="s2">in </span><span class="s1">(typedesc.Structure</span><span class="s2">, </span><span class="s1">typedesc.Union):</span>
            <span class="s1">self.generate(tp.typ.get_head())</span>
            <span class="s1">self.more.add(tp.typ)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generate(tp.typ)</span>
        <span class="s1">definition = self.type_name(tp.typ)</span>
        <span class="s2">if </span><span class="s1">tp.name != definition:</span>
            <span class="s2">if </span><span class="s1">definition </span><span class="s2">in </span><span class="s1">self.known_symbols:</span>
                <span class="s1">self.declarations.add(tp.name</span><span class="s2">, </span><span class="s1">definition)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s4">&quot;%s = %s&quot; </span><span class="s1">% (tp.name</span><span class="s2">, </span><span class="s1">definition)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s1">self.names.add(tp.name)</span>

    <span class="s2">def </span><span class="s1">FundamentalType(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s2">pass </span><span class="s0"># we should check if this is known somewhere</span>

    <span class="s2">def </span><span class="s1">StructureHead(self</span><span class="s2">, </span><span class="s1">head):</span>
        <span class="s2">for </span><span class="s1">struct </span><span class="s2">in </span><span class="s1">head.struct.bases:</span>
            <span class="s1">self.generate(struct.get_head())</span>
            <span class="s1">self.more.add(struct)</span>
        <span class="s2">if </span><span class="s1">head.struct.location:</span>
            <span class="s1">self.last_item_class = </span><span class="s2">False</span>
            <span class="s1">print(</span><span class="s4">&quot;# %s %s&quot; </span><span class="s1">% head.struct.location</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">basenames = [self.type_name(b) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">head.struct.bases]</span>
        <span class="s2">if </span><span class="s1">basenames:</span>
            <span class="s1">self.need_GUID()</span>

            <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>

            <span class="s1">self.last_item_class = </span><span class="s2">True</span>

            <span class="s1">method_names = [m.name </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">head.struct.members </span><span class="s2">if </span><span class="s1">type(m) </span><span class="s2">is </span><span class="s1">typedesc.Method]</span>
            <span class="s1">print(</span><span class="s4">&quot;class %s(%s):&quot; </span><span class="s1">% (head.struct.name</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(basenames))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;    _iid_ = GUID('{}') # please look up iid and fill in!&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">if </span><span class="s4">&quot;Enum&quot; </span><span class="s2">in </span><span class="s1">method_names:</span>
                <span class="s1">print(</span><span class="s4">&quot;    def __iter__(self):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;        return self.Enum()&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">method_names == </span><span class="s4">&quot;Next Skip Reset Clone&quot;</span><span class="s1">.split():</span>
                <span class="s1">print(</span><span class="s4">&quot;    def __iter__(self):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;        return self&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;    def next(self):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;         arr, fetched = self.Next(1)&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;         if fetched == 0:&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;             raise StopIteration&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;         return arr[0]&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">methods = [m </span><span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">head.struct.members </span><span class="s2">if </span><span class="s1">type(m) </span><span class="s2">is </span><span class="s1">typedesc.Method]</span>

            <span class="s2">if </span><span class="s1">methods:</span>
                <span class="s0"># Hm. We cannot generate code for IUnknown...</span>
                <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                    <span class="s1">print(file=self.stream)</span>

                <span class="s1">self.last_item_class = </span><span class="s2">True</span>
                <span class="s1">print(</span><span class="s4">&quot;assert 0, 'cannot generate code for IUnknown'&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;class %s(_com_interface):&quot; </span><span class="s1">% head.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;    pass&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">type(head.struct) == typedesc.Structure:</span>
                <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                    <span class="s1">print(file=self.stream)</span>
                    <span class="s1">print(file=self.stream)</span>

                <span class="s1">self.last_item_class = </span><span class="s2">True</span>

                <span class="s1">print(</span><span class="s4">&quot;class %s(Structure):&quot; </span><span class="s1">% head.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s2">if </span><span class="s1">hasattr(head.struct</span><span class="s2">, </span><span class="s4">&quot;_recordinfo_&quot;</span><span class="s1">):</span>
                    <span class="s1">print(</span><span class="s4">&quot;    _recordinfo_ = %r&quot; </span><span class="s1">% (head.struct._recordinfo_</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    pass&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">type(head.struct) == typedesc.Union:</span>
                <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                    <span class="s1">print(file=self.stream)</span>
                    <span class="s1">print(file=self.stream)</span>

                <span class="s1">self.last_item_class = </span><span class="s2">True</span>

                <span class="s1">print(</span><span class="s4">&quot;class %s(Union):&quot; </span><span class="s1">% head.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;    pass&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">print(file=self.stream)</span>
        <span class="s1">self.names.add(head.struct.name)</span>

    <span class="s1">_structures = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">Structure(self</span><span class="s2">, </span><span class="s1">struct):</span>
        <span class="s1">self._structures += </span><span class="s3">1</span>
        <span class="s1">self.generate(struct.get_head())</span>
        <span class="s1">self.generate(struct.get_body())</span>

    <span class="s1">Union = Structure</span>

    <span class="s2">def </span><span class="s1">StructureBody(self</span><span class="s2">, </span><span class="s1">body):</span>
        <span class="s1">fields = []</span>
        <span class="s1">methods = []</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.struct.members:</span>
            <span class="s2">if </span><span class="s1">type(m) </span><span class="s2">is </span><span class="s1">typedesc.Field:</span>
                <span class="s1">fields.append(m)</span>
                <span class="s2">if </span><span class="s1">type(m.typ) </span><span class="s2">is </span><span class="s1">typedesc.Typedef:</span>
                    <span class="s1">self.generate(get_real_type(m.typ))</span>
                <span class="s1">self.generate(m.typ)</span>
            <span class="s2">elif </span><span class="s1">type(m) </span><span class="s2">is </span><span class="s1">typedesc.Method:</span>
                <span class="s1">methods.append(m)</span>
                <span class="s1">self.generate(m.returns)</span>
                <span class="s1">self.generate_all(m.iterArgTypes())</span>
            <span class="s2">elif </span><span class="s1">type(m) </span><span class="s2">is </span><span class="s1">typedesc.Constructor:</span>
                <span class="s2">pass</span>

        <span class="s0"># we don't need _pack_ on Unions (I hope, at least), and not</span>
        <span class="s0"># on COM interfaces:</span>
        <span class="s2">if not </span><span class="s1">methods:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">pack = calc_packing(body.struct</span><span class="s2">, </span><span class="s1">fields)</span>
                <span class="s2">if </span><span class="s1">pack </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.last_item_class = </span><span class="s2">False</span>
                    <span class="s1">print(</span><span class="s4">&quot;%s._pack_ = %s&quot; </span><span class="s1">% (body.struct.name</span><span class="s2">, </span><span class="s1">pack)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">except </span><span class="s1">PackingError </span><span class="s2">as </span><span class="s1">details:</span>
                <span class="s0"># if packing fails, write a warning comment to the output.</span>
                <span class="s2">import </span><span class="s1">warnings</span>
                <span class="s1">message = </span><span class="s4">&quot;Structure %s: %s&quot; </span><span class="s1">% (body.struct.name</span><span class="s2">, </span><span class="s1">details)</span>
                <span class="s1">warnings.warn(message</span><span class="s2">, </span><span class="s1">UserWarning)</span>
                <span class="s1">print(</span><span class="s4">&quot;# WARNING: %s&quot; </span><span class="s1">% details</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">self.last_item_class = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">fields:</span>
            <span class="s2">if </span><span class="s1">body.struct.bases:</span>
                <span class="s2">assert </span><span class="s1">len(body.struct.bases) == </span><span class="s3">1</span>
                <span class="s1">self.generate(body.struct.bases[</span><span class="s3">0</span><span class="s1">].get_body())</span>
            <span class="s0"># field definition normally span several lines.</span>
            <span class="s0"># Before we generate them, we need to 'import' everything they need.</span>
            <span class="s0"># So, call type_name for each field once,</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields:</span>
                <span class="s1">self.type_name(f.typ)</span>

            <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                <span class="s1">print(file=self.stream)</span>

            <span class="s1">self.last_item_class = </span><span class="s2">False</span>

            <span class="s1">print(</span><span class="s4">&quot;%s._fields_ = [&quot; </span><span class="s1">% body.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">if </span><span class="s1">body.struct.location:</span>
                <span class="s1">print(</span><span class="s4">&quot;    # %s %s&quot; </span><span class="s1">% body.struct.location</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s0"># unnamed fields will get autogenerated names &quot;_&quot;, &quot;_1&quot;. &quot;_2&quot;, &quot;_3&quot;, ...</span>
            <span class="s1">unnamed_index = </span><span class="s3">0</span>
            <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields:</span>
                <span class="s2">if not </span><span class="s1">f.name:</span>
                    <span class="s2">if </span><span class="s1">unnamed_index:</span>
                        <span class="s1">fieldname = </span><span class="s4">&quot;_%d&quot; </span><span class="s1">% unnamed_index</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">fieldname = </span><span class="s4">&quot;_&quot;</span>
                    <span class="s1">unnamed_index += </span><span class="s3">1</span>
                    <span class="s1">print(</span><span class="s4">&quot;    # Unnamed field renamed to '%s'&quot; </span><span class="s1">% fieldname</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fieldname = f.name</span>
                <span class="s2">if </span><span class="s1">f.bits </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    ('%s', %s),&quot; </span><span class="s1">% (fieldname</span><span class="s2">, </span><span class="s1">self.type_name(f.typ))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    ('%s', %s, %s),&quot; </span><span class="s1">% (fieldname</span><span class="s2">, </span><span class="s1">self.type_name(f.typ)</span><span class="s2">, </span><span class="s1">f.bits)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;]&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

            <span class="s2">if </span><span class="s1">body.struct.size </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">msg = (</span><span class="s4">&quot;# The size provided by the typelib is incorrect.</span><span class="s2">\n</span><span class="s4">&quot;</span>
                       <span class="s4">&quot;# The size and alignment check for %s is skipped.&quot;</span><span class="s1">)</span>
                <span class="s1">print(msg % body.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">body.struct.name </span><span class="s2">not in </span><span class="s1">dont_assert_size:</span>
                <span class="s1">print(file=self.stream)</span>
                <span class="s1">size = body.struct.size // </span><span class="s3">8</span>
                <span class="s1">print(</span><span class="s4">&quot;assert sizeof(%s) == %s, sizeof(%s)&quot; </span><span class="s1">% \</span>
                      <span class="s1">(body.struct.name</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">body.struct.name)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">align = body.struct.align // </span><span class="s3">8</span>
                <span class="s1">print(</span><span class="s4">&quot;assert alignment(%s) == %s, alignment(%s)&quot; </span><span class="s1">% \</span>
                      <span class="s1">(body.struct.name</span><span class="s2">, </span><span class="s1">align</span><span class="s2">, </span><span class="s1">body.struct.name)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s2">if </span><span class="s1">methods:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;COMMETHOD&quot;</span><span class="s1">)</span>
            <span class="s0"># method definitions normally span several lines.</span>
            <span class="s0"># Before we generate them, we need to 'import' everything they need.</span>
            <span class="s0"># So, call type_name for each field once,</span>
            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">methods:</span>
                <span class="s1">self.type_name(m.returns)</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.iterArgTypes():</span>
                    <span class="s1">self.type_name(a)</span>

            <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
                <span class="s1">print(file=self.stream)</span>

            <span class="s1">self.last_item_class = </span><span class="s2">False</span>
            <span class="s1">print(</span><span class="s4">&quot;%s._methods_ = [&quot; </span><span class="s1">% body.struct.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">if </span><span class="s1">body.struct.location:</span>
                <span class="s1">print(</span><span class="s4">&quot;# %s %s&quot; </span><span class="s1">% body.struct.location</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

            <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">methods:</span>
                <span class="s2">if </span><span class="s1">m.location:</span>
                    <span class="s1">print(</span><span class="s4">&quot;    # %s %s&quot; </span><span class="s1">% m.location</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span>
                    <span class="s1">(</span>
                        <span class="s4">&quot;    COMMETHOD(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                        <span class="s4">&quot;        [], </span><span class="s2">\n</span><span class="s4">&quot;</span>
                        <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                        <span class="s4">&quot;        '%s',</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s1">) % (self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span><span class="s2">,</span>
                    <span class="s1">file=self.stream</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.iterArgTypes():</span>
                    <span class="s1">print(</span><span class="s4">&quot;        ([], %s),</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s1">% self.type_name(a)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                    <span class="s1">print(</span><span class="s4">&quot;    ),&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;]&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

    <span class="s0">################################################################</span>
    <span class="s0"># top-level typedesc generators</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">TypeLib(self</span><span class="s2">, </span><span class="s1">lib):</span>
        <span class="s0"># lib.name, lib.gui, lib.major, lib.minor, lib.doc</span>

        <span class="s0"># Hm, in user code we have to write:</span>
        <span class="s0"># class MyServer(COMObject, ...):</span>
        <span class="s0">#     _com_interfaces_ = [MyTypeLib.IInterface]</span>
        <span class="s0">#     _reg_typelib_ = MyTypeLib.Library._reg_typelib_</span>
        <span class="s0">#                               ^^^^^^^</span>
        <span class="s0"># Should the '_reg_typelib_' attribute be at top-level in the</span>
        <span class="s0"># generated code, instead as being an attribute of the</span>
        <span class="s0"># 'Library' symbol?</span>
        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">True</span>

        <span class="s1">print(</span><span class="s4">&quot;class Library(object):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">if </span><span class="s1">lib.doc:</span>
            <span class="s1">print(self._to_docstring(lib.doc)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s2">if </span><span class="s1">lib.name:</span>
            <span class="s1">print(</span><span class="s4">&quot;    name = %r&quot; </span><span class="s1">% lib.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s1">print(</span><span class="s4">&quot;    _reg_typelib_ = (%r, %r, %r)&quot; </span><span class="s1">% (lib.guid</span><span class="s2">, </span><span class="s1">lib.major</span><span class="s2">, </span><span class="s1">lib.minor)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>

    <span class="s2">def </span><span class="s1">External(self</span><span class="s2">, </span><span class="s1">ext):</span>
        <span class="s1">modname = comtypes.client._generate._name_module(ext.tlib)</span>
        <span class="s2">if </span><span class="s1">modname </span><span class="s2">not in </span><span class="s1">self.imports:</span>
            <span class="s1">comtypes.client.GetModule(ext.tlib)</span>
            <span class="s1">self.imports.add(modname)</span>

    <span class="s2">def </span><span class="s1">Constant(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s1">print(</span><span class="s4">&quot;%s = %r  # Constant %s&quot; </span><span class="s1">% (tp.name</span><span class="s2">,</span>
                                         <span class="s1">tp.value</span><span class="s2">,</span>
                                         <span class="s1">self.type_name(tp.typ))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">self.names.add(tp.name)</span>

    <span class="s2">def </span><span class="s1">SAFEARRAYType(self</span><span class="s2">, </span><span class="s1">sa):</span>
        <span class="s1">self.generate(sa.typ)</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes.automation&quot;</span><span class="s2">, </span><span class="s4">&quot;_midlSAFEARRAY&quot;</span><span class="s1">)</span>

    <span class="s1">_pointertypes = </span><span class="s3">0</span>
    <span class="s2">def </span><span class="s1">PointerType(self</span><span class="s2">, </span><span class="s1">tp):</span>
        <span class="s1">self._pointertypes += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">type(tp.typ) </span><span class="s2">is </span><span class="s1">typedesc.ComInterface:</span>
            <span class="s0"># this defines the class</span>
            <span class="s1">self.generate(tp.typ.get_head())</span>
            <span class="s0"># this defines the _methods_</span>
            <span class="s1">self.more.add(tp.typ)</span>
        <span class="s2">elif </span><span class="s1">type(tp.typ) </span><span class="s2">is </span><span class="s1">typedesc.PointerType:</span>
            <span class="s1">self.generate(tp.typ)</span>
        <span class="s2">elif </span><span class="s1">type(tp.typ) </span><span class="s2">in </span><span class="s1">(typedesc.Union</span><span class="s2">, </span><span class="s1">typedesc.Structure):</span>
            <span class="s1">self.generate(tp.typ.get_head())</span>
            <span class="s1">self.more.add(tp.typ)</span>
        <span class="s2">elif </span><span class="s1">type(tp.typ) </span><span class="s2">is </span><span class="s1">typedesc.Typedef:</span>
            <span class="s1">self.generate(tp.typ)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generate(tp.typ)</span>
        <span class="s2">if not </span><span class="s1">ASSUME_STRINGS:</span>
            <span class="s2">return</span>
        <span class="s1">real_type = get_real_type(tp.typ)</span>
        <span class="s2">if </span><span class="s1">isinstance(real_type</span><span class="s2">, </span><span class="s1">typedesc.FundamentalType):</span>
            <span class="s2">if </span><span class="s1">real_type.name == </span><span class="s4">&quot;char&quot;</span><span class="s1">:</span>
                <span class="s1">self.declarations.add(</span><span class="s4">&quot;STRING&quot;</span><span class="s2">, </span><span class="s4">&quot;c_char_p&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">real_type.name == </span><span class="s4">&quot;wchar_t&quot;</span><span class="s1">:</span>
                <span class="s1">self.declarations.add(</span><span class="s4">&quot;WSTRING&quot;</span><span class="s2">, </span><span class="s4">&quot;c_wchar_p&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">CoClass(self</span><span class="s2">, </span><span class="s1">coclass):</span>
        <span class="s1">self.need_GUID()</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;CoClass&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">True</span>

        <span class="s1">print(</span><span class="s4">&quot;class %s(CoClass):&quot; </span><span class="s1">% coclass.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">doc = getattr(coclass</span><span class="s2">, </span><span class="s4">&quot;doc&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doc:</span>
            <span class="s1">print(self._to_docstring(doc)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _reg_clsid_ = GUID(%r)&quot; </span><span class="s1">% coclass.clsid</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _idlflags_ = %s&quot; </span><span class="s1">% coclass.idlflags</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">if </span><span class="s1">self.filename </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;    _typelib_path_ = typelib_path&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s0"># X print &gt;&gt; self.stream, &quot;POINTER(%s).__ctypes_from_outparam__ = wrap&quot; % coclass.name</span>

        <span class="s1">libid = coclass.tlibattr.guid</span>
        <span class="s1">wMajor</span><span class="s2">, </span><span class="s1">wMinor = coclass.tlibattr.wMajorVerNum</span><span class="s2">, </span><span class="s1">coclass.tlibattr.wMinorVerNum</span>
        <span class="s1">print(</span><span class="s4">&quot;    _reg_typelib_ = (%r, %s, %s)&quot; </span><span class="s1">% (str(libid)</span><span class="s2">, </span><span class="s1">wMajor</span><span class="s2">, </span><span class="s1">wMinor)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>

        <span class="s2">for </span><span class="s1">itf</span><span class="s2">, </span><span class="s1">idlflags </span><span class="s2">in </span><span class="s1">coclass.interfaces:</span>
            <span class="s1">self.generate(itf.get_head())</span>
        <span class="s1">implemented = []</span>
        <span class="s1">sources = []</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">coclass.interfaces:</span>
            <span class="s0"># item is (interface class, impltypeflags)</span>
            <span class="s2">if </span><span class="s1">item[</span><span class="s3">1</span><span class="s1">] &amp; </span><span class="s3">2</span><span class="s1">: </span><span class="s0"># IMPLTYPEFLAG_FSOURCE</span>
                <span class="s0"># source interface</span>
                <span class="s1">where = sources</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># sink interface</span>
                <span class="s1">where = implemented</span>
            <span class="s2">if </span><span class="s1">item[</span><span class="s3">1</span><span class="s1">] &amp; </span><span class="s3">1</span><span class="s1">: </span><span class="s0"># IMPLTYPEFLAG_FDEAULT</span>
                <span class="s0"># The default interface should be the first item on the list</span>
                <span class="s1">where.insert(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">self.type_name(item[</span><span class="s3">0</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">where.append(self.type_name(item[</span><span class="s3">0</span><span class="s1">]))</span>

        <span class="s2">if </span><span class="s1">implemented:</span>
            <span class="s1">self.last_item_class = </span><span class="s2">False</span>
            <span class="s1">print(</span><span class="s4">&quot;%s._com_interfaces_ = [%s]&quot; </span><span class="s1">% (coclass.name</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(implemented))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">if </span><span class="s1">sources:</span>
            <span class="s1">self.last_item_class = </span><span class="s2">False</span>
            <span class="s1">print(</span><span class="s4">&quot;%s._outgoing_interfaces_ = [%s]&quot; </span><span class="s1">% (coclass.name</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(sources))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s1">self.names.add(coclass.name)</span>

    <span class="s2">def </span><span class="s1">ComInterface(self</span><span class="s2">, </span><span class="s1">itf):</span>
        <span class="s1">self.generate(itf.get_head())</span>
        <span class="s1">self.generate(itf.get_body())</span>
        <span class="s1">self.names.add(itf.name)</span>

    <span class="s2">def </span><span class="s1">_is_enuminterface(self</span><span class="s2">, </span><span class="s1">itf):</span>
        <span class="s0"># Check if this is an IEnumXXX interface</span>
        <span class="s2">if not </span><span class="s1">itf.name.startswith(</span><span class="s4">&quot;IEnum&quot;</span><span class="s1">):</span>
            <span class="s2">return False</span>
        <span class="s1">member_names = [mth.name </span><span class="s2">for </span><span class="s1">mth </span><span class="s2">in </span><span class="s1">itf.members]</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;Next&quot;</span><span class="s2">, </span><span class="s4">&quot;Skip&quot;</span><span class="s2">, </span><span class="s4">&quot;Reset&quot;</span><span class="s2">, </span><span class="s4">&quot;Clone&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">member_names:</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">ComInterfaceHead(self</span><span class="s2">, </span><span class="s1">head):</span>
        <span class="s2">if </span><span class="s1">head.itf.name </span><span class="s2">in </span><span class="s1">self.known_symbols:</span>
            <span class="s2">return</span>
        <span class="s1">base = head.itf.base</span>
        <span class="s2">if </span><span class="s1">head.itf.base </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># we don't beed to generate IUnknown</span>
            <span class="s2">return</span>
        <span class="s1">self.generate(base.get_head())</span>
        <span class="s1">self.more.add(base)</span>
        <span class="s1">basename = self.type_name(head.itf.base)</span>

        <span class="s1">self.need_GUID()</span>

        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">True</span>

        <span class="s1">print(</span><span class="s4">&quot;class %s(%s):&quot; </span><span class="s1">% (head.itf.name</span><span class="s2">, </span><span class="s1">basename)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">doc = getattr(head.itf</span><span class="s2">, </span><span class="s4">&quot;doc&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doc:</span>
            <span class="s1">print(self._to_docstring(doc)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s1">print(</span><span class="s4">&quot;    _case_insensitive_ = True&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _iid_ = GUID(%r)&quot; </span><span class="s1">% head.itf.iid</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _idlflags_ = %s&quot; </span><span class="s1">% head.itf.idlflags</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s2">if </span><span class="s1">self._is_enuminterface(head.itf):</span>
            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;    def __iter__(self):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        return self&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

            <span class="s1">print(</span><span class="s4">&quot;    def next(self):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        item, fetched = self.Next(1)&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        if fetched:&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;            return item&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        raise StopIteration&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

            <span class="s1">print(</span><span class="s4">&quot;    def __getitem__(self, index):&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        self.Reset()&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        self.Skip(index)&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        item, fetched = self.Next(1)&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        if fetched:&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;            return item&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;        raise IndexError(index)&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s1">print(file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>

    <span class="s2">def </span><span class="s1">ComInterfaceBody(self</span><span class="s2">, </span><span class="s1">body):</span>
        <span class="s0"># The base class must be fully generated, including the</span>
        <span class="s0"># _methods_ list.</span>
        <span class="s1">self.generate(body.itf.base)</span>

        <span class="s0"># make sure we can generate the body</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.itf.members:</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.arguments:</span>
                <span class="s1">self.generate(a[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">self.generate(m.returns)</span>

        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s1">print(</span><span class="s4">&quot;%s._methods_ = [&quot; </span><span class="s1">% body.itf.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.itf.members:</span>
            <span class="s2">if </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.ComMethod):</span>
                <span class="s1">self.make_ComMethod(m</span><span class="s2">, </span><span class="s4">&quot;dual&quot; </span><span class="s2">in </span><span class="s1">body.itf.idlflags)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;what's this?&quot;</span><span class="s1">)</span>

        <span class="s1">print(</span><span class="s4">&quot;]&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;################################################################&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;# code template for %s implementation&quot; </span><span class="s1">% body.itf.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;# class %s_Impl(object):&quot; </span><span class="s1">% body.itf.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

        <span class="s1">methods = {}</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.itf.members:</span>
            <span class="s2">if </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.ComMethod):</span>
                <span class="s0"># m.arguments is a sequence of tuples:</span>
                <span class="s0"># (argtype, argname, idlflags, docstring)</span>
                <span class="s0"># Some typelibs have unnamed method parameters!</span>
                <span class="s1">inargs = [a[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">or </span><span class="s4">'&lt;unnamed&gt;' </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.arguments</span>
                        <span class="s2">if not </span><span class="s4">'out' </span><span class="s2">in </span><span class="s1">a[</span><span class="s3">2</span><span class="s1">]]</span>
                <span class="s1">outargs = [a[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">or </span><span class="s4">'&lt;unnamed&gt;' </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.arguments</span>
                           <span class="s2">if </span><span class="s4">'out' </span><span class="s2">in </span><span class="s1">a[</span><span class="s3">2</span><span class="s1">]]</span>
                <span class="s2">if </span><span class="s4">'propget' </span><span class="s2">in </span><span class="s1">m.idlflags:</span>
                    <span class="s1">methods.setdefault(m.name</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">inargs</span><span class="s2">, </span><span class="s1">outargs</span><span class="s2">, </span><span class="s1">m.doc])[</span><span class="s3">0</span><span class="s1">] |= </span><span class="s3">1</span>
                <span class="s2">elif </span><span class="s4">'propput' </span><span class="s2">in </span><span class="s1">m.idlflags:</span>
                    <span class="s1">methods.setdefault(m.name</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">inargs[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">inargs[-</span><span class="s3">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">m.doc])[</span><span class="s3">0</span><span class="s1">] |= </span><span class="s3">2</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">methods[m.name] = [</span><span class="s3">0</span><span class="s2">, </span><span class="s1">inargs</span><span class="s2">, </span><span class="s1">outargs</span><span class="s2">, </span><span class="s1">m.doc]</span>

        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">(typ</span><span class="s2">, </span><span class="s1">inargs</span><span class="s2">, </span><span class="s1">outargs</span><span class="s2">, </span><span class="s1">doc) </span><span class="s2">in </span><span class="s1">methods.items():</span>
            <span class="s2">if </span><span class="s1">typ == </span><span class="s3">0</span><span class="s1">: </span><span class="s0"># method</span>
                <span class="s1">print(</span><span class="s4">&quot;#     def %s(%s):&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">&quot;self&quot;</span><span class="s1">] + inargs))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         %r&quot; </span><span class="s1">% (doc </span><span class="s2">or </span><span class="s4">&quot;-no docstring-&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         #return %s&quot; </span><span class="s1">% (</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(outargs))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">typ == </span><span class="s3">1</span><span class="s1">: </span><span class="s0"># propget</span>
                <span class="s1">print(</span><span class="s4">&quot;#     @property&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#     def %s(%s):&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">&quot;self&quot;</span><span class="s1">] + inargs))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         %r&quot; </span><span class="s1">% (doc </span><span class="s2">or </span><span class="s4">&quot;-no docstring-&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         #return %s&quot; </span><span class="s1">% (</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(outargs))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">typ == </span><span class="s3">2</span><span class="s1">: </span><span class="s0"># propput</span>
                <span class="s1">print(</span><span class="s4">&quot;#     def _set(%s):&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">&quot;self&quot;</span><span class="s1">] + inargs + outargs)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         %r&quot; </span><span class="s1">% (doc </span><span class="s2">or </span><span class="s4">&quot;-no docstring-&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#     %s = property(fset = _set, doc = _set.__doc__)&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">elif </span><span class="s1">typ == </span><span class="s3">3</span><span class="s1">: </span><span class="s0"># propget + propput</span>
                <span class="s1">print(</span><span class="s4">&quot;#     def _get(%s):&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">&quot;self&quot;</span><span class="s1">] + inargs)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         %r&quot; </span><span class="s1">% (doc </span><span class="s2">or </span><span class="s4">&quot;-no docstring-&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         #return %s&quot; </span><span class="s1">% (</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(outargs))</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#     def _set(%s):&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join([</span><span class="s4">&quot;self&quot;</span><span class="s1">] + inargs + outargs)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#         %r&quot; </span><span class="s1">% (doc </span><span class="s2">or </span><span class="s4">&quot;-no docstring-&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
                <span class="s1">print(</span><span class="s4">&quot;#     %s = property(_get, _set, doc = _set.__doc__)&quot; </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;BUG&quot;</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s4">&quot;#&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

    <span class="s2">def </span><span class="s1">DispInterface(self</span><span class="s2">, </span><span class="s1">itf):</span>
        <span class="s1">self.generate(itf.get_head())</span>
        <span class="s1">self.generate(itf.get_body())</span>
        <span class="s1">self.names.add(itf.name)</span>

    <span class="s2">def </span><span class="s1">DispInterfaceHead(self</span><span class="s2">, </span><span class="s1">head):</span>
        <span class="s1">self.generate(head.itf.base)</span>
        <span class="s1">basename = self.type_name(head.itf.base)</span>

        <span class="s1">self.need_GUID()</span>
        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">True</span>

        <span class="s1">print(</span><span class="s4">&quot;class %s(%s):&quot; </span><span class="s1">% (head.itf.name</span><span class="s2">, </span><span class="s1">basename)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _case_insensitive_ = True&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">doc = getattr(head.itf</span><span class="s2">, </span><span class="s4">&quot;doc&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doc:</span>
            <span class="s1">print(</span><span class="s4">&quot;    %r&quot; </span><span class="s1">% doc</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _iid_ = GUID(%r)&quot; </span><span class="s1">% head.itf.iid</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _idlflags_ = %s&quot; </span><span class="s1">% head.itf.idlflags</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(</span><span class="s4">&quot;    _methods_ = []&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>
        <span class="s1">print(file=self.stream)</span>

    <span class="s2">def </span><span class="s1">DispInterfaceBody(self</span><span class="s2">, </span><span class="s1">body):</span>
        <span class="s0"># make sure we can generate the body</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.itf.members:</span>
            <span class="s2">if </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.DispMethod):</span>
                <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">m.arguments:</span>
                    <span class="s1">self.generate(a[</span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">self.generate(m.returns)</span>
            <span class="s2">elif </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.DispProperty):</span>
                <span class="s1">self.generate(m.typ)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(m)</span>

        <span class="s2">if not </span><span class="s1">self.last_item_class:</span>
            <span class="s1">print(file=self.stream)</span>

        <span class="s1">self.last_item_class = </span><span class="s2">False</span>

        <span class="s1">print(</span><span class="s4">&quot;%s._disp_methods_ = [&quot; </span><span class="s1">% body.itf.name</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">body.itf.members:</span>
            <span class="s2">if </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.DispMethod):</span>
                <span class="s1">self.make_DispMethod(m)</span>
            <span class="s2">elif </span><span class="s1">isinstance(m</span><span class="s2">, </span><span class="s1">typedesc.DispProperty):</span>
                <span class="s1">self.make_DispProperty(m)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(m)</span>
        <span class="s1">print(</span><span class="s4">&quot;]&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

    <span class="s0">################################################################</span>
    <span class="s0"># non-toplevel method generators</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">make_ComMethod(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">isdual):</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;COMMETHOD&quot;</span><span class="s1">)</span>
        <span class="s0"># typ, name, idlflags, default</span>
        <span class="s2">if </span><span class="s1">isdual:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;dispid&quot;</span><span class="s1">)</span>
            <span class="s1">idlflags = [dispid(m.memid)] + m.idlflags</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># We don't include the dispid for non-dispatch COM interfaces</span>
            <span class="s1">idlflags = m.idlflags</span>
        <span class="s2">if __debug__ and </span><span class="s1">m.doc:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;helpstring&quot;</span><span class="s1">)</span>
            <span class="s1">idlflags.insert(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">helpstring(m.doc))</span>

        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s2">if not </span><span class="s1">m.arguments:</span>
            <span class="s1">code = </span><span class="s4">&quot;    COMMETHOD(%r, %s, '%s'),&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>
            <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                <span class="s1">code = (</span>
                    <span class="s4">&quot;    COMMETHOD(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        '%s',</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;    ),&quot;</span>
                <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>

            <span class="s1">print(code</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">code = (</span>
                <span class="s4">&quot;    COMMETHOD(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        '%s',&quot;</span>
            <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>
            <span class="s1">print(code</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">arglist = []</span>
            <span class="s2">for </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">idlflags</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">m.arguments:</span>
                <span class="s1">type_name = self.type_name(typ)</span>
                <span class="s0">###########################################################</span>
                <span class="s0"># IDL files that contain 'open arrays' or 'conformant</span>
                <span class="s0"># varying arrays' method parameters are strange.</span>
                <span class="s0"># These arrays have both a 'size_is()' and</span>
                <span class="s0"># 'length_is()' attribute, like this example from</span>
                <span class="s0"># dia2.idl (in the DIA SDK):</span>
                <span class="s0">#</span>
                <span class="s0"># interface IDiaSymbol: IUnknown {</span>
                <span class="s0"># ...</span>
                <span class="s0">#     HRESULT get_dataBytes(</span>
                <span class="s0">#         [in] DWORD cbData,</span>
                <span class="s0">#         [out] DWORD *pcbData,</span>
                <span class="s0">#         [out, size_is(cbData),</span>
                <span class="s0">#          length_is(*pcbData)] BYTE data[]</span>
                <span class="s0">#     );</span>
                <span class="s0">#</span>
                <span class="s0"># The really strange thing is that the decompiled type</span>
                <span class="s0"># library then contains this declaration, which declares</span>
                <span class="s0"># the interface itself as [out] method parameter:</span>
                <span class="s0">#</span>
                <span class="s0"># interface IDiaSymbol: IUnknown {</span>
                <span class="s0"># ...</span>
                <span class="s0">#     HRESULT _stdcall get_dataBytes(</span>
                <span class="s0">#         [in] unsigned long cbData,</span>
                <span class="s0">#         [out] unsigned long* pcbData,</span>
                <span class="s0">#         [out] IDiaSymbol data);</span>
                <span class="s0">#</span>
                <span class="s0"># Of course, comtypes does not accept a COM interface</span>
                <span class="s0"># as method parameter; so replace the parameter type</span>
                <span class="s0"># with the comtypes spelling of 'unsigned char *', and</span>
                <span class="s0"># mark the parameter as [in, out], so the IDL</span>
                <span class="s0"># equivalent would be like this:</span>
                <span class="s0">#</span>
                <span class="s0"># interface IDiaSymbol: IUnknown {</span>
                <span class="s0"># ...</span>
                <span class="s0">#     HRESULT _stdcall get_dataBytes(</span>
                <span class="s0">#         [in] unsigned long cbData,</span>
                <span class="s0">#         [out] unsigned long* pcbData,</span>
                <span class="s0">#         [in, out] BYTE data[]);</span>
                <span class="s0">###########################################################</span>
                <span class="s2">if </span><span class="s1">isinstance(typ</span><span class="s2">, </span><span class="s1">typedesc.ComInterface):</span>
                    <span class="s1">self.declarations.add(</span><span class="s4">&quot;OPENARRAY&quot;</span><span class="s2">, </span><span class="s4">&quot;POINTER(c_ubyte)&quot;</span><span class="s2">,</span>
                        <span class="s4">&quot;hack, see comtypes/tools/codegenerator.py&quot;</span><span class="s1">)</span>
                    <span class="s1">type_name = </span><span class="s4">&quot;OPENARRAY&quot;</span>
                    <span class="s2">if </span><span class="s4">'in' </span><span class="s2">not in </span><span class="s1">idlflags:</span>
                        <span class="s1">idlflags.append(</span><span class="s4">'in'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s4">'lcid' </span><span class="s2">in </span><span class="s1">idlflags:</span><span class="s0"># and 'in' in idlflags:</span>
                    <span class="s1">default = lcid</span>
                <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self.need_VARIANT_imports(default)</span>

                    <span class="s1">code = </span><span class="s4">&quot;        (%r, %s, '%s', %r)&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">type_name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default)</span>

                    <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                        <span class="s1">code = (</span>
                            <span class="s4">&quot;        (</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            '%s',</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;        )&quot;</span>
                        <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">type_name</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">code = </span><span class="s4">&quot;        (%r, %s, '%s')&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">type_name</span><span class="s2">, </span><span class="s1">name)</span>
                    <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                        <span class="s1">code = (</span>
                            <span class="s4">&quot;        (</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            '%s',</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;        )&quot;</span>
                        <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">type_name</span><span class="s2">, </span><span class="s1">name)</span>

                <span class="s1">arglist.append(code)</span>

            <span class="s1">print(</span><span class="s4">&quot;,</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(arglist)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;    ),&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

    <span class="s2">def </span><span class="s1">make_DispMethod(self</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;DISPMETHOD&quot;</span><span class="s1">)</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;dispid&quot;</span><span class="s1">)</span>
        <span class="s1">idlflags = [dispid(m.dispid)] + m.idlflags</span>
        <span class="s2">if __debug__ and </span><span class="s1">m.doc:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;helpstring&quot;</span><span class="s1">)</span>
            <span class="s1">idlflags.insert(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">helpstring(m.doc))</span>

        <span class="s1">self.last_item_class = </span><span class="s2">False</span>

        <span class="s0"># typ, name, idlflags, default</span>
        <span class="s2">if not </span><span class="s1">m.arguments:</span>
            <span class="s1">code = </span><span class="s4">&quot;    DISPMETHOD(%r, %s, '%s'),&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>
            <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                <span class="s1">code = (</span>
                    <span class="s4">&quot;    DISPMETHOD(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;        '%s'</span><span class="s2">\n</span><span class="s4">&quot;</span>
                    <span class="s4">&quot;    ),&quot;</span>
                <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>

            <span class="s1">print(code</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">code = (</span>
                <span class="s4">&quot;    DISPMETHOD(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        '%s',&quot;</span>
                <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(m.returns)</span><span class="s2">, </span><span class="s1">m.name)</span>

            <span class="s1">print(code</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

            <span class="s1">arglist = []</span>
            <span class="s2">for </span><span class="s1">typ</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">idlflags</span><span class="s2">, </span><span class="s1">default </span><span class="s2">in </span><span class="s1">m.arguments:</span>
                <span class="s1">self.need_VARIANT_imports(default)</span>
                <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">code = </span><span class="s4">&quot;        (%r, %s, '%s', %r)&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(typ)</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default)</span>
                    <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                        <span class="s1">code = (</span>
                            <span class="s4">&quot;        (</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            '%s',</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;        )&quot;</span>
                        <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(typ)</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">default)</span>


                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">code = </span><span class="s4">&quot;        (%r, %s, '%s')&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(typ)</span><span class="s2">, </span><span class="s1">name)</span>

                    <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
                        <span class="s1">code = (</span>
                            <span class="s4">&quot;        (</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;            '%s'</span><span class="s2">\n</span><span class="s4">&quot;</span>
                            <span class="s4">&quot;        )&quot;</span>
                        <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(typ)</span><span class="s2">, </span><span class="s1">name)</span>

                <span class="s1">arglist.append(code)</span>

            <span class="s1">print(</span><span class="s4">&quot;,</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(arglist)</span><span class="s2">, </span><span class="s1">file=self.stream)</span>
            <span class="s1">print(</span><span class="s4">&quot;    ),&quot;</span><span class="s2">, </span><span class="s1">file=self.stream)</span>

    <span class="s2">def </span><span class="s1">make_DispProperty(self</span><span class="s2">, </span><span class="s1">prop):</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;DISPPROPERTY&quot;</span><span class="s1">)</span>
        <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;dispid&quot;</span><span class="s1">)</span>
        <span class="s1">idlflags = [dispid(prop.dispid)] + prop.idlflags</span>
        <span class="s2">if __debug__ and </span><span class="s1">prop.doc:</span>
            <span class="s1">self.imports.add(</span><span class="s4">&quot;comtypes&quot;</span><span class="s2">, </span><span class="s4">&quot;helpstring&quot;</span><span class="s1">)</span>
            <span class="s1">idlflags.insert(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">helpstring(prop.doc))</span>

        <span class="s1">self.last_item_class = </span><span class="s2">False</span>
        <span class="s1">code = </span><span class="s4">&quot;    DISPPROPERTY(%r, %s, '%s'),&quot; </span><span class="s1">% (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(prop.typ)</span><span class="s2">, </span><span class="s1">prop.name)</span>
        <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
            <span class="s1">code = (</span>
                <span class="s4">&quot;    DISPPROPERTY(</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %r,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        %s,</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;        '%s'</span><span class="s2">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;    ),&quot;</span>
            <span class="s1">) % (idlflags</span><span class="s2">, </span><span class="s1">self.type_name(prop.typ)</span><span class="s2">, </span><span class="s1">prop.name)</span>

        <span class="s1">print(code</span><span class="s2">, </span><span class="s1">file=self.stream)</span>


<span class="s2">class </span><span class="s1">ImportedNamespaces(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">7</span><span class="s1">):</span>
            <span class="s1">self.data = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
            <span class="s1">self.data = OrderedDict()</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">name1</span><span class="s2">, </span><span class="s1">name2=</span><span class="s2">None, </span><span class="s1">symbols=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Adds a namespace will be imported. 
 
        Examples: 
            &gt;&gt;&gt; imports = ImportedNamespaces() 
            &gt;&gt;&gt; imports.add('datetime') 
            &gt;&gt;&gt; imports.add('ctypes', '*') 
            &gt;&gt;&gt; imports.add('decimal', 'Decimal') 
            &gt;&gt;&gt; imports.add('GUID', symbols={'GUID': 'comtypes'}) 
            &gt;&gt;&gt; for name in ('COMMETHOD', 'IUnknown', 'dispid', 'CoClass', 
            ...              'BSTR', 'DISPPROPERTY'): 
            ...     imports.add('comtypes', name) 
            &gt;&gt;&gt; imports.add('ctypes.wintypes') 
            &gt;&gt;&gt; print(imports.getvalue()) 
            from ctypes import * 
            import datetime 
            from decimal import Decimal 
            from comtypes import BSTR, CoClass, COMMETHOD, dispid, DISPPROPERTY, \\ 
                GUID, IUnknown 
            import ctypes.wintypes 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">import_ = name1</span>
            <span class="s2">if not </span><span class="s1">symbols:</span>
                <span class="s1">self.data[import_] = </span><span class="s2">None</span>
                <span class="s2">return</span>
            <span class="s1">from_ = symbols[import_]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">from_</span><span class="s2">, </span><span class="s1">import_ = name1</span><span class="s2">, </span><span class="s1">name2</span>
        <span class="s1">self.data[import_] = from_</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s5">&quot;&quot;&quot;Returns item has already added. 
 
        Examples: 
            &gt;&gt;&gt; imports = ImportedNamespaces() 
            &gt;&gt;&gt; imports.add('datetime') 
            &gt;&gt;&gt; imports.add('ctypes', '*') 
            &gt;&gt;&gt; 'datetime' in imports 
            True 
            &gt;&gt;&gt; ('ctypes', '*') in imports 
            True 
            &gt;&gt;&gt; 'os' in imports 
            False 
            &gt;&gt;&gt; 'ctypes' in imports 
            False 
            &gt;&gt;&gt; ('ctypes', 'c_int') in imports 
            False 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">from_</span><span class="s2">, </span><span class="s1">import_ = item</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">from_</span><span class="s2">, </span><span class="s1">import_ = </span><span class="s2">None, </span><span class="s1">item</span>
        <span class="s2">if </span><span class="s1">import_ </span><span class="s2">in </span><span class="s1">self.data:</span>
            <span class="s2">return </span><span class="s1">self.data[import_] == from_</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_make_line(self</span><span class="s2">, </span><span class="s1">import_</span><span class="s2">, </span><span class="s1">from_=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">from_ </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;import %s&quot; </span><span class="s1">% import_</span>
        <span class="s1">code = </span><span class="s4">&quot;from %s import %s&quot; </span><span class="s1">% (from_</span><span class="s2">, </span><span class="s1">import_)</span>
        <span class="s2">if </span><span class="s1">len(code) &gt; </span><span class="s3">80</span><span class="s1">:</span>
            <span class="s1">wrapper = textwrap.TextWrapper(subsequent_indent=</span><span class="s4">&quot;    &quot;</span><span class="s2">,</span>
                                           <span class="s1">break_long_words=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">code = </span><span class="s4">&quot; </span><span class="s2">\\\n</span><span class="s4">&quot;</span><span class="s1">.join(wrapper.wrap(code))</span>
        <span class="s2">return </span><span class="s1">code</span>

    <span class="s2">def </span><span class="s1">getvalue(self):</span>
        <span class="s1">ns = {}</span>
        <span class="s1">lines = []</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.data.items():</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">ns[key] = val</span>
            <span class="s2">elif </span><span class="s1">key == </span><span class="s4">&quot;*&quot;</span><span class="s1">:</span>
                <span class="s1">lines.append(self._make_line(</span><span class="s4">&quot;*&quot;</span><span class="s2">, </span><span class="s1">val))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ns.setdefault(val</span><span class="s2">, </span><span class="s1">set()).add(key)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">ns.items():</span>
            <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">lines.append(self._make_line(key))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">names = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(sorted(val</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">s: s.lower()))</span>
                <span class="s1">lines.append(self._make_line(names</span><span class="s2">, </span><span class="s1">key))</span>
        <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(lines)</span>


<span class="s2">class </span><span class="s1">DeclaredNamespaces(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s2">, </span><span class="s3">7</span><span class="s1">):</span>
            <span class="s1">self.data = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
            <span class="s1">self.data = OrderedDict()</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">definition</span><span class="s2">, </span><span class="s1">comment=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot;Adds a namespace will be declared. 
 
        Examples: 
            &gt;&gt;&gt; declarations = DeclaredNamespaces() 
            &gt;&gt;&gt; declarations.add('STRING', 'c_char_p') 
            &gt;&gt;&gt; declarations.add('_lcid', '0', 'change this if required') 
            &gt;&gt;&gt; print(declarations.getvalue()) 
            STRING = c_char_p 
            _lcid = 0  # change this if required 
        &quot;&quot;&quot;</span>
        <span class="s1">self.data[(alias</span><span class="s2">, </span><span class="s1">definition)] = comment</span>

    <span class="s2">def </span><span class="s1">getvalue(self):</span>
        <span class="s1">lines = []</span>
        <span class="s2">for </span><span class="s1">(alias</span><span class="s2">, </span><span class="s1">definition)</span><span class="s2">, </span><span class="s1">comment </span><span class="s2">in </span><span class="s1">self.data.items():</span>
            <span class="s1">code = </span><span class="s4">&quot;%s = %s&quot; </span><span class="s1">% (alias</span><span class="s2">, </span><span class="s1">definition)</span>
            <span class="s2">if </span><span class="s1">comment:</span>
                <span class="s1">code = code + </span><span class="s4">&quot;  # %s&quot; </span><span class="s1">% comment</span>
            <span class="s1">lines.append(code)</span>
        <span class="s2">return </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(lines)</span>


<span class="s0"># shortcut for development</span>
<span class="s2">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">tlbparser</span>
    <span class="s1">tlbparser.main()</span>
</pre>
</body>
</html>